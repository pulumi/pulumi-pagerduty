// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package pagerduty

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-pagerduty/sdk/v3/go/pagerduty/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumix"
)

// A [Global Orchestration](https://support.pagerduty.com/docs/event-orchestration#global-orchestrations) allows you to create a set of Event Rules. The Global Orchestration evaluates Events sent to it against each of its rules, beginning with the rules in the "start" set. When a matching rule is found, it can modify and enhance the event and can route the event to another set of rules within this Global Orchestration for further processing.
//
// ## Example of configuring a Global Orchestration
//
// This example shows creating `Team`, and `Event Orchestration` resources followed by creating a Global Orchestration to handle Events sent to that Event Orchestration.
//
// This example also shows using `priority` data source to configure `priority` action for a rule. If the Event matches the third rule in set "step-two" the resulting incident will have the Priority `P1`.
//
// This example shows a Global Orchestration that has nested sets: a rule in the "start" set has a `routeTo` action pointing at the "step-two" set.
//
// The `catchAll` actions will be applied if an Event reaches the end of any set without matching any rules in that set. In this example the `catchAll` doesn't have any `actions` so it'll leave events as-is.
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-pagerduty/sdk/v3/go/pagerduty"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			databaseTeam, err := pagerduty.NewTeam(ctx, "databaseTeam", nil)
//			if err != nil {
//				return err
//			}
//			eventOrchestration, err := pagerduty.NewEventOrchestration(ctx, "eventOrchestration", &pagerduty.EventOrchestrationArgs{
//				Team: databaseTeam.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			p1, err := pagerduty.GetPriority(ctx, &pagerduty.GetPriorityArgs{
//				Name: "P1",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = pagerduty.NewEventOrchestrationGlobal(ctx, "global", &pagerduty.EventOrchestrationGlobalArgs{
//				EventOrchestration: eventOrchestration.ID(),
//				Sets: pagerduty.EventOrchestrationGlobalSetArray{
//					&pagerduty.EventOrchestrationGlobalSetArgs{
//						Id: pulumi.String("start"),
//						Rules: pagerduty.EventOrchestrationGlobalSetRuleArray{
//							&pagerduty.EventOrchestrationGlobalSetRuleArgs{
//								Label: pulumi.String("Always annotate a note to all events"),
//								Actions: &pagerduty.EventOrchestrationGlobalSetRuleActionsArgs{
//									Annotate: pulumi.String("This incident was created by the Database Team via a Global Orchestration"),
//									RouteTo:  pulumi.String("step-two"),
//								},
//							},
//						},
//					},
//					&pagerduty.EventOrchestrationGlobalSetArgs{
//						Id: pulumi.String("step-two"),
//						Rules: pagerduty.EventOrchestrationGlobalSetRuleArray{
//							&pagerduty.EventOrchestrationGlobalSetRuleArgs{
//								Label: pulumi.String("Drop events that are marked as no-op"),
//								Conditions: pagerduty.EventOrchestrationGlobalSetRuleConditionArray{
//									&pagerduty.EventOrchestrationGlobalSetRuleConditionArgs{
//										Expression: pulumi.String("event.summary matches 'no-op'"),
//									},
//								},
//								Actions: &pagerduty.EventOrchestrationGlobalSetRuleActionsArgs{
//									DropEvent: pulumi.Bool(true),
//								},
//							},
//							&pagerduty.EventOrchestrationGlobalSetRuleArgs{
//								Label: pulumi.String("If there's something wrong on the replica, then mark the alert as a warning"),
//								Conditions: pagerduty.EventOrchestrationGlobalSetRuleConditionArray{
//									&pagerduty.EventOrchestrationGlobalSetRuleConditionArgs{
//										Expression: pulumi.String("event.custom_details.hostname matches part 'replica'"),
//									},
//								},
//								Actions: &pagerduty.EventOrchestrationGlobalSetRuleActionsArgs{
//									Severity: pulumi.String("warning"),
//								},
//							},
//							&pagerduty.EventOrchestrationGlobalSetRuleArgs{
//								Label: pulumi.String("Otherwise, set the incident to P1 and run a diagnostic"),
//								Actions: &pagerduty.EventOrchestrationGlobalSetRuleActionsArgs{
//									Priority: *pulumi.String(p1.Id),
//									AutomationAction: &pagerduty.EventOrchestrationGlobalSetRuleActionsAutomationActionArgs{
//										Name:     pulumi.String("db-diagnostic"),
//										Url:      pulumi.String("https://example.com/run-diagnostic"),
//										AutoSend: pulumi.Bool(true),
//									},
//								},
//							},
//						},
//					},
//				},
//				CatchAll: &pagerduty.EventOrchestrationGlobalCatchAllArgs{
//					Actions: nil,
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Global Orchestration can be imported using the `id` of the Event Orchestration, e.g.
//
// ```sh
//
//	$ pulumi import pagerduty:index/eventOrchestrationGlobal:EventOrchestrationGlobal global 1b49abe7-26db-4439-a715-c6d883acfb3e
//
// ```
type EventOrchestrationGlobal struct {
	pulumi.CustomResourceState

	// the `catchAll` actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	CatchAll EventOrchestrationGlobalCatchAllOutput `pulumi:"catchAll"`
	// ID of the Event Orchestration to which this Global Orchestration belongs to.
	EventOrchestration pulumi.StringOutput `pulumi:"eventOrchestration"`
	// A Global Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	Sets EventOrchestrationGlobalSetArrayOutput `pulumi:"sets"`
}

// NewEventOrchestrationGlobal registers a new resource with the given unique name, arguments, and options.
func NewEventOrchestrationGlobal(ctx *pulumi.Context,
	name string, args *EventOrchestrationGlobalArgs, opts ...pulumi.ResourceOption) (*EventOrchestrationGlobal, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CatchAll == nil {
		return nil, errors.New("invalid value for required argument 'CatchAll'")
	}
	if args.EventOrchestration == nil {
		return nil, errors.New("invalid value for required argument 'EventOrchestration'")
	}
	if args.Sets == nil {
		return nil, errors.New("invalid value for required argument 'Sets'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource EventOrchestrationGlobal
	err := ctx.RegisterResource("pagerduty:index/eventOrchestrationGlobal:EventOrchestrationGlobal", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetEventOrchestrationGlobal gets an existing EventOrchestrationGlobal resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetEventOrchestrationGlobal(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *EventOrchestrationGlobalState, opts ...pulumi.ResourceOption) (*EventOrchestrationGlobal, error) {
	var resource EventOrchestrationGlobal
	err := ctx.ReadResource("pagerduty:index/eventOrchestrationGlobal:EventOrchestrationGlobal", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering EventOrchestrationGlobal resources.
type eventOrchestrationGlobalState struct {
	// the `catchAll` actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	CatchAll *EventOrchestrationGlobalCatchAll `pulumi:"catchAll"`
	// ID of the Event Orchestration to which this Global Orchestration belongs to.
	EventOrchestration *string `pulumi:"eventOrchestration"`
	// A Global Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	Sets []EventOrchestrationGlobalSet `pulumi:"sets"`
}

type EventOrchestrationGlobalState struct {
	// the `catchAll` actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	CatchAll EventOrchestrationGlobalCatchAllPtrInput
	// ID of the Event Orchestration to which this Global Orchestration belongs to.
	EventOrchestration pulumi.StringPtrInput
	// A Global Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	Sets EventOrchestrationGlobalSetArrayInput
}

func (EventOrchestrationGlobalState) ElementType() reflect.Type {
	return reflect.TypeOf((*eventOrchestrationGlobalState)(nil)).Elem()
}

type eventOrchestrationGlobalArgs struct {
	// the `catchAll` actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	CatchAll EventOrchestrationGlobalCatchAll `pulumi:"catchAll"`
	// ID of the Event Orchestration to which this Global Orchestration belongs to.
	EventOrchestration string `pulumi:"eventOrchestration"`
	// A Global Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	Sets []EventOrchestrationGlobalSet `pulumi:"sets"`
}

// The set of arguments for constructing a EventOrchestrationGlobal resource.
type EventOrchestrationGlobalArgs struct {
	// the `catchAll` actions will be applied if an Event reaches the end of any set without matching any rules in that set.
	CatchAll EventOrchestrationGlobalCatchAllInput
	// ID of the Event Orchestration to which this Global Orchestration belongs to.
	EventOrchestration pulumi.StringInput
	// A Global Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
	Sets EventOrchestrationGlobalSetArrayInput
}

func (EventOrchestrationGlobalArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*eventOrchestrationGlobalArgs)(nil)).Elem()
}

type EventOrchestrationGlobalInput interface {
	pulumi.Input

	ToEventOrchestrationGlobalOutput() EventOrchestrationGlobalOutput
	ToEventOrchestrationGlobalOutputWithContext(ctx context.Context) EventOrchestrationGlobalOutput
}

func (*EventOrchestrationGlobal) ElementType() reflect.Type {
	return reflect.TypeOf((**EventOrchestrationGlobal)(nil)).Elem()
}

func (i *EventOrchestrationGlobal) ToEventOrchestrationGlobalOutput() EventOrchestrationGlobalOutput {
	return i.ToEventOrchestrationGlobalOutputWithContext(context.Background())
}

func (i *EventOrchestrationGlobal) ToEventOrchestrationGlobalOutputWithContext(ctx context.Context) EventOrchestrationGlobalOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EventOrchestrationGlobalOutput)
}

func (i *EventOrchestrationGlobal) ToOutput(ctx context.Context) pulumix.Output[*EventOrchestrationGlobal] {
	return pulumix.Output[*EventOrchestrationGlobal]{
		OutputState: i.ToEventOrchestrationGlobalOutputWithContext(ctx).OutputState,
	}
}

// EventOrchestrationGlobalArrayInput is an input type that accepts EventOrchestrationGlobalArray and EventOrchestrationGlobalArrayOutput values.
// You can construct a concrete instance of `EventOrchestrationGlobalArrayInput` via:
//
//	EventOrchestrationGlobalArray{ EventOrchestrationGlobalArgs{...} }
type EventOrchestrationGlobalArrayInput interface {
	pulumi.Input

	ToEventOrchestrationGlobalArrayOutput() EventOrchestrationGlobalArrayOutput
	ToEventOrchestrationGlobalArrayOutputWithContext(context.Context) EventOrchestrationGlobalArrayOutput
}

type EventOrchestrationGlobalArray []EventOrchestrationGlobalInput

func (EventOrchestrationGlobalArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EventOrchestrationGlobal)(nil)).Elem()
}

func (i EventOrchestrationGlobalArray) ToEventOrchestrationGlobalArrayOutput() EventOrchestrationGlobalArrayOutput {
	return i.ToEventOrchestrationGlobalArrayOutputWithContext(context.Background())
}

func (i EventOrchestrationGlobalArray) ToEventOrchestrationGlobalArrayOutputWithContext(ctx context.Context) EventOrchestrationGlobalArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EventOrchestrationGlobalArrayOutput)
}

func (i EventOrchestrationGlobalArray) ToOutput(ctx context.Context) pulumix.Output[[]*EventOrchestrationGlobal] {
	return pulumix.Output[[]*EventOrchestrationGlobal]{
		OutputState: i.ToEventOrchestrationGlobalArrayOutputWithContext(ctx).OutputState,
	}
}

// EventOrchestrationGlobalMapInput is an input type that accepts EventOrchestrationGlobalMap and EventOrchestrationGlobalMapOutput values.
// You can construct a concrete instance of `EventOrchestrationGlobalMapInput` via:
//
//	EventOrchestrationGlobalMap{ "key": EventOrchestrationGlobalArgs{...} }
type EventOrchestrationGlobalMapInput interface {
	pulumi.Input

	ToEventOrchestrationGlobalMapOutput() EventOrchestrationGlobalMapOutput
	ToEventOrchestrationGlobalMapOutputWithContext(context.Context) EventOrchestrationGlobalMapOutput
}

type EventOrchestrationGlobalMap map[string]EventOrchestrationGlobalInput

func (EventOrchestrationGlobalMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EventOrchestrationGlobal)(nil)).Elem()
}

func (i EventOrchestrationGlobalMap) ToEventOrchestrationGlobalMapOutput() EventOrchestrationGlobalMapOutput {
	return i.ToEventOrchestrationGlobalMapOutputWithContext(context.Background())
}

func (i EventOrchestrationGlobalMap) ToEventOrchestrationGlobalMapOutputWithContext(ctx context.Context) EventOrchestrationGlobalMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(EventOrchestrationGlobalMapOutput)
}

func (i EventOrchestrationGlobalMap) ToOutput(ctx context.Context) pulumix.Output[map[string]*EventOrchestrationGlobal] {
	return pulumix.Output[map[string]*EventOrchestrationGlobal]{
		OutputState: i.ToEventOrchestrationGlobalMapOutputWithContext(ctx).OutputState,
	}
}

type EventOrchestrationGlobalOutput struct{ *pulumi.OutputState }

func (EventOrchestrationGlobalOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**EventOrchestrationGlobal)(nil)).Elem()
}

func (o EventOrchestrationGlobalOutput) ToEventOrchestrationGlobalOutput() EventOrchestrationGlobalOutput {
	return o
}

func (o EventOrchestrationGlobalOutput) ToEventOrchestrationGlobalOutputWithContext(ctx context.Context) EventOrchestrationGlobalOutput {
	return o
}

func (o EventOrchestrationGlobalOutput) ToOutput(ctx context.Context) pulumix.Output[*EventOrchestrationGlobal] {
	return pulumix.Output[*EventOrchestrationGlobal]{
		OutputState: o.OutputState,
	}
}

// the `catchAll` actions will be applied if an Event reaches the end of any set without matching any rules in that set.
func (o EventOrchestrationGlobalOutput) CatchAll() EventOrchestrationGlobalCatchAllOutput {
	return o.ApplyT(func(v *EventOrchestrationGlobal) EventOrchestrationGlobalCatchAllOutput { return v.CatchAll }).(EventOrchestrationGlobalCatchAllOutput)
}

// ID of the Event Orchestration to which this Global Orchestration belongs to.
func (o EventOrchestrationGlobalOutput) EventOrchestration() pulumi.StringOutput {
	return o.ApplyT(func(v *EventOrchestrationGlobal) pulumi.StringOutput { return v.EventOrchestration }).(pulumi.StringOutput)
}

// A Global Orchestration must contain at least a "start" set, but can contain any number of additional sets that are routed to by other rules to form a directional graph.
func (o EventOrchestrationGlobalOutput) Sets() EventOrchestrationGlobalSetArrayOutput {
	return o.ApplyT(func(v *EventOrchestrationGlobal) EventOrchestrationGlobalSetArrayOutput { return v.Sets }).(EventOrchestrationGlobalSetArrayOutput)
}

type EventOrchestrationGlobalArrayOutput struct{ *pulumi.OutputState }

func (EventOrchestrationGlobalArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*EventOrchestrationGlobal)(nil)).Elem()
}

func (o EventOrchestrationGlobalArrayOutput) ToEventOrchestrationGlobalArrayOutput() EventOrchestrationGlobalArrayOutput {
	return o
}

func (o EventOrchestrationGlobalArrayOutput) ToEventOrchestrationGlobalArrayOutputWithContext(ctx context.Context) EventOrchestrationGlobalArrayOutput {
	return o
}

func (o EventOrchestrationGlobalArrayOutput) ToOutput(ctx context.Context) pulumix.Output[[]*EventOrchestrationGlobal] {
	return pulumix.Output[[]*EventOrchestrationGlobal]{
		OutputState: o.OutputState,
	}
}

func (o EventOrchestrationGlobalArrayOutput) Index(i pulumi.IntInput) EventOrchestrationGlobalOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *EventOrchestrationGlobal {
		return vs[0].([]*EventOrchestrationGlobal)[vs[1].(int)]
	}).(EventOrchestrationGlobalOutput)
}

type EventOrchestrationGlobalMapOutput struct{ *pulumi.OutputState }

func (EventOrchestrationGlobalMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*EventOrchestrationGlobal)(nil)).Elem()
}

func (o EventOrchestrationGlobalMapOutput) ToEventOrchestrationGlobalMapOutput() EventOrchestrationGlobalMapOutput {
	return o
}

func (o EventOrchestrationGlobalMapOutput) ToEventOrchestrationGlobalMapOutputWithContext(ctx context.Context) EventOrchestrationGlobalMapOutput {
	return o
}

func (o EventOrchestrationGlobalMapOutput) ToOutput(ctx context.Context) pulumix.Output[map[string]*EventOrchestrationGlobal] {
	return pulumix.Output[map[string]*EventOrchestrationGlobal]{
		OutputState: o.OutputState,
	}
}

func (o EventOrchestrationGlobalMapOutput) MapIndex(k pulumi.StringInput) EventOrchestrationGlobalOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *EventOrchestrationGlobal {
		return vs[0].(map[string]*EventOrchestrationGlobal)[vs[1].(string)]
	}).(EventOrchestrationGlobalOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*EventOrchestrationGlobalInput)(nil)).Elem(), &EventOrchestrationGlobal{})
	pulumi.RegisterInputType(reflect.TypeOf((*EventOrchestrationGlobalArrayInput)(nil)).Elem(), EventOrchestrationGlobalArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*EventOrchestrationGlobalMapInput)(nil)).Elem(), EventOrchestrationGlobalMap{})
	pulumi.RegisterOutputType(EventOrchestrationGlobalOutput{})
	pulumi.RegisterOutputType(EventOrchestrationGlobalArrayOutput{})
	pulumi.RegisterOutputType(EventOrchestrationGlobalMapOutput{})
}
