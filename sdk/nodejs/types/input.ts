// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AutomationActionsActionActionDataReference {
    /**
     * The command to execute the script with.
     */
    invocationCommand?: pulumi.Input<string>;
    /**
     * The arguments to pass to the Process Automation job execution.
     */
    processAutomationJobArguments?: pulumi.Input<string>;
    /**
     * The ID of the Process Automation job to execute.
     */
    processAutomationJobId?: pulumi.Input<string>;
    /**
     * The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
     */
    processAutomationNodeFilter?: pulumi.Input<string>;
    /**
     * Body of the script to be executed on the Runner. Max length is 16777215 characters.
     */
    script?: pulumi.Input<string>;
}

export interface EscalationPolicyRule {
    /**
     * The number of minutes before an unacknowledged incident escalates away from this rule.
     */
    escalationDelayInMinutes: pulumi.Input<number>;
    /**
     * A target ID
     */
    id?: pulumi.Input<string>;
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPolicyRuleTarget>[]>;
}

export interface EscalationPolicyRuleTarget {
    /**
     * A target ID
     */
    id: pulumi.Input<string>;
    /**
     * Can be `userReference` or `scheduleReference`. Defaults to `userReference`. For multiple users as example, repeat the target.
     */
    type?: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActions>;
}

export interface EventOrchestrationGlobalCatchAllActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: pulumi.Input<string>;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsAutomationAction>;
    /**
     * When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
     */
    dropEvent?: pulumi.Input<boolean>;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsExtraction>[]>;
    priority?: pulumi.Input<string>;
    /**
     * The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: pulumi.Input<boolean>;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: pulumi.Input<number>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsVariable>[]>;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: pulumi.Input<boolean>;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsAutomationActionHeader>[]>;
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsAutomationActionParameter>[]>;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationActionHeader {
    /**
     * Name to identify the header
     */
    key: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationActionParameter {
    /**
     * Name to identify the header
     */
    key: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsVariable {
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: pulumi.Input<string>;
    rules?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRule>[]>;
}

export interface EventOrchestrationGlobalSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActions>;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleCondition>[]>;
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id?: pulumi.Input<string>;
    /**
     * A description of this rule's purpose.
     */
    label?: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: pulumi.Input<string>;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsAutomationAction>;
    /**
     * When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
     */
    dropEvent?: pulumi.Input<boolean>;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsExtraction>[]>;
    priority?: pulumi.Input<string>;
    /**
     * The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: pulumi.Input<boolean>;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: pulumi.Input<number>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsVariable>[]>;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: pulumi.Input<boolean>;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsAutomationActionHeader>[]>;
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsAutomationActionParameter>[]>;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationActionHeader {
    /**
     * Name to identify the header
     */
    key: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationActionParameter {
    /**
     * Name to identify the header
     */
    key: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsVariable {
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface EventOrchestrationIntegration {
    /**
     * ID of the integration
     */
    id?: pulumi.Input<string>;
    label?: pulumi.Input<string>;
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationIntegrationParameter>[]>;
}

export interface EventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey?: pulumi.Input<string>;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type?: pulumi.Input<string>;
}

export interface EventOrchestrationRouterCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident.
     */
    actions: pulumi.Input<inputs.EventOrchestrationRouterCatchAllActions>;
}

export interface EventOrchestrationRouterCatchAllActions {
    /**
     * The ID of the target Service for the resulting alert.
     */
    routeTo: pulumi.Input<string>;
}

export interface EventOrchestrationRouterSet {
    /**
     * ID of the `start` set. Router supports only one set and it's id has to be `start`
     */
    id: pulumi.Input<string>;
    rules?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationRouterSetRule>[]>;
}

export interface EventOrchestrationRouterSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: pulumi.Input<inputs.EventOrchestrationRouterSetRuleActions>;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationRouterSetRuleCondition>[]>;
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * ID of the `start` set. Router supports only one set and it's id has to be `start`
     */
    id?: pulumi.Input<string>;
    /**
     * A description of this rule's purpose.
     */
    label?: pulumi.Input<string>;
}

export interface EventOrchestrationRouterSetRuleActions {
    /**
     * The ID of the target Service for the resulting alert.
     */
    routeTo: pulumi.Input<string>;
}

export interface EventOrchestrationRouterSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: pulumi.Input<inputs.EventOrchestrationServiceCatchAllActions>;
}

export interface EventOrchestrationServiceCatchAllActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: pulumi.Input<string>;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsAutomationAction>;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsExtraction>[]>;
    /**
     * Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
     */
    pagerdutyAutomationAction?: pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction>;
    priority?: pulumi.Input<string>;
    /**
     * The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: pulumi.Input<boolean>;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: pulumi.Input<number>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsVariable>[]>;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: pulumi.Input<boolean>;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsAutomationActionHeader>[]>;
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsAutomationActionParameter>[]>;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationActionHeader {
    /**
     * Name to identify the header
     */
    key: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationActionParameter {
    /**
     * Name to identify the header
     */
    key: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction {
    /**
     * Id of the Process Automation action to be triggered.
     */
    actionId: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsVariable {
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: pulumi.Input<string>;
    rules?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRule>[]>;
}

export interface EventOrchestrationServiceSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: pulumi.Input<inputs.EventOrchestrationServiceSetRuleActions>;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleCondition>[]>;
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id?: pulumi.Input<string>;
    /**
     * A description of this rule's purpose.
     */
    label?: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: pulumi.Input<string>;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsAutomationAction>;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsExtraction>[]>;
    /**
     * Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
     */
    pagerdutyAutomationAction?: pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction>;
    priority?: pulumi.Input<string>;
    /**
     * The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: pulumi.Input<boolean>;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: pulumi.Input<number>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsVariable>[]>;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: pulumi.Input<boolean>;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsAutomationActionHeader>[]>;
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsAutomationActionParameter>[]>;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationActionHeader {
    /**
     * Name to identify the header
     */
    key: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationActionParameter {
    /**
     * Name to identify the header
     */
    key: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction {
    /**
     * Id of the Process Automation action to be triggered.
     */
    actionId: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsVariable {
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * Value of this header
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: pulumi.Input<inputs.EventOrchestrationUnroutedCatchAllActions>;
}

export interface EventOrchestrationUnroutedCatchAllActions {
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedCatchAllActionsExtraction>[]>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    suppress?: pulumi.Input<boolean>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedCatchAllActionsVariable>[]>;
}

export interface EventOrchestrationUnroutedCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: pulumi.Input<string>;
    rules?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedSetRule>[]>;
}

export interface EventOrchestrationUnroutedSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: pulumi.Input<inputs.EventOrchestrationUnroutedSetRuleActions>;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedSetRuleCondition>[]>;
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id?: pulumi.Input<string>;
    /**
     * A description of this rule's purpose.
     */
    label?: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedSetRuleActions {
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedSetRuleActionsExtraction>[]>;
    /**
     * The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedSetRuleActionsVariable>[]>;
}

export interface EventOrchestrationUnroutedSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface GetEventOrchestrationIntegration {
    /**
     * ID of the integration
     */
    id?: string;
    label?: string;
    parameters?: inputs.GetEventOrchestrationIntegrationParameter[];
}

export interface GetEventOrchestrationIntegrationArgs {
    /**
     * ID of the integration
     */
    id?: pulumi.Input<string>;
    label?: pulumi.Input<string>;
    parameters?: pulumi.Input<pulumi.Input<inputs.GetEventOrchestrationIntegrationParameterArgs>[]>;
}

export interface GetEventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey?: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type?: string;
}

export interface GetEventOrchestrationIntegrationParameterArgs {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey?: pulumi.Input<string>;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type?: pulumi.Input<string>;
}

export interface GetLicensesLicense {
    /**
     * Available allocations to assign to users
     */
    allocationsAvailable?: number;
    /**
     * The number of allocations already assigned to users
     */
    currentValue?: number;
    /**
     * Description of the license
     */
    description?: string;
    htmlUrl?: string;
    /**
     * Allows to override the default behavior for setting the `id` attribute that is required for data sources.
     */
    id?: string;
    /**
     * Name of the license
     */
    name?: string;
    /**
     * The role group for the license that determines the available `validRoles`
     */
    roleGroup?: string;
    self?: string;
    /**
     * Summary of the license
     */
    summary?: string;
    type?: string;
    /**
     * List of allowed roles that may be assigned to a user with this license
     */
    validRoles?: string[];
}

export interface GetLicensesLicenseArgs {
    /**
     * Available allocations to assign to users
     */
    allocationsAvailable?: pulumi.Input<number>;
    /**
     * The number of allocations already assigned to users
     */
    currentValue?: pulumi.Input<number>;
    /**
     * Description of the license
     */
    description?: pulumi.Input<string>;
    htmlUrl?: pulumi.Input<string>;
    /**
     * Allows to override the default behavior for setting the `id` attribute that is required for data sources.
     */
    id?: pulumi.Input<string>;
    /**
     * Name of the license
     */
    name?: pulumi.Input<string>;
    /**
     * The role group for the license that determines the available `validRoles`
     */
    roleGroup?: pulumi.Input<string>;
    self?: pulumi.Input<string>;
    /**
     * Summary of the license
     */
    summary?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
    /**
     * List of allowed roles that may be assigned to a user with this license
     */
    validRoles?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface IncidentWorkflowStep {
    /**
     * The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
     */
    action: pulumi.Input<string>;
    /**
     * The ID of the incident workflow.
     */
    id?: pulumi.Input<string>;
    /**
     * The list of inputs for the workflow action.
     */
    inputs?: pulumi.Input<pulumi.Input<inputs.IncidentWorkflowStepInput>[]>;
    /**
     * The name of the workflow step.
     */
    name: pulumi.Input<string>;
}

export interface IncidentWorkflowStepInput {
    generated?: pulumi.Input<boolean>;
    /**
     * The name of the input.
     */
    name: pulumi.Input<string>;
    /**
     * The value of the input.
     */
    value: pulumi.Input<string>;
}

export interface ResponsePlayResponder {
    /**
     * Description of escalation policy
     */
    description?: pulumi.Input<string>;
    /**
     * The escalation rules
     */
    escalationRules?: pulumi.Input<pulumi.Input<inputs.ResponsePlayResponderEscalationRule>[]>;
    /**
     * ID of the user defined as the responder
     */
    id?: pulumi.Input<string>;
    /**
     * Name of the escalation policy
     */
    name?: pulumi.Input<string>;
    /**
     * The number of times the escalation policy will repeat after reaching the end of its escalation.
     */
    numLoops?: pulumi.Input<number>;
    /**
     * Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "ifHasServices". Could be "ifHasServices", "always
     */
    onCallHandoffNotifications?: pulumi.Input<string>;
    /**
     * There can be multiple services associated with a policy.
     */
    services?: pulumi.Input<pulumi.Input<inputs.ResponsePlayResponderService>[]>;
    /**
     * Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
     */
    teams?: pulumi.Input<pulumi.Input<inputs.ResponsePlayResponderTeam>[]>;
    /**
     * Type of object of the target. Supported types are `userReference`, `scheduleReference`.
     */
    type?: pulumi.Input<string>;
}

export interface ResponsePlayResponderEscalationRule {
    /**
     * The number of minutes before an unacknowledged incident escalates away from this rule.
     */
    escalationDelayInMinutes?: pulumi.Input<number>;
    /**
     * ID of the user defined as the responder
     */
    id?: pulumi.Input<string>;
    /**
     * The targets an incident should be assigned to upon reaching this rule.
     */
    targets: pulumi.Input<pulumi.Input<inputs.ResponsePlayResponderEscalationRuleTarget>[]>;
}

export interface ResponsePlayResponderEscalationRuleTarget {
    /**
     * ID of the user defined as the responder
     */
    id?: pulumi.Input<string>;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type?: pulumi.Input<string>;
}

export interface ResponsePlayResponderService {
    /**
     * ID of the user defined as the responder
     */
    id?: pulumi.Input<string>;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type?: pulumi.Input<string>;
}

export interface ResponsePlayResponderTeam {
    /**
     * ID of the user defined as the responder
     */
    id?: pulumi.Input<string>;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type: pulumi.Input<string>;
}

export interface ResponsePlaySubscriber {
    /**
     * ID of the user defined as the responder
     */
    id?: pulumi.Input<string>;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type?: pulumi.Input<string>;
}

export interface RulesetRuleActions {
    /**
     * Note added to the event.
     */
    annotates?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsAnnotate>[]>;
    /**
     * An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
     */
    eventActions?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsEventAction>[]>;
    /**
     * Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsExtraction>[]>;
    /**
     * The ID of the priority applied to the event.
     */
    priorities?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsPriority>[]>;
    /**
     * The ID of the service where the event will be routed.
     */
    routes?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsRoute>[]>;
    /**
     * The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
     */
    severities?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsSeverity>[]>;
    /**
     * Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
     */
    suppresses?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsSuppress>[]>;
    /**
     * An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
     */
    suspends?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsSuspend>[]>;
}

export interface RulesetRuleActionsAnnotate {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsEventAction {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsExtraction {
    /**
     * The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
     */
    regex?: pulumi.Input<string>;
    /**
     * Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    source?: pulumi.Input<string>;
    /**
     * Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    target?: pulumi.Input<string>;
    /**
     * A customized field message. This can also include variables extracted from the payload by using string interpolation.
     */
    template?: pulumi.Input<string>;
}

export interface RulesetRuleActionsPriority {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsRoute {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsSeverity {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsSuppress {
    /**
     * The number value of the `thresholdTimeUnit` before an incident is created. Must be greater than 0.
     */
    thresholdTimeAmount?: pulumi.Input<number>;
    /**
     * The `seconds`,`minutes`, or `hours` the `thresholdTimeAmount` should be measured.
     */
    thresholdTimeUnit?: pulumi.Input<string>;
    /**
     * The number of alerts that should be suppressed. Must be greater than 0.
     */
    thresholdValue?: pulumi.Input<number>;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<boolean>;
}

export interface RulesetRuleActionsSuspend {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<number>;
}

export interface RulesetRuleConditions {
    /**
     * Operator to combine sub-conditions. Can be `and` or `or`.
     */
    operator?: pulumi.Input<string>;
    /**
     * List of sub-conditions that define the condition.
     */
    subconditions?: pulumi.Input<pulumi.Input<inputs.RulesetRuleConditionsSubcondition>[]>;
}

export interface RulesetRuleConditionsSubcondition {
    /**
     * Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
     */
    operator?: pulumi.Input<string>;
    /**
     * Parameter for the sub-condition. It requires both a `path` and `value` to be set.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.RulesetRuleConditionsSubconditionParameter>[]>;
}

export interface RulesetRuleConditionsSubconditionParameter {
    path?: pulumi.Input<string>;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetRuleTimeFrame {
    /**
     * Values for executing the rule during a specific time period.
     */
    activeBetweens?: pulumi.Input<pulumi.Input<inputs.RulesetRuleTimeFrameActiveBetween>[]>;
    /**
     * Values for executing the rule on a recurring schedule.
     */
    scheduledWeeklies?: pulumi.Input<pulumi.Input<inputs.RulesetRuleTimeFrameScheduledWeekly>[]>;
}

export interface RulesetRuleTimeFrameActiveBetween {
    endTime?: pulumi.Input<number>;
    startTime?: pulumi.Input<number>;
}

export interface RulesetRuleTimeFrameScheduledWeekly {
    /**
     * Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `startTime`.
     */
    duration?: pulumi.Input<number>;
    startTime?: pulumi.Input<number>;
    /**
     * [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
     */
    timezone?: pulumi.Input<string>;
    /**
     * An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
     */
    weekdays?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface RulesetRuleVariable {
    name?: pulumi.Input<string>;
    parameters?: pulumi.Input<pulumi.Input<inputs.RulesetRuleVariableParameter>[]>;
    type?: pulumi.Input<string>;
}

export interface RulesetRuleVariableParameter {
    path?: pulumi.Input<string>;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface RulesetTeam {
    /**
     * The ID of the ruleset.
     */
    id: pulumi.Input<string>;
}

export interface ScheduleFinalSchedule {
    /**
     * The name of the schedule.
     */
    name?: pulumi.Input<string>;
    renderedCoveragePercentage?: pulumi.Input<string>;
}

export interface ScheduleLayer {
    /**
     * The end time of the schedule layer. If not specified, the layer does not end.
     */
    end?: pulumi.Input<string>;
    /**
     * The ID of the schedule.
     */
    id?: pulumi.Input<string>;
    /**
     * The name of the schedule layer.
     */
    name?: pulumi.Input<string>;
    renderedCoveragePercentage?: pulumi.Input<string>;
    /**
     * A schedule layer restriction block. Restriction blocks documented below.
     */
    restrictions?: pulumi.Input<pulumi.Input<inputs.ScheduleLayerRestriction>[]>;
    /**
     * The duration of each on-call shift in `seconds`.
     */
    rotationTurnLengthSeconds: pulumi.Input<number>;
    /**
     * The effective start time of the schedule layer. This can be before the start time of the schedule.
     */
    rotationVirtualStart: pulumi.Input<string>;
    /**
     * The start time of the schedule layer.
     */
    start: pulumi.Input<string>;
    /**
     * The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
     */
    users: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ScheduleLayerRestriction {
    /**
     * The duration of the restriction in `seconds`.
     */
    durationSeconds: pulumi.Input<number>;
    /**
     * Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
     */
    startDayOfWeek?: pulumi.Input<number>;
    /**
     * The start time in `HH:mm:ss` format.
     */
    startTimeOfDay: pulumi.Input<string>;
    /**
     * Can be `dailyRestriction` or `weeklyRestriction`.
     */
    type: pulumi.Input<string>;
}

export interface ServiceAlertGroupingParameters {
    /**
     * Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
     */
    config?: pulumi.Input<inputs.ServiceAlertGroupingParametersConfig>;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceAlertGroupingParametersConfig {
    /**
     * One of `any` or `all`. This setting applies only when `type` is set to `contentBased`. Group alerts based on one or all of `fields` value(s).
     */
    aggregate?: pulumi.Input<string>;
    /**
     * Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `contentBased`.
     */
    fields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
     */
    timeout?: pulumi.Input<number>;
}

export interface ServiceAutoPauseNotificationsParameters {
    /**
     * Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
     */
    timeout?: pulumi.Input<number>;
}

export interface ServiceDependencyDependency {
    /**
     * The service that dependents on the supporting service. Dependency dependent service documented below.
     */
    dependentServices: pulumi.Input<pulumi.Input<inputs.ServiceDependencyDependencyDependentService>[]>;
    /**
     * The service that supports the dependent service. Dependency supporting service documented below.
     */
    supportingServices: pulumi.Input<pulumi.Input<inputs.ServiceDependencyDependencySupportingService>[]>;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceDependencyDependencyDependentService {
    /**
     * The ID of the service dependency.
     */
    id: pulumi.Input<string>;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: pulumi.Input<string>;
}

export interface ServiceDependencyDependencySupportingService {
    /**
     * The ID of the service dependency.
     */
    id: pulumi.Input<string>;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: pulumi.Input<string>;
}

export interface ServiceEventRuleActions {
    /**
     * Note added to the event.
     */
    annotates?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsAnnotate>[]>;
    /**
     * An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
     */
    eventActions?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsEventAction>[]>;
    /**
     * Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsExtraction>[]>;
    /**
     * The ID of the priority applied to the event.
     */
    priorities?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsPriority>[]>;
    /**
     * The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
     */
    severities?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsSeverity>[]>;
    /**
     * Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
     */
    suppresses?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsSuppress>[]>;
    /**
     * An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
     */
    suspends?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsSuspend>[]>;
}

export interface ServiceEventRuleActionsAnnotate {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsEventAction {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsExtraction {
    /**
     * The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
     */
    regex?: pulumi.Input<string>;
    /**
     * Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    source?: pulumi.Input<string>;
    /**
     * Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    target?: pulumi.Input<string>;
    /**
     * A customized field message. This can also include variables extracted from the payload by using string interpolation.
     */
    template?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsPriority {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsSeverity {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsSuppress {
    /**
     * The number value of the `thresholdTimeUnit` before an incident is created.
     */
    thresholdTimeAmount?: pulumi.Input<number>;
    /**
     * The `seconds`,`minutes`, or `hours` the `thresholdTimeAmount` should be measured.
     */
    thresholdTimeUnit?: pulumi.Input<string>;
    /**
     * The number of alerts that should be suppressed.
     */
    thresholdValue?: pulumi.Input<number>;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<boolean>;
}

export interface ServiceEventRuleActionsSuspend {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<number>;
}

export interface ServiceEventRuleConditions {
    /**
     * Operator to combine sub-conditions. Can be `and` or `or`.
     */
    operator?: pulumi.Input<string>;
    /**
     * List of sub-conditions that define the condition.
     */
    subconditions?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleConditionsSubcondition>[]>;
}

export interface ServiceEventRuleConditionsSubcondition {
    /**
     * Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
     */
    operator?: pulumi.Input<string>;
    /**
     * Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleConditionsSubconditionParameter>[]>;
}

export interface ServiceEventRuleConditionsSubconditionParameter {
    /**
     * Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
     */
    path?: pulumi.Input<string>;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleTimeFrame {
    /**
     * Values for executing the rule during a specific time period.
     */
    activeBetweens?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleTimeFrameActiveBetween>[]>;
    /**
     * Values for executing the rule on a recurring schedule.
     */
    scheduledWeeklies?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleTimeFrameScheduledWeekly>[]>;
}

export interface ServiceEventRuleTimeFrameActiveBetween {
    /**
     * Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
     */
    endTime?: pulumi.Input<number>;
    /**
     * Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `startTime` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `startTime` was `3,600,000` the it would be active starting at `01:00`.
     */
    startTime?: pulumi.Input<number>;
}

export interface ServiceEventRuleTimeFrameScheduledWeekly {
    /**
     * Length of time the schedule will be active.  Unix timestamp in milliseconds.
     */
    duration?: pulumi.Input<number>;
    /**
     * Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `startTime` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `startTime` was `3,600,000` the it would be active starting at `01:00`.
     */
    startTime?: pulumi.Input<number>;
    /**
     * Timezone for the given schedule.
     */
    timezone?: pulumi.Input<string>;
    /**
     * An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
     */
    weekdays?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface ServiceEventRuleVariable {
    /**
     * The name of the variable.
     */
    name?: pulumi.Input<string>;
    /**
     * The parameters for performing the operation to populate the variable.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleVariableParameter>[]>;
    /**
     * Type of operation to populate the variable. Usually `regex`.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceEventRuleVariableParameter {
    /**
     * Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
     */
    path?: pulumi.Input<string>;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<string>;
}

export interface ServiceIncidentUrgencyRule {
    /**
     * Incidents' urgency during support hours.
     */
    duringSupportHours?: pulumi.Input<inputs.ServiceIncidentUrgencyRuleDuringSupportHours>;
    /**
     * Incidents' urgency outside support hours.
     */
    outsideSupportHours?: pulumi.Input<inputs.ServiceIncidentUrgencyRuleOutsideSupportHours>;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type: pulumi.Input<string>;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: pulumi.Input<string>;
}

export interface ServiceIncidentUrgencyRuleDuringSupportHours {
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: pulumi.Input<string>;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: pulumi.Input<string>;
}

export interface ServiceIncidentUrgencyRuleOutsideSupportHours {
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: pulumi.Input<string>;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailFilter {
    /**
     * Can be `always` or `match`.
     */
    bodyMode?: pulumi.Input<string>;
    /**
     * Should be a valid regex or `null`
     */
    bodyRegex?: pulumi.Input<string>;
    /**
     * Can be `always` or `match`.
     */
    fromEmailMode?: pulumi.Input<string>;
    /**
     * Should be a valid regex or `null`
     */
    fromEmailRegex?: pulumi.Input<string>;
    /**
     * The ID of the service integration.
     */
    id?: pulumi.Input<string>;
    /**
     * Can be `always` or `match`.
     */
    subjectMode?: pulumi.Input<string>;
    /**
     * Should be a valid regex or `null`
     */
    subjectRegex?: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailParser {
    /**
     * Can be `resolve` or `trigger`.
     */
    action: pulumi.Input<string>;
    /**
     * The ID of the service integration.
     */
    id?: pulumi.Input<number>;
    matchPredicate: pulumi.Input<inputs.ServiceIntegrationEmailParserMatchPredicate>;
    valueExtractors?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEmailParserValueExtractor>[]>;
}

export interface ServiceIntegrationEmailParserMatchPredicate {
    predicates?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEmailParserMatchPredicatePredicate>[]>;
    /**
     * Can be `any` or `all`.
     */
    type: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailParserMatchPredicatePredicate {
    /**
     * Predicate value or valid regex.
     */
    matcher?: pulumi.Input<string>;
    /**
     * Can be `subject`, `body` or `fromAddresses`.
     */
    part?: pulumi.Input<string>;
    predicates?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEmailParserMatchPredicatePredicatePredicate>[]>;
    /**
     * Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
     */
    type: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailParserMatchPredicatePredicatePredicate {
    /**
     * Predicate value or valid regex.
     */
    matcher: pulumi.Input<string>;
    /**
     * Can be `subject`, `body` or `fromAddresses`.
     */
    part: pulumi.Input<string>;
    /**
     * Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
     */
    type: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailParserValueExtractor {
    endsBefore?: pulumi.Input<string>;
    /**
     * Can be `subject` or `body`.
     */
    part: pulumi.Input<string>;
    /**
     * If `type` has value `regex` this value should contain valid regex.
     */
    regex?: pulumi.Input<string>;
    startsAfter?: pulumi.Input<string>;
    /**
     * Can be `between`, `entire` or `regex`.
     */
    type: pulumi.Input<string>;
    /**
     * First value extractor should have name `incidentKey` other value extractors should contain custom names.
     */
    valueName: pulumi.Input<string>;
}

export interface ServiceScheduledAction {
    /**
     * A block representing when the scheduled action will occur.
     */
    ats?: pulumi.Input<pulumi.Input<inputs.ServiceScheduledActionAt>[]>;
    /**
     * The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
     */
    toUrgency?: pulumi.Input<string>;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceScheduledActionAt {
    /**
     * Designates either the start or the end of the scheduled action. Can be `supportHoursStart` or `supportHoursEnd`.
     */
    name?: pulumi.Input<string>;
    /**
     * The type of time specification. Currently, this must be set to `namedTime`.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceSupportHours {
    /**
     * Array of days of week as integers. `1` to `7`, `1` being
     * Monday and `7` being Sunday.
     */
    daysOfWeeks?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * The support hours' ending time of day.
     */
    endTime?: pulumi.Input<string>;
    /**
     * The support hours' starting time of day.
     */
    startTime?: pulumi.Input<string>;
    /**
     * The time zone for the support hours.
     */
    timeZone?: pulumi.Input<string>;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: pulumi.Input<string>;
}

export interface SlackConnectionConfig {
    /**
     * A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
     * - `incident.acknowledged`
     * - `incident.escalated`
     * - `incident.resolved`
     * - `incident.reassigned`
     * - `incident.annotated`
     * - `incident.unacknowledged`
     * - `incident.delegated`
     * - `incident.priority_updated`
     * - `incident.responder.added`
     * - `incident.responder.replied`
     * - `incident.status_update_published`
     * - `incident.reopened`
     */
    events: pulumi.Input<pulumi.Input<string>[]>;
    priorities?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Allows you to filter events by urgency. Either `high` or `low`.
     */
    urgency?: pulumi.Input<string>;
}

export interface WebhookSubscriptionDeliveryMethod {
    /**
     * The customHeader of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
     */
    customHeaders?: pulumi.Input<pulumi.Input<inputs.WebhookSubscriptionDeliveryMethodCustomHeader>[]>;
    /**
     * Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
     */
    temporarilyDisabled?: pulumi.Input<boolean>;
    /**
     * Indicates the type of the delivery method. Allowed and default value: `httpDeliveryMethod`.
     */
    type?: pulumi.Input<string>;
    /**
     * The destination URL for webhook delivery.
     */
    url?: pulumi.Input<string>;
}

export interface WebhookSubscriptionDeliveryMethodCustomHeader {
    name: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface WebhookSubscriptionFilter {
    /**
     * The id of the object being used as the filter. This field is required for all filter types except account_reference.
     */
    id?: pulumi.Input<string>;
    /**
     * The type of object being used as the filter. Allowed values are `accountReference`, `serviceReference`, and `teamReference`.
     */
    type: pulumi.Input<string>;
}
