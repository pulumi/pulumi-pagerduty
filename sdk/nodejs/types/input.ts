// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AutomationActionsActionActionDataReference {
    invocationCommand?: pulumi.Input<string>;
    processAutomationJobArguments?: pulumi.Input<string>;
    processAutomationJobId?: pulumi.Input<string>;
    processAutomationNodeFilter?: pulumi.Input<string>;
    script?: pulumi.Input<string>;
}

export interface EscalationPolicyRule {
    escalationDelayInMinutes: pulumi.Input<number>;
    escalationRuleAssignmentStrategy?: pulumi.Input<inputs.EscalationPolicyRuleEscalationRuleAssignmentStrategy>;
    /**
     * The ID of the escalation policy.
     */
    id?: pulumi.Input<string>;
    targets: pulumi.Input<pulumi.Input<inputs.EscalationPolicyRuleTarget>[]>;
}

export interface EscalationPolicyRuleEscalationRuleAssignmentStrategy {
    /**
     * Can be `roundRobin` or `assignToEveryone`.
     */
    type?: pulumi.Input<string>;
}

export interface EscalationPolicyRuleTarget {
    /**
     * The ID of the escalation policy.
     */
    id: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCacheVariableConfiguration {
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source?: pulumi.Input<string>;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount`
     */
    ttlSeconds?: pulumi.Input<number>;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue` or `triggerEventCount`.
     */
    type: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActions>;
}

export interface EventOrchestrationGlobalCatchAllActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: pulumi.Input<string>;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsAutomationAction>;
    /**
     * When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
     */
    dropEvent?: pulumi.Input<boolean>;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsExtraction>[]>;
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate>[]>;
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: pulumi.Input<string>;
    /**
     * The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: pulumi.Input<boolean>;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: pulumi.Input<number>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsVariable>[]>;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: pulumi.Input<boolean>;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsAutomationActionHeader>[]>;
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalCatchAllActionsAutomationActionParameter>[]>;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationActionHeader {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationActionParameter {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: pulumi.Input<string>;
    /**
     * The value to assign to this custom field
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: pulumi.Input<string>;
    rules?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRule>[]>;
}

export interface EventOrchestrationGlobalSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActions>;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleCondition>[]>;
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The ID of the rule within the set.
     */
    id?: pulumi.Input<string>;
    /**
     * A description of this rule's purpose.
     */
    label?: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: pulumi.Input<string>;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsAutomationAction>;
    /**
     * When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
     */
    dropEvent?: pulumi.Input<boolean>;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsExtraction>[]>;
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate>[]>;
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: pulumi.Input<string>;
    /**
     * The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: pulumi.Input<boolean>;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: pulumi.Input<number>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsVariable>[]>;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: pulumi.Input<boolean>;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsAutomationActionHeader>[]>;
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationGlobalSetRuleActionsAutomationActionParameter>[]>;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationActionHeader {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationActionParameter {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: pulumi.Input<string>;
    /**
     * The value to assign to this custom field
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationGlobalSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface EventOrchestrationIntegration {
    /**
     * ID of the integration
     */
    id?: pulumi.Input<string>;
    label?: pulumi.Input<string>;
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationIntegrationParameter>[]>;
}

export interface EventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey?: pulumi.Input<string>;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type?: pulumi.Input<string>;
}

export interface EventOrchestrationRouterCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident.
     */
    actions: pulumi.Input<inputs.EventOrchestrationRouterCatchAllActions>;
}

export interface EventOrchestrationRouterCatchAllActions {
    /**
     * Defines where an alert will be sent if doesn't match any rules. Can either be the ID of a Service _or_ the string `"unrouted"` to send events to the Unrouted Orchestration.
     */
    routeTo: pulumi.Input<string>;
}

export interface EventOrchestrationRouterSet {
    /**
     * ID of the `start` set. Router supports only one set and it's id has to be `start`
     */
    id: pulumi.Input<string>;
    rules?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationRouterSetRule>[]>;
}

export interface EventOrchestrationRouterSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: pulumi.Input<inputs.EventOrchestrationRouterSetRuleActions>;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationRouterSetRuleCondition>[]>;
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The ID of the rule within the `start` set.
     */
    id?: pulumi.Input<string>;
    /**
     * A description of this rule's purpose.
     */
    label?: pulumi.Input<string>;
}

export interface EventOrchestrationRouterSetRuleActions {
    /**
     * The ID of the target Service for the resulting alert.
     */
    routeTo: pulumi.Input<string>;
}

export interface EventOrchestrationRouterSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCacheVariableConfiguration {
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source?: pulumi.Input<string>;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount`
     */
    ttlSeconds?: pulumi.Input<number>;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue` or `triggerEventCount`.
     */
    type: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: pulumi.Input<inputs.EventOrchestrationServiceCatchAllActions>;
}

export interface EventOrchestrationServiceCatchAllActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: pulumi.Input<string>;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsAutomationAction>;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsExtraction>[]>;
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate>[]>;
    /**
     * Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
     */
    pagerdutyAutomationAction?: pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction>;
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: pulumi.Input<string>;
    /**
     * The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: pulumi.Input<boolean>;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: pulumi.Input<number>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsVariable>[]>;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: pulumi.Input<boolean>;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsAutomationActionHeader>[]>;
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceCatchAllActionsAutomationActionParameter>[]>;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationActionHeader {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationActionParameter {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: pulumi.Input<string>;
    /**
     * The value to assign to this custom field
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction {
    /**
     * Id of the Process Automation action to be triggered.
     */
    actionId: pulumi.Input<string>;
}

export interface EventOrchestrationServiceCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: pulumi.Input<string>;
    rules?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRule>[]>;
}

export interface EventOrchestrationServiceSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: pulumi.Input<inputs.EventOrchestrationServiceSetRuleActions>;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleCondition>[]>;
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The ID of the rule within the set.
     */
    id?: pulumi.Input<string>;
    /**
     * A description of this rule's purpose.
     */
    label?: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: pulumi.Input<string>;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsAutomationAction>;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsExtraction>[]>;
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate>[]>;
    /**
     * Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
     */
    pagerdutyAutomationAction?: pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction>;
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: pulumi.Input<string>;
    /**
     * The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: pulumi.Input<boolean>;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: pulumi.Input<number>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsVariable>[]>;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: pulumi.Input<boolean>;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsAutomationActionHeader>[]>;
    /**
     * Name of this Webhook.
     */
    name: pulumi.Input<string>;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationServiceSetRuleActionsAutomationActionParameter>[]>;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationActionHeader {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationActionParameter {
    key: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: pulumi.Input<string>;
    /**
     * The value to assign to this custom field
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction {
    /**
     * Id of the Process Automation action to be triggered.
     */
    actionId: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationServiceSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: pulumi.Input<inputs.EventOrchestrationUnroutedCatchAllActions>;
}

export interface EventOrchestrationUnroutedCatchAllActions {
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedCatchAllActionsExtraction>[]>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    suppress?: pulumi.Input<boolean>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedCatchAllActionsVariable>[]>;
}

export interface EventOrchestrationUnroutedCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: pulumi.Input<string>;
    rules?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedSetRule>[]>;
}

export interface EventOrchestrationUnroutedSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: pulumi.Input<inputs.EventOrchestrationUnroutedSetRuleActions>;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedSetRuleCondition>[]>;
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: pulumi.Input<boolean>;
    /**
     * The ID of the rule within the set.
     */
    id?: pulumi.Input<string>;
    /**
     * A description of this rule's purpose.
     */
    label?: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedSetRuleActions {
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: pulumi.Input<string>;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedSetRuleActionsExtraction>[]>;
    /**
     * The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: pulumi.Input<string>;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: pulumi.Input<string>;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: pulumi.Input<pulumi.Input<inputs.EventOrchestrationUnroutedSetRuleActionsVariable>[]>;
}

export interface EventOrchestrationUnroutedSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: pulumi.Input<string>;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: pulumi.Input<string>;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: pulumi.Input<string>;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: pulumi.Input<string>;
    /**
     * Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
     */
    path: pulumi.Input<string>;
    /**
     * Only `regex` is supported
     */
    type: pulumi.Input<string>;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: pulumi.Input<string>;
}

export interface EventOrchestrationUnroutedSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: pulumi.Input<string>;
}

export interface GetEventOrchestrationIntegrationDetail {
    /**
     * ID of the integration
     */
    id?: string;
    label?: string;
    parameters?: inputs.GetEventOrchestrationIntegrationDetailParameter[];
}

export interface GetEventOrchestrationIntegrationDetailArgs {
    /**
     * ID of the integration
     */
    id?: pulumi.Input<string>;
    label?: pulumi.Input<string>;
    parameters?: pulumi.Input<pulumi.Input<inputs.GetEventOrchestrationIntegrationDetailParameterArgs>[]>;
}

export interface GetEventOrchestrationIntegrationDetailParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey?: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type?: string;
}

export interface GetEventOrchestrationIntegrationDetailParameterArgs {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey?: pulumi.Input<string>;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type?: pulumi.Input<string>;
}

export interface GetLicensesLicense {
    /**
     * Available allocations to assign to users
     */
    allocationsAvailable?: number;
    /**
     * The number of allocations already assigned to users
     */
    currentValue?: number;
    /**
     * Description of the license
     */
    description?: string;
    htmlUrl?: string;
    /**
     * Allows to override the default behavior for setting the `id` attribute that is required for data sources.
     */
    id?: string;
    /**
     * Name of the license
     */
    name?: string;
    /**
     * The role group for the license that determines the available `validRoles`
     */
    roleGroup?: string;
    self?: string;
    /**
     * Summary of the license
     */
    summary?: string;
    type?: string;
    /**
     * List of allowed roles that may be assigned to a user with this license
     */
    validRoles?: string[];
}

export interface GetLicensesLicenseArgs {
    /**
     * Available allocations to assign to users
     */
    allocationsAvailable?: pulumi.Input<number>;
    /**
     * The number of allocations already assigned to users
     */
    currentValue?: pulumi.Input<number>;
    /**
     * Description of the license
     */
    description?: pulumi.Input<string>;
    htmlUrl?: pulumi.Input<string>;
    /**
     * Allows to override the default behavior for setting the `id` attribute that is required for data sources.
     */
    id?: pulumi.Input<string>;
    /**
     * Name of the license
     */
    name?: pulumi.Input<string>;
    /**
     * The role group for the license that determines the available `validRoles`
     */
    roleGroup?: pulumi.Input<string>;
    self?: pulumi.Input<string>;
    /**
     * Summary of the license
     */
    summary?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
    /**
     * List of allowed roles that may be assigned to a user with this license
     */
    validRoles?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface IncidentWorkflowStep {
    /**
     * The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
     */
    action: pulumi.Input<string>;
    /**
     * The ID of the incident workflow.
     */
    id?: pulumi.Input<string>;
    /**
     * The list of inputs that contain a series of inline steps for the workflow action.
     */
    inlineStepsInputs?: pulumi.Input<pulumi.Input<inputs.IncidentWorkflowStepInlineStepsInput>[]>;
    /**
     * The list of standard inputs for the workflow action.
     */
    inputs?: pulumi.Input<pulumi.Input<inputs.IncidentWorkflowStepInput>[]>;
    /**
     * The name of the workflow step.
     */
    name: pulumi.Input<string>;
}

export interface IncidentWorkflowStepInlineStepsInput {
    /**
     * The name of the input.
     */
    name: pulumi.Input<string>;
    /**
     * The inline steps of the input. An inline step adheres to the step schema described above.
     */
    steps?: pulumi.Input<pulumi.Input<inputs.IncidentWorkflowStepInlineStepsInputStep>[]>;
}

export interface IncidentWorkflowStepInlineStepsInputStep {
    /**
     * The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
     */
    action: pulumi.Input<string>;
    /**
     * The list of standard inputs for the workflow action.
     */
    inputs?: pulumi.Input<pulumi.Input<inputs.IncidentWorkflowStepInlineStepsInputStepInput>[]>;
    /**
     * The name of the workflow step.
     */
    name: pulumi.Input<string>;
}

export interface IncidentWorkflowStepInlineStepsInputStepInput {
    generated?: pulumi.Input<boolean>;
    /**
     * The name of the input.
     */
    name: pulumi.Input<string>;
    /**
     * The value of the input.
     */
    value: pulumi.Input<string>;
}

export interface IncidentWorkflowStepInput {
    generated?: pulumi.Input<boolean>;
    /**
     * The name of the input.
     */
    name: pulumi.Input<string>;
    /**
     * The value of the input.
     */
    value: pulumi.Input<string>;
}

export interface IncidentWorkflowTriggerPermissions {
    /**
     * If `true`, indicates that the Trigger can only be started by authorized Users. If `false` (default), any user can start this Trigger. Applicable only to `manual`-type triggers.
     */
    restricted?: pulumi.Input<boolean>;
    /**
     * The ID of the Team whose members can manually start this Trigger. Required and allowed only if `restricted` is `true`.
     */
    teamId?: pulumi.Input<string>;
}

export interface ProviderUseAppOauthScopedToken {
    pdClientId?: pulumi.Input<string>;
    pdClientSecret?: pulumi.Input<string>;
    pdSubdomain?: pulumi.Input<string>;
}

export interface ResponsePlayResponder {
    /**
     * Description of escalation policy
     */
    description?: pulumi.Input<string>;
    /**
     * The escalation rules
     */
    escalationRules?: pulumi.Input<pulumi.Input<inputs.ResponsePlayResponderEscalationRule>[]>;
    /**
     * ID of the user defined as the responder
     */
    id?: pulumi.Input<string>;
    /**
     * Name of the escalation policy
     */
    name?: pulumi.Input<string>;
    /**
     * The number of times the escalation policy will repeat after reaching the end of its escalation.
     */
    numLoops?: pulumi.Input<number>;
    /**
     * Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "ifHasServices". Could be "ifHasServices", "always
     */
    onCallHandoffNotifications?: pulumi.Input<string>;
    /**
     * There can be multiple services associated with a policy.
     */
    services?: pulumi.Input<pulumi.Input<inputs.ResponsePlayResponderService>[]>;
    /**
     * Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
     */
    teams?: pulumi.Input<pulumi.Input<inputs.ResponsePlayResponderTeam>[]>;
    /**
     * Should be set as `escalationPolicy` for escalation policy responders.
     */
    type?: pulumi.Input<string>;
}

export interface ResponsePlayResponderEscalationRule {
    /**
     * The number of minutes before an unacknowledged incident escalates away from this rule.
     */
    escalationDelayInMinutes?: pulumi.Input<number>;
    /**
     * The ID of the response play.
     */
    id?: pulumi.Input<string>;
    /**
     * The targets an incident should be assigned to upon reaching this rule.
     */
    targets: pulumi.Input<pulumi.Input<inputs.ResponsePlayResponderEscalationRuleTarget>[]>;
}

export interface ResponsePlayResponderEscalationRuleTarget {
    /**
     * The ID of the response play.
     */
    id?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface ResponsePlayResponderService {
    /**
     * The ID of the response play.
     */
    id?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface ResponsePlayResponderTeam {
    /**
     * The ID of the response play.
     */
    id?: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface ResponsePlaySubscriber {
    /**
     * The ID of the response play.
     */
    id?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
}

export interface RulesetRuleActions {
    /**
     * Note added to the event.
     */
    annotates?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsAnnotate>[]>;
    /**
     * An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
     */
    eventActions?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsEventAction>[]>;
    /**
     * Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsExtraction>[]>;
    /**
     * The ID of the priority applied to the event.
     */
    priorities?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsPriority>[]>;
    /**
     * The ID of the service where the event will be routed.
     */
    routes?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsRoute>[]>;
    /**
     * The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
     */
    severities?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsSeverity>[]>;
    /**
     * Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
     */
    suppresses?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsSuppress>[]>;
    /**
     * An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
     */
    suspends?: pulumi.Input<pulumi.Input<inputs.RulesetRuleActionsSuspend>[]>;
}

export interface RulesetRuleActionsAnnotate {
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsEventAction {
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsExtraction {
    /**
     * The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
     *
     * *- **OR** -*
     */
    regex?: pulumi.Input<string>;
    /**
     * Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    source?: pulumi.Input<string>;
    /**
     * Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     *
     * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
     */
    target?: pulumi.Input<string>;
    /**
     * A customized field message. This can also include variables extracted from the payload by using string interpolation.
     */
    template?: pulumi.Input<string>;
}

export interface RulesetRuleActionsPriority {
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsRoute {
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsSeverity {
    value?: pulumi.Input<string>;
}

export interface RulesetRuleActionsSuppress {
    /**
     * The number value of the `thresholdTimeUnit` before an incident is created. Must be greater than 0.
     */
    thresholdTimeAmount?: pulumi.Input<number>;
    /**
     * The `seconds`,`minutes`, or `hours` the `thresholdTimeAmount` should be measured.
     */
    thresholdTimeUnit?: pulumi.Input<string>;
    /**
     * The number of alerts that should be suppressed. Must be greater than 0.
     */
    thresholdValue?: pulumi.Input<number>;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: pulumi.Input<boolean>;
}

export interface RulesetRuleActionsSuspend {
    value?: pulumi.Input<number>;
}

export interface RulesetRuleConditions {
    /**
     * Operator to combine sub-conditions. Can be `and` or `or`.
     */
    operator?: pulumi.Input<string>;
    /**
     * List of sub-conditions that define the condition.
     */
    subconditions?: pulumi.Input<pulumi.Input<inputs.RulesetRuleConditionsSubcondition>[]>;
}

export interface RulesetRuleConditionsSubcondition {
    /**
     * Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
     */
    operator?: pulumi.Input<string>;
    /**
     * Parameter for the sub-condition. It requires both a `path` and `value` to be set.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.RulesetRuleConditionsSubconditionParameter>[]>;
}

export interface RulesetRuleConditionsSubconditionParameter {
    path?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface RulesetRuleTimeFrame {
    /**
     * Values for executing the rule during a specific time period.
     */
    activeBetweens?: pulumi.Input<pulumi.Input<inputs.RulesetRuleTimeFrameActiveBetween>[]>;
    /**
     * Values for executing the rule on a recurring schedule.
     */
    scheduledWeeklies?: pulumi.Input<pulumi.Input<inputs.RulesetRuleTimeFrameScheduledWeekly>[]>;
}

export interface RulesetRuleTimeFrameActiveBetween {
    endTime?: pulumi.Input<number>;
    startTime?: pulumi.Input<number>;
}

export interface RulesetRuleTimeFrameScheduledWeekly {
    /**
     * Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `startTime`.
     */
    duration?: pulumi.Input<number>;
    /**
     * A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `timeStatic` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
     */
    startTime?: pulumi.Input<number>;
    /**
     * [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
     */
    timezone?: pulumi.Input<string>;
    /**
     * An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
     */
    weekdays?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface RulesetRuleVariable {
    name?: pulumi.Input<string>;
    parameters?: pulumi.Input<pulumi.Input<inputs.RulesetRuleVariableParameter>[]>;
    type?: pulumi.Input<string>;
}

export interface RulesetRuleVariableParameter {
    path?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface RulesetTeam {
    /**
     * The ID of the ruleset.
     */
    id: pulumi.Input<string>;
}

export interface ScheduleFinalSchedule {
    /**
     * The name of the schedule.
     */
    name?: pulumi.Input<string>;
    renderedCoveragePercentage?: pulumi.Input<string>;
}

export interface ScheduleLayer {
    /**
     * The end time of the schedule layer. If not specified, the layer does not end.
     */
    end?: pulumi.Input<string>;
    /**
     * The ID of the schedule.
     */
    id?: pulumi.Input<string>;
    /**
     * The name of the schedule layer.
     */
    name?: pulumi.Input<string>;
    renderedCoveragePercentage?: pulumi.Input<string>;
    /**
     * A schedule layer restriction block. Restriction blocks documented below.
     */
    restrictions?: pulumi.Input<pulumi.Input<inputs.ScheduleLayerRestriction>[]>;
    /**
     * The duration of each on-call shift in `seconds`.
     */
    rotationTurnLengthSeconds: pulumi.Input<number>;
    /**
     * The effective start time of the schedule layer. This can be before the start time of the schedule.
     */
    rotationVirtualStart: pulumi.Input<string>;
    /**
     * The start time of the schedule layer.
     */
    start: pulumi.Input<string>;
    /**
     * The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
     */
    users: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ScheduleLayerRestriction {
    /**
     * The duration of the restriction in `seconds`.
     */
    durationSeconds: pulumi.Input<number>;
    /**
     * Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
     */
    startDayOfWeek?: pulumi.Input<number>;
    /**
     * The start time in `HH:mm:ss` format.
     */
    startTimeOfDay: pulumi.Input<string>;
    /**
     * Can be `dailyRestriction` or `weeklyRestriction`.
     */
    type: pulumi.Input<string>;
}

export interface ServiceAlertGroupingParameters {
    /**
     * Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
     */
    config?: pulumi.Input<inputs.ServiceAlertGroupingParametersConfig>;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceAlertGroupingParametersConfig {
    /**
     * One of `any` or `all`. This setting applies only when `type` is set to `contentBased`. Group alerts based on one or all of `fields` value(s).
     */
    aggregate?: pulumi.Input<string>;
    /**
     * Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `contentBased`.
     */
    fields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent` or `contentBased`. Value must be between `300` and `3600`. Any Alerts arriving greater than `timeWindow` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours.
     */
    timeWindow?: pulumi.Input<number>;
    /**
     * The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
     */
    timeout?: pulumi.Input<number>;
}

export interface ServiceAutoPauseNotificationsParameters {
    /**
     * Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
     */
    enabled?: pulumi.Input<boolean>;
    /**
     * Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
     *
     *
     * You may specify one optional `incidentUrgencyRule` block configuring what urgencies to use.
     * Your PagerDuty account must have the `urgencies` ability to assign an incident urgency rule.
     * The block contains the following arguments:
     */
    timeout?: pulumi.Input<number>;
}

export interface ServiceDependencyDependency {
    dependentServices: pulumi.Input<pulumi.Input<inputs.ServiceDependencyDependencyDependentService>[]>;
    supportingServices: pulumi.Input<pulumi.Input<inputs.ServiceDependencyDependencySupportingService>[]>;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceDependencyDependencyDependentService {
    /**
     * The ID of the service dependency.
     */
    id: pulumi.Input<string>;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: pulumi.Input<string>;
}

export interface ServiceDependencyDependencySupportingService {
    /**
     * The ID of the service dependency.
     */
    id: pulumi.Input<string>;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: pulumi.Input<string>;
}

export interface ServiceEventRuleActions {
    /**
     * Note added to the event.
     */
    annotates?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsAnnotate>[]>;
    /**
     * An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
     */
    eventActions?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsEventAction>[]>;
    /**
     * Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
     */
    extractions?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsExtraction>[]>;
    /**
     * The ID of the priority applied to the event.
     */
    priorities?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsPriority>[]>;
    /**
     * The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
     */
    severities?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsSeverity>[]>;
    /**
     * Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
     */
    suppresses?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsSuppress>[]>;
    /**
     * An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
     */
    suspends?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleActionsSuspend>[]>;
}

export interface ServiceEventRuleActionsAnnotate {
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsEventAction {
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsExtraction {
    regex?: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    target?: pulumi.Input<string>;
    template?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsPriority {
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsSeverity {
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleActionsSuppress {
    thresholdTimeAmount?: pulumi.Input<number>;
    thresholdTimeUnit?: pulumi.Input<string>;
    thresholdValue?: pulumi.Input<number>;
    value?: pulumi.Input<boolean>;
}

export interface ServiceEventRuleActionsSuspend {
    value?: pulumi.Input<number>;
}

export interface ServiceEventRuleConditions {
    /**
     * Operator to combine sub-conditions. Can be `and` or `or`.
     */
    operator?: pulumi.Input<string>;
    /**
     * List of sub-conditions that define the condition.
     */
    subconditions?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleConditionsSubcondition>[]>;
}

export interface ServiceEventRuleConditionsSubcondition {
    /**
     * Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
     */
    operator?: pulumi.Input<string>;
    /**
     * Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleConditionsSubconditionParameter>[]>;
}

export interface ServiceEventRuleConditionsSubconditionParameter {
    path?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ServiceEventRuleTimeFrame {
    /**
     * Values for executing the rule during a specific time period.
     */
    activeBetweens?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleTimeFrameActiveBetween>[]>;
    /**
     * Values for executing the rule on a recurring schedule.
     */
    scheduledWeeklies?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleTimeFrameScheduledWeekly>[]>;
}

export interface ServiceEventRuleTimeFrameActiveBetween {
    endTime?: pulumi.Input<number>;
    startTime?: pulumi.Input<number>;
}

export interface ServiceEventRuleTimeFrameScheduledWeekly {
    duration?: pulumi.Input<number>;
    startTime?: pulumi.Input<number>;
    timezone?: pulumi.Input<string>;
    weekdays?: pulumi.Input<pulumi.Input<number>[]>;
}

export interface ServiceEventRuleVariable {
    name?: pulumi.Input<string>;
    parameters?: pulumi.Input<pulumi.Input<inputs.ServiceEventRuleVariableParameter>[]>;
    type?: pulumi.Input<string>;
}

export interface ServiceEventRuleVariableParameter {
    path?: pulumi.Input<string>;
    value?: pulumi.Input<string>;
}

export interface ServiceIncidentUrgencyRule {
    duringSupportHours?: pulumi.Input<inputs.ServiceIncidentUrgencyRuleDuringSupportHours>;
    outsideSupportHours?: pulumi.Input<inputs.ServiceIncidentUrgencyRuleOutsideSupportHours>;
    /**
     * The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
     */
    type: pulumi.Input<string>;
    urgency?: pulumi.Input<string>;
}

export interface ServiceIncidentUrgencyRuleDuringSupportHours {
    /**
     * The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
     */
    type?: pulumi.Input<string>;
    urgency?: pulumi.Input<string>;
}

export interface ServiceIncidentUrgencyRuleOutsideSupportHours {
    /**
     * The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
     */
    type?: pulumi.Input<string>;
    urgency?: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailFilter {
    bodyMode?: pulumi.Input<string>;
    bodyRegex?: pulumi.Input<string>;
    fromEmailMode?: pulumi.Input<string>;
    fromEmailRegex?: pulumi.Input<string>;
    /**
     * The ID of the service integration.
     */
    id?: pulumi.Input<string>;
    subjectMode?: pulumi.Input<string>;
    subjectRegex?: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailParser {
    action: pulumi.Input<string>;
    /**
     * The ID of the service integration.
     */
    id?: pulumi.Input<number>;
    matchPredicate: pulumi.Input<inputs.ServiceIntegrationEmailParserMatchPredicate>;
    valueExtractors?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEmailParserValueExtractor>[]>;
}

export interface ServiceIntegrationEmailParserMatchPredicate {
    predicates?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEmailParserMatchPredicatePredicate>[]>;
    type: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailParserMatchPredicatePredicate {
    matcher?: pulumi.Input<string>;
    part?: pulumi.Input<string>;
    predicates?: pulumi.Input<pulumi.Input<inputs.ServiceIntegrationEmailParserMatchPredicatePredicatePredicate>[]>;
    type: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailParserMatchPredicatePredicatePredicate {
    matcher: pulumi.Input<string>;
    part: pulumi.Input<string>;
    type: pulumi.Input<string>;
}

export interface ServiceIntegrationEmailParserValueExtractor {
    endsBefore?: pulumi.Input<string>;
    part: pulumi.Input<string>;
    regex?: pulumi.Input<string>;
    startsAfter?: pulumi.Input<string>;
    type: pulumi.Input<string>;
    valueName: pulumi.Input<string>;
}

export interface ServiceScheduledAction {
    ats?: pulumi.Input<pulumi.Input<inputs.ServiceScheduledActionAt>[]>;
    toUrgency?: pulumi.Input<string>;
    /**
     * The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceScheduledActionAt {
    name?: pulumi.Input<string>;
    /**
     * The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
     */
    type?: pulumi.Input<string>;
}

export interface ServiceSupportHours {
    daysOfWeeks?: pulumi.Input<pulumi.Input<number>[]>;
    endTime?: pulumi.Input<string>;
    startTime?: pulumi.Input<string>;
    timeZone?: pulumi.Input<string>;
    /**
     * The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
     */
    type?: pulumi.Input<string>;
}

export interface SlackConnectionConfig {
    events: pulumi.Input<pulumi.Input<string>[]>;
    priorities?: pulumi.Input<pulumi.Input<string>[]>;
    urgency?: pulumi.Input<string>;
}

export interface WebhookSubscriptionDeliveryMethod {
    /**
     * The customHeader of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
     */
    customHeaders?: pulumi.Input<pulumi.Input<inputs.WebhookSubscriptionDeliveryMethodCustomHeader>[]>;
    /**
     * Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
     */
    temporarilyDisabled?: pulumi.Input<boolean>;
    /**
     * Indicates the type of the delivery method. Allowed and default value: `httpDeliveryMethod`.
     */
    type?: pulumi.Input<string>;
    /**
     * The destination URL for webhook delivery.
     */
    url?: pulumi.Input<string>;
}

export interface WebhookSubscriptionDeliveryMethodCustomHeader {
    name: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface WebhookSubscriptionFilter {
    /**
     * The id of the object being used as the filter. This field is required for all filter types except account_reference.
     */
    id?: pulumi.Input<string>;
    /**
     * The type of object being used as the filter. Allowed values are `accountReference`, `serviceReference`, and `teamReference`.
     */
    type: pulumi.Input<string>;
}
export namespace config {
}
