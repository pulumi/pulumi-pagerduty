// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AlertGroupingSettingConfig {
    /**
     * One of `any` or `all`. This setting is only required and applies when `type` is set to `contentBased` or `contentBasedIntelligent`. Group alerts based on one or all of `fields` value(s).
     */
    aggregate?: string;
    /**
     * Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `contentBased` or `contentBasedIntelligent`.
     */
    fields?: string[];
    /**
     * An array of strings which represent the iag fields with which to intelligently group against.  This setting applies only when `type` is set to `intelligent`. Default: ["summary"].
     */
    iagFields: string[];
    /**
     * The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `contentBased`, `contentBasedIntelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `contentBased` alert grouping). Any Alerts arriving greater than `timeWindow` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
     */
    timeWindow: number;
    /**
     * The duration in seconds within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
     */
    timeout: number;
}

export interface AutomationActionsActionActionDataReference {
    /**
     * The command to execute the script with.
     */
    invocationCommand?: string;
    /**
     * The arguments to pass to the Process Automation job execution.
     */
    processAutomationJobArguments?: string;
    /**
     * The ID of the Process Automation job to execute.
     */
    processAutomationJobId?: string;
    /**
     * The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
     */
    processAutomationNodeFilter?: string;
    /**
     * Body of the script to be executed on the Runner. Max length is 16777215 characters.
     */
    script?: string;
}

export interface EscalationPolicyRule {
    /**
     * The number of minutes before an unacknowledged incident escalates away from this rule.
     */
    escalationDelayInMinutes: number;
    /**
     * The strategy used to assign the escalation rule to an incident. Documented below.
     */
    escalationRuleAssignmentStrategy: outputs.EscalationPolicyRuleEscalationRuleAssignmentStrategy;
    /**
     * The ID of the escalation policy.
     */
    id: string;
    targets: outputs.EscalationPolicyRuleTarget[];
}

export interface EscalationPolicyRuleEscalationRuleAssignmentStrategy {
    /**
     * Can be `roundRobin` or `assignToEveryone`.
     */
    type: string;
}

export interface EscalationPolicyRuleTarget {
    /**
     * A target ID
     */
    id: string;
    /**
     * Can be `userReference` or `scheduleReference`. Defaults to `userReference`. For multiple users as example, repeat the target.
     */
    type?: string;
}

export interface EventOrchestrationGlobalCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationGlobalCacheVariableConfiguration {
    /**
     * The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `externalData`
     */
    dataType?: string;
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source?: string;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount` or `externalData`
     */
    ttlSeconds?: number;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue`, `triggerEventCount` or `externalData`.
     */
    type: string;
}

export interface EventOrchestrationGlobalCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: outputs.EventOrchestrationGlobalCatchAllActions;
}

export interface EventOrchestrationGlobalCatchAllActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: string;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
     */
    automationAction?: outputs.EventOrchestrationGlobalCatchAllActionsAutomationAction;
    /**
     * When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
     */
    dropEvent?: boolean;
    /**
     * The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
     */
    escalationPolicy?: string;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationGlobalCatchAllActionsExtraction[];
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: outputs.EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate[];
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: string;
    /**
     * The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: boolean;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: number;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationGlobalCatchAllActionsVariable[];
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: boolean;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: outputs.EventOrchestrationGlobalCatchAllActionsAutomationActionHeader[];
    /**
     * Name of this Webhook.
     */
    name: string;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: outputs.EventOrchestrationGlobalCatchAllActionsAutomationActionParameter[];
    /**
     * The Webhook will be associated (or automatically triggered, if `autoSend` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alertTriggered"]`, `["alertSuspended"]`, `["alertSuppressed"]`. NOTE: `autoSend` must be `true` for trigger types of `["alertSuspended"]` and `["alertSuppressed"]`
     */
    triggerTypes?: string;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: string;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationActionHeader {
    /**
     * Name to identify the header
     */
    key: string;
    /**
     * Value of this header
     */
    value: string;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationActionParameter {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * Value of this parameter
     */
    value: string;
}

export interface EventOrchestrationGlobalCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: string;
    /**
     * The value to assign to this custom field
     */
    value: string;
}

export interface EventOrchestrationGlobalCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: string;
    /**
     * The Global Orchestration evaluates Events against these Rules, one at a time, and applies all the actions for first rule it finds where the event matches the rule's conditions. If no rules are provided as part of Terraform configuration, the API returns empty list of rules.
     */
    rules?: outputs.EventOrchestrationGlobalSetRule[];
}

export interface EventOrchestrationGlobalSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: outputs.EventOrchestrationGlobalSetRuleActions;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: outputs.EventOrchestrationGlobalSetRuleCondition[];
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: boolean;
    /**
     * The ID of the rule within the set.
     */
    id: string;
    /**
     * A description of this rule's purpose.
     */
    label?: string;
}

export interface EventOrchestrationGlobalSetRuleActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: string;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
     */
    automationAction?: outputs.EventOrchestrationGlobalSetRuleActionsAutomationAction;
    /**
     * When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
     */
    dropEvent?: boolean;
    /**
     * The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
     */
    escalationPolicy?: string;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationGlobalSetRuleActionsExtraction[];
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: outputs.EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate[];
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: string;
    /**
     * The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: boolean;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: number;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationGlobalSetRuleActionsVariable[];
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: boolean;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: outputs.EventOrchestrationGlobalSetRuleActionsAutomationActionHeader[];
    /**
     * Name of this Webhook.
     */
    name: string;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: outputs.EventOrchestrationGlobalSetRuleActionsAutomationActionParameter[];
    /**
     * The Webhook will be associated (or automatically triggered, if `autoSend` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alertTriggered"]`, `["alertSuspended"]`, `["alertSuppressed"]`. NOTE: `autoSend` must be `true` for trigger types of `["alertSuspended"]` and `["alertSuppressed"]`
     */
    triggerTypes?: string;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: string;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationActionHeader {
    /**
     * Name to identify the header
     */
    key: string;
    /**
     * Value of this header
     */
    value: string;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationActionParameter {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * Value of this parameter
     */
    value: string;
}

export interface EventOrchestrationGlobalSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: string;
    /**
     * The value to assign to this custom field
     */
    value: string;
}

export interface EventOrchestrationGlobalSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationIntegration {
    /**
     * ID of the integration
     */
    id: string;
    label: string;
    /**
     * A single-item list containing a parameter object describing the integration
     */
    parameters: outputs.EventOrchestrationIntegrationParameter[];
}

export interface EventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type: string;
}

export interface EventOrchestrationRouterCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident.
     */
    actions: outputs.EventOrchestrationRouterCatchAllActions;
}

export interface EventOrchestrationRouterCatchAllActions {
    /**
     * Defines where an alert will be sent if doesn't match any rules. Can either be the ID of a Service _or_ the string `"unrouted"` to send events to the Unrouted Orchestration.
     */
    routeTo: string;
}

export interface EventOrchestrationRouterSet {
    /**
     * ID of the `start` set. Router supports only one set and it's id has to be `start`
     */
    id: string;
    /**
     * The Router evaluates Events against these Rules, one at a time, and routes each Event to a specific Service based on the first rule that matches. If no rules are provided as part of Terraform configuration, the API returns empty list of rules.
     */
    rules?: outputs.EventOrchestrationRouterSetRule[];
}

export interface EventOrchestrationRouterSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: outputs.EventOrchestrationRouterSetRuleActions;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
     */
    conditions?: outputs.EventOrchestrationRouterSetRuleCondition[];
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: boolean;
    /**
     * The ID of the rule within the `start` set.
     */
    id: string;
    /**
     * A description of this rule's purpose.
     */
    label?: string;
}

export interface EventOrchestrationRouterSetRuleActions {
    /**
     * supports the following:
     */
    dynamicRouteTos?: outputs.EventOrchestrationRouterSetRuleActionsDynamicRouteTo[];
    routeTo?: string;
}

export interface EventOrchestrationRouterSetRuleActionsDynamicRouteTo {
    /**
     * Indicates whether the extracted value from the source is a service's name or ID. Allowed values are: `serviceName`, `serviceId`
     *
     * If an event has a value at the specified `source`, and if the `regex` successfully matches the value, and if the matching portion is valid Service ID or Name, then the event will be routed to that service. Otherwise the event will be checked against any subsequent router rules.
     */
    lookupBy: string;
    /**
     * The regular expression, used to extract a value from the source field. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    regex: string;
    /**
     * The path to a field in an event.
     */
    source: string;
}

export interface EventOrchestrationRouterSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationServiceCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationServiceCacheVariableConfiguration {
    /**
     * The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `externalData`
     */
    dataType?: string;
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source?: string;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount` or `externalData`
     */
    ttlSeconds?: number;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue`, `triggerEventCount` or `externalData`.
     */
    type: string;
}

export interface EventOrchestrationServiceCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: outputs.EventOrchestrationServiceCatchAllActions;
}

export interface EventOrchestrationServiceCatchAllActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: string;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
     */
    automationAction?: outputs.EventOrchestrationServiceCatchAllActionsAutomationAction;
    /**
     * The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
     */
    escalationPolicy?: string;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationServiceCatchAllActionsExtraction[];
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: outputs.EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate[];
    /**
     * Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) to be run for certain alert states.
     */
    pagerdutyAutomationAction?: outputs.EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction;
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: string;
    /**
     * The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
     *
     * @deprecated The 'route_to' attribute is no longer supported for catch-all rules.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: boolean;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: number;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationServiceCatchAllActionsVariable[];
}

export interface EventOrchestrationServiceCatchAllActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: boolean;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: outputs.EventOrchestrationServiceCatchAllActionsAutomationActionHeader[];
    /**
     * Name of this Webhook.
     */
    name: string;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: outputs.EventOrchestrationServiceCatchAllActionsAutomationActionParameter[];
    /**
     * The Webhook will be associated (or automatically triggered, if `autoSend` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alertTriggered"]`, `["alertSuspended"]`, `["alertSuppressed"]`. NOTE: `autoSend` must be `true` for trigger types of `["alertSuspended"]` and `["alertSuppressed"]`
     */
    triggerTypes?: string;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: string;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationActionHeader {
    /**
     * Name to identify the header
     */
    key: string;
    /**
     * Value of this header
     */
    value: string;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationActionParameter {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * Value of this parameter
     */
    value: string;
}

export interface EventOrchestrationServiceCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: string;
    /**
     * The value to assign to this custom field
     */
    value: string;
}

export interface EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction {
    /**
     * Id of the Process Automation action to be triggered.
     */
    actionId: string;
    /**
     * The Automation Action will be triggered whenever an alert reaches the specified state. Allowed values are: `["alertTriggered"]`, `["alertSuspended"]`, `["alertSuppressed"]`
     */
    triggerTypes?: string;
}

export interface EventOrchestrationServiceCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: string;
    /**
     * The service orchestration evaluates Events against these Rules, one at a time, and applies all the actions for first rule it finds where the event matches the rule's conditions. If no rules are provided as part of Terraform configuration, the API returns empty list of rules.
     */
    rules?: outputs.EventOrchestrationServiceSetRule[];
}

export interface EventOrchestrationServiceSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: outputs.EventOrchestrationServiceSetRuleActions;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: outputs.EventOrchestrationServiceSetRuleCondition[];
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: boolean;
    /**
     * The ID of the rule within the set.
     */
    id: string;
    /**
     * A description of this rule's purpose.
     */
    label?: string;
}

export interface EventOrchestrationServiceSetRuleActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: string;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
     */
    automationAction?: outputs.EventOrchestrationServiceSetRuleActionsAutomationAction;
    /**
     * The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
     */
    escalationPolicy?: string;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationServiceSetRuleActionsExtraction[];
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: outputs.EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate[];
    /**
     * Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) to be run for certain alert states.
     */
    pagerdutyAutomationAction?: outputs.EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction;
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: string;
    /**
     * The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: boolean;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: number;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationServiceSetRuleActionsVariable[];
}

export interface EventOrchestrationServiceSetRuleActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: boolean;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: outputs.EventOrchestrationServiceSetRuleActionsAutomationActionHeader[];
    /**
     * Name of this Webhook.
     */
    name: string;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: outputs.EventOrchestrationServiceSetRuleActionsAutomationActionParameter[];
    /**
     * The Webhook will be associated (or automatically triggered, if `autoSend` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alertTriggered"]`, `["alertSuspended"]`, `["alertSuppressed"]`. NOTE: `autoSend` must be `true` for trigger types of `["alertSuspended"]` and `["alertSuppressed"]`
     */
    triggerTypes?: string;
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: string;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationActionHeader {
    /**
     * Name to identify the header
     */
    key: string;
    /**
     * Value of this header
     */
    value: string;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationActionParameter {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * Value of this parameter
     */
    value: string;
}

export interface EventOrchestrationServiceSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: string;
    /**
     * The value to assign to this custom field
     */
    value: string;
}

export interface EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction {
    /**
     * Id of the Process Automation action to be triggered.
     */
    actionId: string;
    /**
     * The Automation Action will be triggered whenever an alert reaches the specified state. Allowed values are: `["alertTriggered"]`, `["alertSuspended"]`, `["alertSuppressed"]`
     */
    triggerTypes?: string;
}

export interface EventOrchestrationServiceSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationUnroutedCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: outputs.EventOrchestrationUnroutedCatchAllActions;
}

export interface EventOrchestrationUnroutedCatchAllActions {
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationUnroutedCatchAllActionsExtraction[];
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    suppress: boolean;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationUnroutedCatchAllActionsVariable[];
}

export interface EventOrchestrationUnroutedCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationUnroutedCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationUnroutedSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: string;
    /**
     * The Unrouted Orchestration evaluates Events against these Rules, one at a time, and applies all the actions for first rule it finds where the event matches the rule's conditions. If no rules are provided as part of Terraform configuration, the API returns empty list of rules.
     */
    rules?: outputs.EventOrchestrationUnroutedSetRule[];
}

export interface EventOrchestrationUnroutedSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: outputs.EventOrchestrationUnroutedSetRuleActions;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: outputs.EventOrchestrationUnroutedSetRuleCondition[];
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: boolean;
    /**
     * The ID of the rule within the set.
     */
    id: string;
    /**
     * A description of this rule's purpose.
     */
    label?: string;
}

export interface EventOrchestrationUnroutedSetRuleActions {
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationUnroutedSetRuleActionsExtraction[];
    /**
     * The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationUnroutedSetRuleActionsVariable[];
}

export interface EventOrchestrationUnroutedSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationUnroutedSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationUnroutedSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface GetAlertGroupingSettingConfig {
    /**
     * One of `any` or `all`. This setting is only required and applies when `type` is set to `contentBased` or `contentBasedIntelligent`. Group alerts based on one or all of `fields` value(s).
     */
    aggregate: string;
    /**
     * Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `contentBased` or `contentBasedIntelligent`.
     */
    fields: string[];
    /**
     * An array of strings which represent the iag fields with which to intelligently group against.
     */
    iagFields: string[];
    /**
     * The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `contentBased`, `contentBasedIntelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `contentBased` alert grouping). Any Alerts arriving greater than `timeWindow` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
     */
    timeWindow: number;
    /**
     * The duration in minutes within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
     */
    timeout: number;
}

export interface GetAutomationActionsActionActionDataReference {
    /**
     * (Optional) The command to execute the script with.
     */
    invocationCommand: string;
    /**
     * (Optional) The arguments to pass to the Process Automation job execution.
     */
    processAutomationJobArguments: string;
    /**
     * (Required for `processAutomation` action_type) The ID of the Process Automation job to execute.
     */
    processAutomationJobId: string;
    /**
     * (Optional) The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
     */
    processAutomationNodeFilter: string;
    /**
     * (Required for `script` action_type) Body of the script to be executed on the Runner. Max length is 16777215 characters.
     */
    script: string;
}

export interface GetEventOrchestrationGlobalCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface GetEventOrchestrationGlobalCacheVariableConfiguration {
    /**
     * The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `externalData`
     */
    dataType?: string;
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source: string;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount` or `externalData`
     */
    ttlSeconds: number;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue`, `triggerEventCount` or `externalData`.
     */
    type: string;
}

export interface GetEventOrchestrationIntegrationDetail {
    /**
     * ID of the integration
     */
    id: string;
    label: string;
    /**
     * A single-item list containing a parameter object describing the integration
     */
    parameters: outputs.GetEventOrchestrationIntegrationDetailParameter[];
}

export interface GetEventOrchestrationIntegrationDetailParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type: string;
}

export interface GetEventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type: string;
}

export interface GetEventOrchestrationServiceCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface GetEventOrchestrationServiceCacheVariableConfiguration {
    /**
     * The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `externalData`
     */
    dataType?: string;
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source: string;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount` or `externalData`
     */
    ttlSeconds: number;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue`, `triggerEventCount` or `externalData`.
     */
    type: string;
}

export interface GetEventOrchestrationsEventOrchestration {
    /**
     * ID of the integration
     */
    id: string;
    /**
     * A list of integrations for the Event Orchestration.
     */
    integrations: outputs.GetEventOrchestrationsEventOrchestrationIntegration[];
    /**
     * The name of the found Event Orchestration.
     */
    name: string;
}

export interface GetEventOrchestrationsEventOrchestrationIntegration {
    /**
     * ID of the integration
     */
    id: string;
    label: string;
    /**
     * A single-item list containing a parameter object describing the integration
     */
    parameters: outputs.GetEventOrchestrationsEventOrchestrationIntegrationParameter[];
}

export interface GetEventOrchestrationsEventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type: string;
}

export interface GetIncidentTypeCustomFieldFieldOption {
    data: outputs.GetIncidentTypeCustomFieldFieldOptionData;
    id: string;
    type: string;
}

export interface GetIncidentTypeCustomFieldFieldOptionData {
    dataType: string;
    value: string;
}

export interface GetLicensesLicense {
    /**
     * Available allocations to assign to users
     */
    allocationsAvailable: number;
    /**
     * The number of allocations already assigned to users
     */
    currentValue: number;
    /**
     * Description of the license
     */
    description: string;
    htmlUrl: string;
    /**
     * Allows to override the default behavior for setting the `id` attribute that is required for data sources.
     */
    id: string;
    /**
     * Name of the license
     */
    name: string;
    /**
     * The role group for the license that determines the available `validRoles`
     */
    roleGroup: string;
    self: string;
    /**
     * Summary of the license
     */
    summary: string;
    type: string;
    /**
     * List of allowed roles that may be assigned to a user with this license
     */
    validRoles: string[];
}

export interface GetServiceCustomFieldFieldOption {
    /**
     * The data type of the field option.
     */
    dataType: string;
    /**
     * The ID of the found field.
     */
    id: string;
    /**
     * The value of the field option.
     */
    value: string;
}

export interface GetServiceCustomFieldValueCustomField {
    /**
     * The kind of data the custom field is allowed to contain. Can be one of: `string`, `integer`, `float`, `boolean`, `datetime`, or `url`.
     */
    dataType: string;
    /**
     * A description of the data this field contains.
     */
    description: string;
    /**
     * The human-readable name of the custom field.
     */
    displayName: string;
    /**
     * The type of field. Can be one of: `singleValue`, `singleValueFixed`, `multiValue`, or `multiValueFixed`.
     */
    fieldType: string;
    /**
     * The ID of the custom field.
     */
    id: string;
    /**
     * The name of the custom field.
     */
    name: string;
    /**
     * The type of the reference, typically "fieldValue".
     */
    type: string;
    /**
     * The value of the custom field. This is a JSON-encoded string matching the field's data type.
     */
    value: string;
}

export interface GetServiceTeam {
    /**
     * The ID of the found service.
     */
    id: string;
    /**
     * The service name to use to find a service in the PagerDuty API.
     */
    name: string;
}

export interface GetStandardsResourceScoresScore {
    /**
     * Number of standards this resource successfully complies to.
     */
    passing: number;
    /**
     * Number of standards associated to this resource.
     */
    total: number;
}

export interface GetStandardsResourceScoresStandard {
    /**
     * Indicates whether the standard is currently active and applicable to the resource.
     */
    active: boolean;
    /**
     * Provides a textual description of the standard.
     */
    description: string;
    /**
     * Identifier of said resource.
     */
    id: string;
    /**
     * The human-readable name of the standard.
     */
    name: string;
    /**
     * Indicates whether the resource complies to this standard.
     */
    pass: boolean;
    /**
     * The type of the standard.
     */
    type: string;
}

export interface GetStandardsResourcesScoresResource {
    /**
     * Unique Identifier.
     */
    resourceId: string;
    /**
     * Type of the object the standards are associated to. Allowed values are `technicalServices`.
     */
    resourceType: string;
    /**
     * Summary of the scores for standards associated with this resource.
     */
    score: outputs.GetStandardsResourcesScoresResourceScore;
    /**
     * The list of standards evaluated against.
     */
    standards: outputs.GetStandardsResourcesScoresResourceStandard[];
}

export interface GetStandardsResourcesScoresResourceScore {
    /**
     * Number of standards this resource successfully complies to.
     */
    passing: number;
    /**
     * Number of standards associated to this resource.
     */
    total: number;
}

export interface GetStandardsResourcesScoresResourceStandard {
    /**
     * Indicates whether the standard is currently active and applicable to the resource.
     */
    active: boolean;
    /**
     * Provides a textual description of the standard.
     */
    description: string;
    /**
     * A unique identifier for the standard.
     */
    id: string;
    /**
     * The human-readable name of the standard.
     */
    name: string;
    /**
     * Indicates whether the resource complies to this standard.
     */
    pass: boolean;
    /**
     * The type of the standard.
     */
    type: string;
}

export interface GetStandardsStandard {
    /**
     * Indicates whether the standard is currently active and applicable to the resource.
     */
    active: boolean;
    /**
     * Provides a textual description of the standard.
     */
    description: string;
    /**
     * A list of exceptions for the application of this standard.
     */
    exclusions: outputs.GetStandardsStandardExclusion[];
    /**
     * The unique identifier for the resource being included.
     */
    id: string;
    /**
     * A list of explict instances this standard applies to.
     */
    inclusions: outputs.GetStandardsStandardInclusion[];
    /**
     * The human-readable name of the standard.
     */
    name: string;
    /**
     * Filter by `resourceType` the received standards. Allowed values are `technicalService`.
     */
    resourceType: string;
    /**
     * Specifies the type of resource this inclusion applies to.
     */
    type: string;
}

export interface GetStandardsStandardExclusion {
    /**
     * The unique identifier for the resource being included.
     */
    id: string;
    /**
     * Specifies the type of resource this inclusion applies to.
     */
    type: string;
}

export interface GetStandardsStandardInclusion {
    /**
     * The unique identifier for the resource being included.
     */
    id: string;
    /**
     * Specifies the type of resource this inclusion applies to.
     */
    type: string;
}

export interface GetTeamMembersMember {
    /**
     * The ID of the found user.
     */
    id: string;
    /**
     * The team role of the found user.
     */
    role: string;
    /**
     * A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to name, though it is not intended to be an identifier.
     */
    summary: string;
    /**
     * The type of object. The value returned will be `userReference`. Can be used for passing to another object as dependency.
     */
    type: string;
}

export interface GetTeamsTeam {
    /**
     * The description of the team.
     */
    description: string;
    /**
     * The ID of the team.
     */
    id: string;
    /**
     * The name of the team.
     */
    name: string;
    /**
     * A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to name, though it is not intended to be an identifier.
     */
    summary: string;
}

export interface GetUsersUser {
    /**
     * The human-friendly description of the found user.
     */
    description: string;
    /**
     * The email of the found user.
     */
    email: string;
    /**
     * The ID of the found user.
     */
    id: string;
    /**
     * The job title of the found user.
     */
    jobTitle: string;
    /**
     * The short name of the found user.
     */
    name: string;
    /**
     * The role of the found user.
     */
    role: string;
    /**
     * The timezone of the found user.
     */
    timeZone: string;
    type: string;
}

export interface IncidentWorkflowStep {
    /**
     * The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
     */
    action: string;
    /**
     * The ID of the incident workflow.
     */
    id: string;
    /**
     * The list of inputs that contain a series of inline steps for the workflow action.
     */
    inlineStepsInputs?: outputs.IncidentWorkflowStepInlineStepsInput[];
    /**
     * The list of standard inputs for the workflow action.
     */
    inputs: outputs.IncidentWorkflowStepInput[];
    /**
     * The name of the workflow step.
     */
    name: string;
}

export interface IncidentWorkflowStepInlineStepsInput {
    /**
     * The name of the input.
     */
    name: string;
    /**
     * The inline steps of the input. An inline step adheres to the step schema described above.
     */
    steps: outputs.IncidentWorkflowStepInlineStepsInputStep[];
}

export interface IncidentWorkflowStepInlineStepsInputStep {
    /**
     * The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
     */
    action: string;
    /**
     * The list of standard inputs for the workflow action.
     */
    inputs: outputs.IncidentWorkflowStepInlineStepsInputStepInput[];
    /**
     * The name of the workflow step.
     */
    name: string;
}

export interface IncidentWorkflowStepInlineStepsInputStepInput {
    generated: boolean;
    /**
     * The name of the input.
     */
    name: string;
    /**
     * The value of the input.
     */
    value: string;
}

export interface IncidentWorkflowStepInput {
    generated: boolean;
    /**
     * The name of the input.
     */
    name: string;
    /**
     * The value of the input.
     */
    value: string;
}

export interface IncidentWorkflowTriggerPermissions {
    /**
     * If `true`, indicates that the Trigger can only be started by authorized Users. If `false` (default), any user can start this Trigger. Applicable only to `manual`-type triggers.
     */
    restricted: boolean;
    /**
     * The ID of the Team whose members can manually start this Trigger. Required and allowed only if `restricted` is `true`.
     */
    teamId?: string;
}

export interface JiraCloudAccountMappingRuleConfig {
    /**
     * Synchronization settings.
     */
    jira?: outputs.JiraCloudAccountMappingRuleConfigJira;
    /**
     * [Updating can cause a resource replacement] The ID of the linked PagerDuty service.
     */
    service: string;
}

export interface JiraCloudAccountMappingRuleConfigJira {
    /**
     * JQL query to automatically create PagerDuty incidents when matching Jira issues are created. Leave empty to disable this feature.
     */
    autocreateJql?: string;
    /**
     * When enabled, automatically creates a Jira issue whenever a PagerDuty incident is triggered.
     */
    createIssueOnIncidentTrigger: boolean;
    /**
     * Defines how Jira fields are populated when a Jira Issue is created from a PagerDuty Incident.
     */
    customFields?: outputs.JiraCloudAccountMappingRuleConfigJiraCustomField[];
    /**
     * Specifies the Jira issue type to be created or synchronized with PagerDuty incidents.
     */
    issueType?: outputs.JiraCloudAccountMappingRuleConfigJiraIssueType;
    /**
     * Maps PagerDuty incident priorities to Jira issue priorities for synchronization.
     */
    priorities?: outputs.JiraCloudAccountMappingRuleConfigJiraPriority[];
    /**
     * [Updating can cause a resource replacement] Defines the Jira project where issues will be created or synchronized.
     */
    project?: outputs.JiraCloudAccountMappingRuleConfigJiraProject;
    /**
     * Maps PagerDuty incident statuses to corresponding Jira issue statuses for synchronization.
     */
    statusMapping?: outputs.JiraCloudAccountMappingRuleConfigJiraStatusMapping;
    /**
     * ID of the PagerDuty user for syncing notes and comments between Jira issues and PagerDuty incidents. If not provided, note synchronization is disabled.
     */
    syncNotesUser?: string;
}

export interface JiraCloudAccountMappingRuleConfigJiraCustomField {
    /**
     * The PagerDuty incident field from which the value will be extracted (only applicable if `type` is `attribute`); one of `incidentNumber`, `incidentTitle`, `incidentDescription`, `incidentStatus`, `incidentCreatedAt`, `incidentService`, `incidentEscalationPolicy`, `incidentImpactedServices`, `incidentHtmlUrl`, `incidentAssignees`, `incidentAcknowledgers`, `incidentLastStatusChangeAt`, `incidentLastStatusChangeBy`, `incidentUrgency` or `incidentPriority`.
     */
    sourceIncidentField?: string;
    /**
     * The unique identifier key of the Jira field that will be set.
     */
    targetIssueField: string;
    /**
     * The human-readable name of the Jira field.
     */
    targetIssueFieldName: string;
    /**
     * The type of the value that will be set; one of `attribute`, `const` or `jiraValue`.
     */
    type: string;
    /**
     * The value to be set for the Jira field (only applicable if `type` is `const` or `jiraValue`). It must be set as a JSON string.
     */
    value?: string;
}

export interface JiraCloudAccountMappingRuleConfigJiraIssueType {
    /**
     * Unique identifier for the Jira issue type.
     */
    id: string;
    /**
     * The name of the Jira issue type.
     */
    name: string;
}

export interface JiraCloudAccountMappingRuleConfigJiraPriority {
    /**
     * The ID of the Jira priority.
     */
    jiraId: string;
    /**
     * The ID of the PagerDuty priority.
     */
    pagerdutyId: string;
}

export interface JiraCloudAccountMappingRuleConfigJiraProject {
    /**
     * Unique identifier for the Jira project.
     */
    id: string;
    /**
     * The short key name of the Jira project.
     */
    key: string;
    /**
     * The name of the Jira project.
     */
    name: string;
}

export interface JiraCloudAccountMappingRuleConfigJiraStatusMapping {
    /**
     * Jira status that maps to the PagerDuty `acknowledged` status.
     */
    acknowledged?: outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledged;
    /**
     * Jira status that maps to the PagerDuty `resolved` status.
     */
    resolved?: outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingResolved;
    /**
     * Jira status that maps to the PagerDuty `triggered` status.
     */
    triggered?: outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggered;
}

export interface JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledged {
    /**
     * Unique identifier for the Jira status.
     */
    id?: string;
    /**
     * Name of the Jira status.
     */
    name?: string;
}

export interface JiraCloudAccountMappingRuleConfigJiraStatusMappingResolved {
    /**
     * Unique identifier for the Jira status.
     */
    id?: string;
    /**
     * Name of the Jira status.
     */
    name?: string;
}

export interface JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggered {
    /**
     * Unique identifier for the Jira status.
     */
    id: string;
    /**
     * Name of the Jira status.
     */
    name: string;
}

export interface ResponsePlayResponder {
    /**
     * Description of escalation policy
     */
    description?: string;
    /**
     * The escalation rules
     */
    escalationRules: outputs.ResponsePlayResponderEscalationRule[];
    /**
     * ID of the user defined as the responder
     */
    id?: string;
    /**
     * Name of the escalation policy
     */
    name?: string;
    /**
     * The number of times the escalation policy will repeat after reaching the end of its escalation.
     */
    numLoops: number;
    /**
     * Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "ifHasServices". Could be "ifHasServices", "always
     */
    onCallHandoffNotifications: string;
    /**
     * There can be multiple services associated with a policy.
     */
    services: outputs.ResponsePlayResponderService[];
    /**
     * Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
     */
    teams: outputs.ResponsePlayResponderTeam[];
    /**
     * Should be set as `escalationPolicy` for escalation policy responders.
     */
    type?: string;
}

export interface ResponsePlayResponderEscalationRule {
    /**
     * The number of minutes before an unacknowledged incident escalates away from this rule.
     */
    escalationDelayInMinutes: number;
    /**
     * The ID of the response play.
     */
    id: string;
    /**
     * The targets an incident should be assigned to upon reaching this rule.
     */
    targets: outputs.ResponsePlayResponderEscalationRuleTarget[];
}

export interface ResponsePlayResponderEscalationRuleTarget {
    /**
     * The ID of the response play.
     */
    id: string;
    /**
     * Type of object of the target. Supported types are `userReference`, `scheduleReference`.
     */
    type: string;
}

export interface ResponsePlayResponderService {
    /**
     * The ID of the response play.
     */
    id: string;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type: string;
}

export interface ResponsePlayResponderTeam {
    /**
     * The ID of the response play.
     */
    id: string;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type: string;
}

export interface ResponsePlaySubscriber {
    /**
     * The ID of the response play.
     */
    id?: string;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type?: string;
}

export interface RulesetRuleActions {
    /**
     * Note added to the event.
     */
    annotates?: outputs.RulesetRuleActionsAnnotate[];
    /**
     * An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
     */
    eventActions?: outputs.RulesetRuleActionsEventAction[];
    /**
     * Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
     */
    extractions?: outputs.RulesetRuleActionsExtraction[];
    /**
     * The ID of the priority applied to the event.
     */
    priorities?: outputs.RulesetRuleActionsPriority[];
    /**
     * The ID of the service where the event will be routed.
     */
    routes?: outputs.RulesetRuleActionsRoute[];
    /**
     * The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
     */
    severities?: outputs.RulesetRuleActionsSeverity[];
    /**
     * Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
     */
    suppresses?: outputs.RulesetRuleActionsSuppress[];
    /**
     * An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
     */
    suspends?: outputs.RulesetRuleActionsSuspend[];
}

export interface RulesetRuleActionsAnnotate {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsEventAction {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsExtraction {
    /**
     * The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
     *
     * *- **OR** -*
     */
    regex?: string;
    /**
     * Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    source?: string;
    /**
     * Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     *
     * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
     */
    target?: string;
    /**
     * A customized field message. This can also include variables extracted from the payload by using string interpolation.
     */
    template?: string;
}

export interface RulesetRuleActionsPriority {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsRoute {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsSeverity {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsSuppress {
    /**
     * The number value of the `thresholdTimeUnit` before an incident is created. Must be greater than 0.
     */
    thresholdTimeAmount?: number;
    /**
     * The `seconds`,`minutes`, or `hours` the `thresholdTimeAmount` should be measured.
     */
    thresholdTimeUnit?: string;
    /**
     * The number of alerts that should be suppressed. Must be greater than 0.
     */
    thresholdValue?: number;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: boolean;
}

export interface RulesetRuleActionsSuspend {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: number;
}

export interface RulesetRuleConditions {
    /**
     * Operator to combine sub-conditions. Can be `and` or `or`.
     */
    operator?: string;
    /**
     * List of sub-conditions that define the condition.
     */
    subconditions?: outputs.RulesetRuleConditionsSubcondition[];
}

export interface RulesetRuleConditionsSubcondition {
    /**
     * Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
     */
    operator?: string;
    /**
     * Parameter for the sub-condition. It requires both a `path` and `value` to be set.
     */
    parameters?: outputs.RulesetRuleConditionsSubconditionParameter[];
}

export interface RulesetRuleConditionsSubconditionParameter {
    path?: string;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleTimeFrame {
    /**
     * Values for executing the rule during a specific time period.
     */
    activeBetweens?: outputs.RulesetRuleTimeFrameActiveBetween[];
    /**
     * Values for executing the rule on a recurring schedule.
     */
    scheduledWeeklies?: outputs.RulesetRuleTimeFrameScheduledWeekly[];
}

export interface RulesetRuleTimeFrameActiveBetween {
    endTime?: number;
    /**
     * A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `timeStatic` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
     */
    startTime?: number;
}

export interface RulesetRuleTimeFrameScheduledWeekly {
    /**
     * Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `startTime`.
     */
    duration?: number;
    /**
     * A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `timeStatic` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
     */
    startTime?: number;
    /**
     * [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
     */
    timezone?: string;
    /**
     * An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
     */
    weekdays?: number[];
}

export interface RulesetRuleVariable {
    name?: string;
    parameters?: outputs.RulesetRuleVariableParameter[];
    type?: string;
}

export interface RulesetRuleVariableParameter {
    path?: string;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetTeam {
    /**
     * The ID of the ruleset.
     */
    id: string;
}

export interface ScheduleFinalSchedule {
    /**
     * The name of the schedule.
     */
    name: string;
    renderedCoveragePercentage: string;
}

export interface ScheduleLayer {
    /**
     * The end time of the schedule layer. If not specified, the layer does not end.
     */
    end?: string;
    /**
     * The ID of the schedule.
     */
    id: string;
    /**
     * The name of the schedule layer.
     */
    name: string;
    renderedCoveragePercentage: string;
    /**
     * A schedule layer restriction block. Restriction blocks documented below.
     */
    restrictions?: outputs.ScheduleLayerRestriction[];
    /**
     * The duration of each on-call shift in `seconds`.
     */
    rotationTurnLengthSeconds: number;
    /**
     * The effective start time of the schedule layer. This can be before the start time of the schedule.
     */
    rotationVirtualStart: string;
    /**
     * The start time of the schedule layer.
     */
    start: string;
    /**
     * The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
     */
    users: string[];
}

export interface ScheduleLayerRestriction {
    /**
     * The duration of the restriction in `seconds`.
     */
    durationSeconds: number;
    /**
     * Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
     */
    startDayOfWeek?: number;
    /**
     * The start time in `HH:mm:ss` format.
     */
    startTimeOfDay: string;
    /**
     * Can be `dailyRestriction` or `weeklyRestriction`.
     */
    type: string;
}

export interface ServiceAlertGroupingParameters {
    /**
     * Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
     */
    config: outputs.ServiceAlertGroupingParametersConfig;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: string;
}

export interface ServiceAlertGroupingParametersConfig {
    /**
     * One of `any` or `all`. This setting applies only when `type` is set to `contentBased`. Group alerts based on one or all of `fields` value(s).
     */
    aggregate?: string;
    /**
     * Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `contentBased`.
     */
    fields?: string[];
    /**
     * The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent` or `contentBased`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `contentBased` alert grouping). Any Alerts arriving greater than `timeWindow` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours.
     */
    timeWindow: number;
    /**
     * The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
     */
    timeout?: number;
}

export interface ServiceAutoPauseNotificationsParameters {
    /**
     * Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
     */
    enabled: boolean;
    /**
     * Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
     */
    timeout: number;
}

export interface ServiceCustomFieldFieldOption {
    /**
     * Must be `string`.
     */
    dataType: string;
    /**
     * The ID of the service custom field.
     */
    id: string;
    /**
     * The value of the option.
     */
    value: string;
}

export interface ServiceCustomFieldValueCustomField {
    /**
     * The ID of the custom field. Either `id` or `name` must be provided.
     */
    id: string;
    /**
     * The name of the custom field. Either `id` or `name` must be provided.
     */
    name: string;
    /**
     * The value to set for the custom field. Must be provided as a JSON-encoded string matching the field's data type. Use the `jsonencode()` function to ensure proper formatting.
     */
    value: string;
}

export interface ServiceDependencyDependency {
    /**
     * The service that dependents on the supporting service. Dependency dependent service documented below. One and only one `dependentService` dependency block must be defined.
     */
    dependentServices: outputs.ServiceDependencyDependencyDependentService[];
    /**
     * The service that supports the dependent service. Dependency supporting service documented below. One and only one `supportingService` dependency block must be defined.
     */
    supportingServices: outputs.ServiceDependencyDependencySupportingService[];
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: string;
}

export interface ServiceDependencyDependencyDependentService {
    /**
     * The ID of the service dependency.
     */
    id: string;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: string;
}

export interface ServiceDependencyDependencySupportingService {
    /**
     * The ID of the service dependency.
     */
    id: string;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: string;
}

export interface ServiceEventRuleActions {
    /**
     * Note added to the event.
     */
    annotates?: outputs.ServiceEventRuleActionsAnnotate[];
    /**
     * An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
     */
    eventActions?: outputs.ServiceEventRuleActionsEventAction[];
    /**
     * Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
     */
    extractions?: outputs.ServiceEventRuleActionsExtraction[];
    /**
     * The ID of the priority applied to the event.
     */
    priorities?: outputs.ServiceEventRuleActionsPriority[];
    /**
     * The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
     */
    severities?: outputs.ServiceEventRuleActionsSeverity[];
    /**
     * Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
     */
    suppresses?: outputs.ServiceEventRuleActionsSuppress[];
    /**
     * An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
     */
    suspends?: outputs.ServiceEventRuleActionsSuspend[];
}

export interface ServiceEventRuleActionsAnnotate {
    value?: string;
}

export interface ServiceEventRuleActionsEventAction {
    value?: string;
}

export interface ServiceEventRuleActionsExtraction {
    /**
     * The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
     *
     * *- **OR** -*
     */
    regex?: string;
    /**
     * Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    source?: string;
    /**
     * Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     *
     * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
     */
    target?: string;
    /**
     * A customized field message. This can also include variables extracted from the payload by using string interpolation.
     */
    template?: string;
}

export interface ServiceEventRuleActionsPriority {
    value?: string;
}

export interface ServiceEventRuleActionsSeverity {
    value?: string;
}

export interface ServiceEventRuleActionsSuppress {
    /**
     * The number value of the `thresholdTimeUnit` before an incident is created.
     */
    thresholdTimeAmount?: number;
    /**
     * The `seconds`,`minutes`, or `hours` the `thresholdTimeAmount` should be measured.
     */
    thresholdTimeUnit?: string;
    /**
     * The number of alerts that should be suppressed.
     */
    thresholdValue?: number;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: boolean;
}

export interface ServiceEventRuleActionsSuspend {
    value?: number;
}

export interface ServiceEventRuleConditions {
    /**
     * Operator to combine sub-conditions. Can be `and` or `or`.
     */
    operator?: string;
    /**
     * List of sub-conditions that define the condition.
     */
    subconditions?: outputs.ServiceEventRuleConditionsSubcondition[];
}

export interface ServiceEventRuleConditionsSubcondition {
    /**
     * Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
     */
    operator?: string;
    /**
     * Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    parameters?: outputs.ServiceEventRuleConditionsSubconditionParameter[];
}

export interface ServiceEventRuleConditionsSubconditionParameter {
    /**
     * Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
     */
    path?: string;
    value?: string;
}

export interface ServiceEventRuleTimeFrame {
    /**
     * Values for executing the rule during a specific time period.
     */
    activeBetweens?: outputs.ServiceEventRuleTimeFrameActiveBetween[];
    /**
     * Values for executing the rule on a recurring schedule.
     */
    scheduledWeeklies?: outputs.ServiceEventRuleTimeFrameScheduledWeekly[];
}

export interface ServiceEventRuleTimeFrameActiveBetween {
    /**
     * Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
     */
    endTime?: number;
    /**
     * Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
     */
    startTime?: number;
}

export interface ServiceEventRuleTimeFrameScheduledWeekly {
    /**
     * Length of time the schedule will be active.  Unix timestamp in milliseconds.
     */
    duration?: number;
    /**
     * Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `startTime` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `startTime` was `3,600,000` the it would be active starting at `01:00`.
     */
    startTime?: number;
    /**
     * Timezone for the given schedule.
     */
    timezone?: string;
    /**
     * An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
     */
    weekdays?: number[];
}

export interface ServiceEventRuleVariable {
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * The parameters for performing the operation to populate the variable.
     */
    parameters?: outputs.ServiceEventRuleVariableParameter[];
    /**
     * Type of operation to populate the variable. Usually `regex`.
     */
    type?: string;
}

export interface ServiceEventRuleVariableParameter {
    /**
     * Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
     */
    path?: string;
    value?: string;
}

export interface ServiceIncidentUrgencyRule {
    /**
     * Incidents' urgency during support hours.
     */
    duringSupportHours?: outputs.ServiceIncidentUrgencyRuleDuringSupportHours;
    /**
     * Incidents' urgency outside support hours.
     */
    outsideSupportHours?: outputs.ServiceIncidentUrgencyRuleOutsideSupportHours;
    /**
     * The type of incident urgency: `constant` or `useSupportHours` (when depending on specific support hours; see `supportHours`).
     */
    type: string;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: string;
}

export interface ServiceIncidentUrgencyRuleDuringSupportHours {
    /**
     * The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
     */
    type?: string;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: string;
}

export interface ServiceIncidentUrgencyRuleOutsideSupportHours {
    /**
     * The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
     */
    type?: string;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: string;
}

export interface ServiceIntegrationEmailFilter {
    /**
     * Can be `always`, `match` or `no-match`.
     */
    bodyMode?: string;
    /**
     * Should be a valid regex or `null`
     */
    bodyRegex?: string;
    /**
     * Can be `always`, `match` or `no-match`.
     */
    fromEmailMode?: string;
    /**
     * Should be a valid regex or `null`
     */
    fromEmailRegex?: string;
    /**
     * The ID of the service integration.
     */
    id: string;
    /**
     * Can be `always`, `match` or `no-match`.
     */
    subjectMode?: string;
    /**
     * Should be a valid regex or `null`
     */
    subjectRegex?: string;
}

export interface ServiceIntegrationEmailParser {
    /**
     * Can be `resolve` or `trigger`.
     */
    action: string;
    /**
     * The ID of the service integration.
     */
    id: number;
    matchPredicate: outputs.ServiceIntegrationEmailParserMatchPredicate;
    valueExtractors?: outputs.ServiceIntegrationEmailParserValueExtractor[];
}

export interface ServiceIntegrationEmailParserMatchPredicate {
    predicates?: outputs.ServiceIntegrationEmailParserMatchPredicatePredicate[];
    /**
     * Can be `any` or `all`.
     */
    type: string;
}

export interface ServiceIntegrationEmailParserMatchPredicatePredicate {
    /**
     * Predicate value or valid regex.
     */
    matcher?: string;
    /**
     * Can be `subject`, `body` or `fromAddresses`.
     */
    part?: string;
    predicates?: outputs.ServiceIntegrationEmailParserMatchPredicatePredicatePredicate[];
    /**
     * Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
     */
    type: string;
}

export interface ServiceIntegrationEmailParserMatchPredicatePredicatePredicate {
    /**
     * Predicate value or valid regex.
     */
    matcher: string;
    /**
     * Can be `subject`, `body` or `fromAddresses`.
     */
    part: string;
    /**
     * Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
     */
    type: string;
}

export interface ServiceIntegrationEmailParserValueExtractor {
    endsBefore?: string;
    /**
     * Can be `subject` or `body`.
     */
    part: string;
    /**
     * If `type` has value `regex` this value should contain valid regex.
     *
     * **Note:** You can use the `pagerduty.getVendor` data source to locate the appropriate vendor ID.
     */
    regex?: string;
    startsAfter?: string;
    /**
     * Can be `between`, `entire` or `regex`.
     */
    type: string;
    /**
     * First value extractor should have name `incidentKey` other value extractors should contain custom names.
     */
    valueName: string;
}

export interface ServiceScheduledAction {
    /**
     * A block representing when the scheduled action will occur.
     */
    ats?: outputs.ServiceScheduledActionAt[];
    /**
     * The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
     */
    toUrgency?: string;
    /**
     * The type of scheduled action. Currently, this must be set to `urgencyChange`.
     */
    type?: string;
}

export interface ServiceScheduledActionAt {
    /**
     * Designates either the start or the end of the scheduled action. Can be `supportHoursStart` or `supportHoursEnd`.
     *
     * Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `duringSupportHours` and to `low`  for `outsideSupportHours` in `incidentUrgencyRule`.
     *
     * Below is an example for a `pagerduty.Service` resource with `incidentUrgencyRules` with `type = "useSupportHours"`, `supportHours` and a default `scheduledAction` as well.
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as pagerduty from "@pulumi/pagerduty";
     *
     * const foo = new pagerduty.Service("foo", {
     *     name: "bar",
     *     description: "bar bar bar",
     *     autoResolveTimeout: "3600",
     *     acknowledgementTimeout: "3600",
     *     escalationPolicy: fooPagerdutyEscalationPolicy.id,
     *     incidentUrgencyRule: {
     *         type: "use_support_hours",
     *         duringSupportHours: {
     *             type: "constant",
     *             urgency: "high",
     *         },
     *         outsideSupportHours: {
     *             type: "constant",
     *             urgency: "low",
     *         },
     *     },
     *     supportHours: {
     *         type: "fixed_time_per_day",
     *         timeZone: "America/Lima",
     *         startTime: "09:00:00",
     *         endTime: "17:00:00",
     *         daysOfWeeks: [
     *             1,
     *             2,
     *             3,
     *             4,
     *             5,
     *         ],
     *     },
     *     scheduledActions: [{
     *         type: "urgency_change",
     *         toUrgency: "high",
     *         ats: [{
     *             type: "named_time",
     *             name: "support_hours_start",
     *         }],
     *     }],
     * });
     * ```
     */
    name?: string;
    /**
     * The type of time specification. Currently, this must be set to `namedTime`.
     */
    type?: string;
}

export interface ServiceSupportHours {
    /**
     * Array of days of week as integers. `1` to `7`, `1` being
     * Monday and `7` being Sunday.
     */
    daysOfWeeks?: number[];
    /**
     * The support hours' ending time of day.
     */
    endTime?: string;
    /**
     * The support hours' starting time of day.
     */
    startTime?: string;
    /**
     * The time zone for the support hours.
     */
    timeZone?: string;
    /**
     * The type of support hours. Can be `fixedTimePerDay`.
     */
    type?: string;
}

export interface SlackConnectionConfig {
    /**
     * A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
     * - `incident.acknowledged`
     * - `incident.escalated`
     * - `incident.resolved`
     * - `incident.reassigned`
     * - `incident.annotated`
     * - `incident.unacknowledged`
     * - `incident.delegated`
     * - `incident.priority_updated`
     * - `incident.responder.added`
     * - `incident.responder.replied`
     * - `incident.status_update_published`
     * - `incident.reopened`
     */
    events: string[];
    /**
     * Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through pagerduty.getPriority data source.
     * - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behavior is to set `priorities` to `No Priority` value.
     * - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
     */
    priorities?: string[];
    /**
     * Allows you to filter events by urgency. Either `high`, `low` or `null` for Any urgency. Default is `null`.
     */
    urgency?: string;
}

export interface UserHandoffNotificationRuleContactMethod {
    /**
     * The ID of the contact method.
     */
    id: string;
    /**
     * The type of the contact method. May be (`emailContactMethod`, `emailContactMethodReference`, `phoneContactMethod`, `phoneContactMethodReference`, `pushNotificationContactMethod`, `pushNotificationContactMethodReference`, `smsContactMethod`, `smsContactMethodReference`).
     */
    type: string;
}

export interface UserNotificationRuleContactMethod {
    /**
     * The id of the referenced contact method.
     */
    id: string;
    /**
     * The type of contact method. Can be `emailContactMethod`, `phoneContactMethod`, `pushNotificationContactMethod` or `smsContactMethod`.
     */
    type: string;
}

export interface WebhookSubscriptionDeliveryMethod {
    /**
     * The customHeader of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
     */
    customHeaders?: outputs.WebhookSubscriptionDeliveryMethodCustomHeader[];
    /**
     * Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
     */
    temporarilyDisabled: boolean;
    /**
     * Indicates the type of the delivery method. Allowed and default value: `httpDeliveryMethod`.
     */
    type?: string;
    /**
     * The destination URL for webhook delivery.
     */
    url?: string;
}

export interface WebhookSubscriptionDeliveryMethodCustomHeader {
    name: string;
    value: string;
}

export interface WebhookSubscriptionFilter {
    /**
     * The id of the object being used as the filter. This field is required for all filter types except account_reference.
     */
    id?: string;
    /**
     * The type of object being used as the filter. Allowed values are `accountReference`, `serviceReference`, and `teamReference`.
     */
    type: string;
}

export namespace config {
    export interface UseAppOauthScopedToken {
        pdClientId?: string;
        pdClientSecret?: string;
        pdSubdomain?: string;
    }

}
