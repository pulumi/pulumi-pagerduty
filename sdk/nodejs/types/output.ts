// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AutomationActionsActionActionDataReference {
    /**
     * The command to execute the script with.
     */
    invocationCommand?: string;
    /**
     * The arguments to pass to the Process Automation job execution.
     */
    processAutomationJobArguments?: string;
    /**
     * The ID of the Process Automation job to execute.
     */
    processAutomationJobId?: string;
    /**
     * The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
     */
    processAutomationNodeFilter?: string;
    /**
     * Body of the script to be executed on the Runner. Max length is 16777215 characters.
     */
    script?: string;
}

export interface EscalationPolicyRule {
    /**
     * The number of minutes before an unacknowledged incident escalates away from this rule.
     */
    escalationDelayInMinutes: number;
    /**
     * The strategy used to assign the escalation rule to an incident. Documented below.
     */
    escalationRuleAssignmentStrategy: outputs.EscalationPolicyRuleEscalationRuleAssignmentStrategy;
    /**
     * A target ID
     */
    id: string;
    targets: outputs.EscalationPolicyRuleTarget[];
}

export interface EscalationPolicyRuleEscalationRuleAssignmentStrategy {
    /**
     * Can be `roundRobin` or `assignToEveryone`.
     */
    type: string;
}

export interface EscalationPolicyRuleTarget {
    /**
     * A target ID
     */
    id: string;
    /**
     * Can be `userReference` or `scheduleReference`. Defaults to `userReference`. For multiple users as example, repeat the target.
     */
    type?: string;
}

export interface EventOrchestrationGlobalCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationGlobalCacheVariableConfiguration {
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source?: string;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount`
     */
    ttlSeconds?: number;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue` or `triggerEventCount`.
     */
    type: string;
}

export interface EventOrchestrationGlobalCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: outputs.EventOrchestrationGlobalCatchAllActions;
}

export interface EventOrchestrationGlobalCatchAllActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: string;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: outputs.EventOrchestrationGlobalCatchAllActionsAutomationAction;
    /**
     * When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
     */
    dropEvent?: boolean;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationGlobalCatchAllActionsExtraction[];
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: outputs.EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate[];
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: string;
    /**
     * The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: boolean;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: number;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationGlobalCatchAllActionsVariable[];
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: boolean;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: outputs.EventOrchestrationGlobalCatchAllActionsAutomationActionHeader[];
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: outputs.EventOrchestrationGlobalCatchAllActionsAutomationActionParameter[];
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: string;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationActionHeader {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalCatchAllActionsAutomationActionParameter {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: string;
    rules?: outputs.EventOrchestrationGlobalSetRule[];
}

export interface EventOrchestrationGlobalSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: outputs.EventOrchestrationGlobalSetRuleActions;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: outputs.EventOrchestrationGlobalSetRuleCondition[];
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: boolean;
    /**
     * The custom field id
     */
    id: string;
    /**
     * A description of this rule's purpose.
     */
    label?: string;
}

export interface EventOrchestrationGlobalSetRuleActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: string;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: outputs.EventOrchestrationGlobalSetRuleActionsAutomationAction;
    /**
     * When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
     */
    dropEvent?: boolean;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationGlobalSetRuleActionsExtraction[];
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: outputs.EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate[];
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: string;
    /**
     * The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: boolean;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: number;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationGlobalSetRuleActionsVariable[];
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: boolean;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: outputs.EventOrchestrationGlobalSetRuleActionsAutomationActionHeader[];
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: outputs.EventOrchestrationGlobalSetRuleActionsAutomationActionParameter[];
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: string;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationActionHeader {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalSetRuleActionsAutomationActionParameter {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationGlobalSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationIntegration {
    /**
     * ID of the integration
     */
    id: string;
    label: string;
    parameters: outputs.EventOrchestrationIntegrationParameter[];
}

export interface EventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type: string;
}

export interface EventOrchestrationRouterCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident.
     */
    actions: outputs.EventOrchestrationRouterCatchAllActions;
}

export interface EventOrchestrationRouterCatchAllActions {
    /**
     * The ID of the target Service for the resulting alert.
     */
    routeTo: string;
}

export interface EventOrchestrationRouterSet {
    /**
     * ID of the `start` set. Router supports only one set and it's id has to be `start`
     */
    id: string;
    rules?: outputs.EventOrchestrationRouterSetRule[];
}

export interface EventOrchestrationRouterSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: outputs.EventOrchestrationRouterSetRuleActions;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
     */
    conditions?: outputs.EventOrchestrationRouterSetRuleCondition[];
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: boolean;
    /**
     * ID of the `start` set. Router supports only one set and it's id has to be `start`
     */
    id: string;
    /**
     * A description of this rule's purpose.
     */
    label?: string;
}

export interface EventOrchestrationRouterSetRuleActions {
    /**
     * The ID of the target Service for the resulting alert.
     */
    routeTo: string;
}

export interface EventOrchestrationRouterSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationServiceCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationServiceCacheVariableConfiguration {
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source?: string;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount`
     */
    ttlSeconds?: number;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue` or `triggerEventCount`.
     */
    type: string;
}

export interface EventOrchestrationServiceCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: outputs.EventOrchestrationServiceCatchAllActions;
}

export interface EventOrchestrationServiceCatchAllActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: string;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: outputs.EventOrchestrationServiceCatchAllActionsAutomationAction;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationServiceCatchAllActionsExtraction[];
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: outputs.EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate[];
    /**
     * Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
     */
    pagerdutyAutomationAction?: outputs.EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction;
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: string;
    /**
     * The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: boolean;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: number;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationServiceCatchAllActionsVariable[];
}

export interface EventOrchestrationServiceCatchAllActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: boolean;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: outputs.EventOrchestrationServiceCatchAllActionsAutomationActionHeader[];
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: outputs.EventOrchestrationServiceCatchAllActionsAutomationActionParameter[];
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: string;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationActionHeader {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceCatchAllActionsAutomationActionParameter {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction {
    /**
     * Id of the Process Automation action to be triggered.
     */
    actionId: string;
}

export interface EventOrchestrationServiceCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: string;
    rules?: outputs.EventOrchestrationServiceSetRule[];
}

export interface EventOrchestrationServiceSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: outputs.EventOrchestrationServiceSetRuleActions;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: outputs.EventOrchestrationServiceSetRuleCondition[];
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: boolean;
    /**
     * The custom field id
     */
    id: string;
    /**
     * A description of this rule's purpose.
     */
    label?: string;
}

export interface EventOrchestrationServiceSetRuleActions {
    /**
     * Add this text as a note on the resulting incident.
     */
    annotate?: string;
    /**
     * Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
     */
    automationAction?: outputs.EventOrchestrationServiceSetRuleActionsAutomationAction;
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationServiceSetRuleActionsExtraction[];
    /**
     * Assign a custom field to the resulting incident.
     */
    incidentCustomFieldUpdates?: outputs.EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate[];
    /**
     * Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
     */
    pagerdutyAutomationAction?: outputs.EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction;
    /**
     * The ID of the priority you want to set on resulting incident. Consider using the `pagerduty.getPriority` data source.
     */
    priority?: string;
    /**
     * The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
     */
    suppress?: boolean;
    /**
     * The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
     */
    suspend?: number;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationServiceSetRuleActionsVariable[];
}

export interface EventOrchestrationServiceSetRuleActionsAutomationAction {
    /**
     * When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
     */
    autoSend?: boolean;
    /**
     * Specify custom key/value pairs that'll be sent with the webhook request as request headers.
     */
    headers?: outputs.EventOrchestrationServiceSetRuleActionsAutomationActionHeader[];
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
     */
    parameters?: outputs.EventOrchestrationServiceSetRuleActionsAutomationActionParameter[];
    /**
     * The API endpoint where PagerDuty's servers will send the webhook request.
     */
    url: string;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationActionHeader {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceSetRuleActionsAutomationActionParameter {
    /**
     * Name to identify the parameter
     */
    key: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate {
    /**
     * The custom field id
     */
    id: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction {
    /**
     * Id of the Process Automation action to be triggered.
     */
    actionId: string;
}

export interface EventOrchestrationServiceSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationServiceSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface EventOrchestrationUnroutedCatchAll {
    /**
     * These are the actions that will be taken to change the resulting alert and incident. `catchAll` supports all actions described above for `rule` _except_ `routeTo` action.
     */
    actions: outputs.EventOrchestrationUnroutedCatchAllActions;
}

export interface EventOrchestrationUnroutedCatchAllActions {
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationUnroutedCatchAllActionsExtraction[];
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    suppress: boolean;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationUnroutedCatchAllActionsVariable[];
}

export interface EventOrchestrationUnroutedCatchAllActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationUnroutedCatchAllActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationUnroutedSet {
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: string;
    rules?: outputs.EventOrchestrationUnroutedSetRule[];
}

export interface EventOrchestrationUnroutedSetRule {
    /**
     * Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
     */
    actions: outputs.EventOrchestrationUnroutedSetRuleActions;
    /**
     * Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
     */
    conditions?: outputs.EventOrchestrationUnroutedSetRuleCondition[];
    /**
     * Indicates whether the rule is disabled and would therefore not be evaluated.
     */
    disabled?: boolean;
    /**
     * The ID of this set of rules. Rules in other sets can route events into this set using the rule's `routeTo` property.
     */
    id: string;
    /**
     * A description of this rule's purpose.
     */
    label?: string;
}

export interface EventOrchestrationUnroutedSetRuleActions {
    /**
     * sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
     */
    eventAction?: string;
    /**
     * Replace any CEF field or Custom Details object field using custom variables.
     */
    extractions?: outputs.EventOrchestrationUnroutedSetRuleActionsExtraction[];
    /**
     * The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
     */
    routeTo?: string;
    /**
     * sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
     */
    severity?: string;
    /**
     * Populate variables from event payloads and use those variables in other event actions.
     */
    variables?: outputs.EventOrchestrationUnroutedSetRuleActionsVariable[];
}

export interface EventOrchestrationUnroutedSetRuleActionsExtraction {
    /**
     * A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
     */
    regex?: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
     */
    source?: string;
    /**
     * The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
     */
    target: string;
    /**
     * A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
     * * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
     * * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
     */
    template?: string;
}

export interface EventOrchestrationUnroutedSetRuleActionsVariable {
    /**
     * The name of the variable
     */
    name: string;
    /**
     * Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
     */
    path: string;
    /**
     * Only `regex` is supported
     */
    type: string;
    /**
     * The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
     */
    value: string;
}

export interface EventOrchestrationUnroutedSetRuleCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface GetAutomationActionsActionActionDataReference {
    /**
     * (Optional) The command to execute the script with.
     */
    invocationCommand: string;
    /**
     * (Optional) The arguments to pass to the Process Automation job execution.
     */
    processAutomationJobArguments: string;
    /**
     * (Required for `processAutomation` action_type) The ID of the Process Automation job to execute.
     */
    processAutomationJobId: string;
    /**
     * (Optional) The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
     */
    processAutomationNodeFilter: string;
    /**
     * (Required for `script` action_type) Body of the script to be executed on the Runner. Max length is 16777215 characters.
     */
    script: string;
}

export interface GetEventOrchestrationGlobalCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface GetEventOrchestrationGlobalCacheVariableConfiguration {
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source: string;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount`
     */
    ttlSeconds: number;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue` or `triggerEventCount`.
     */
    type: string;
}

export interface GetEventOrchestrationIntegrationDetail {
    /**
     * ID of the integration
     */
    id: string;
    label: string;
    parameters: outputs.GetEventOrchestrationIntegrationDetailParameter[];
}

export interface GetEventOrchestrationIntegrationDetailParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type: string;
}

export interface GetEventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type: string;
}

export interface GetEventOrchestrationServiceCacheVariableCondition {
    /**
     * A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
     */
    expression: string;
}

export interface GetEventOrchestrationServiceCacheVariableConfiguration {
    /**
     * A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recentValue`
     */
    regex: string;
    /**
     * The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recentValue`
     */
    source: string;
    /**
     * The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `triggerEventCount`
     */
    ttlSeconds: number;
    /**
     * The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recentValue` or `triggerEventCount`.
     */
    type: string;
}

export interface GetEventOrchestrationsEventOrchestration {
    /**
     * ID of the integration
     */
    id: string;
    /**
     * An integration for the Event Orchestration.
     */
    integrations: outputs.GetEventOrchestrationsEventOrchestrationIntegration[];
    /**
     * The name of the found Event Orchestration.
     */
    name: string;
}

export interface GetEventOrchestrationsEventOrchestrationIntegration {
    /**
     * ID of the integration
     */
    id: string;
    label: string;
    parameters: outputs.GetEventOrchestrationsEventOrchestrationIntegrationParameter[];
}

export interface GetEventOrchestrationsEventOrchestrationIntegrationParameter {
    /**
     * Routing key that routes to this Orchestration.
     */
    routingKey: string;
    /**
     * Type of the routing key. `global` is the default type.
     */
    type: string;
}

export interface GetLicensesLicense {
    /**
     * Available allocations to assign to users
     */
    allocationsAvailable: number;
    /**
     * The number of allocations already assigned to users
     */
    currentValue: number;
    /**
     * Description of the license
     */
    description: string;
    htmlUrl: string;
    /**
     * Allows to override the default behavior for setting the `id` attribute that is required for data sources.
     */
    id: string;
    /**
     * Name of the license
     */
    name: string;
    /**
     * The role group for the license that determines the available `validRoles`
     */
    roleGroup: string;
    self: string;
    /**
     * Summary of the license
     */
    summary: string;
    type: string;
    /**
     * List of allowed roles that may be assigned to a user with this license
     */
    validRoles: string[];
}

export interface GetServiceTeam {
    /**
     * The ID of the found service.
     */
    id: string;
    /**
     * The service name to use to find a service in the PagerDuty API.
     */
    name: string;
}

export interface GetStandardsResourceScoresScore {
    /**
     * Number of standards this resource successfully complies to.
     */
    passing: number;
    /**
     * Number of standards associated to this resource.
     */
    total: number;
}

export interface GetStandardsResourceScoresStandard {
    /**
     * Indicates whether the standard is currently active and applicable to the resource.
     */
    active: boolean;
    /**
     * Provides a textual description of the standard.
     */
    description: string;
    /**
     * Identifier of said resource.
     */
    id: string;
    /**
     * The human-readable name of the standard.
     */
    name: string;
    /**
     * Indicates whether the resource complies to this standard.
     */
    pass: boolean;
    /**
     * The type of the standard.
     */
    type: string;
}

export interface GetStandardsResourcesScoresResource {
    /**
     * Unique Identifier.
     */
    resourceId: string;
    /**
     * Type of the object the standards are associated to. Allowed values are `technicalServices`.
     */
    resourceType: string;
    /**
     * Summary of the scores for standards associated with this resource.
     */
    score: outputs.GetStandardsResourcesScoresResourceScore;
    /**
     * The list of standards evaluated against.
     */
    standards: outputs.GetStandardsResourcesScoresResourceStandard[];
}

export interface GetStandardsResourcesScoresResourceScore {
    /**
     * Number of standards this resource successfully complies to.
     */
    passing: number;
    /**
     * Number of standards associated to this resource.
     */
    total: number;
}

export interface GetStandardsResourcesScoresResourceStandard {
    /**
     * Indicates whether the standard is currently active and applicable to the resource.
     */
    active: boolean;
    /**
     * Provides a textual description of the standard.
     */
    description: string;
    /**
     * A unique identifier for the standard.
     */
    id: string;
    /**
     * The human-readable name of the standard.
     */
    name: string;
    /**
     * Indicates whether the resource complies to this standard.
     */
    pass: boolean;
    /**
     * The type of the standard.
     */
    type: string;
}

export interface GetStandardsStandard {
    /**
     * Indicates whether the standard is currently active and applicable to the resource.
     */
    active: boolean;
    /**
     * Provides a textual description of the standard.
     */
    description: string;
    /**
     * A list of exceptions for the application of this standard.
     */
    exclusions: outputs.GetStandardsStandardExclusion[];
    /**
     * The unique identifier for the resource being included.
     */
    id: string;
    /**
     * A list of explict instances this standard applies to.
     */
    inclusions: outputs.GetStandardsStandardInclusion[];
    /**
     * The human-readable name of the standard.
     */
    name: string;
    /**
     * Filter by `resourceType` the received standards. Allowed values are `technicalService`.
     */
    resourceType: string;
    /**
     * Specifies the type of resource this inclusion applies to.
     */
    type: string;
}

export interface GetStandardsStandardExclusion {
    /**
     * The unique identifier for the resource being included.
     */
    id: string;
    /**
     * Specifies the type of resource this inclusion applies to.
     */
    type: string;
}

export interface GetStandardsStandardInclusion {
    /**
     * The unique identifier for the resource being included.
     */
    id: string;
    /**
     * Specifies the type of resource this inclusion applies to.
     */
    type: string;
}

export interface GetTeamMembersMember {
    /**
     * The ID of the found user.
     */
    id: string;
    /**
     * The team role of the found user.
     */
    role: string;
    /**
     * A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to name, though it is not intended to be an identifier.
     */
    summary: string;
    /**
     * The type of object. The value returned will be `userReference`. Can be used for passing to another object as dependency.
     */
    type: string;
}

export interface GetUsersUser {
    /**
     * The human-friendly description of the found user.
     */
    description: string;
    /**
     * The email of the found user.
     */
    email: string;
    /**
     * The ID of the found user.
     */
    id: string;
    /**
     * The job title of the found user.
     */
    jobTitle: string;
    /**
     * The short name of the found user.
     */
    name: string;
    /**
     * The role of the found user.
     */
    role: string;
    /**
     * The timezone of the found user.
     */
    timeZone: string;
    type: string;
}

export interface IncidentWorkflowStep {
    /**
     * The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
     */
    action: string;
    /**
     * The ID of the incident workflow.
     */
    id: string;
    /**
     * The list of inputs that contain a series of inline steps for the workflow action.
     */
    inlineStepsInputs?: outputs.IncidentWorkflowStepInlineStepsInput[];
    /**
     * The list of standard inputs for the workflow action.
     */
    inputs: outputs.IncidentWorkflowStepInput[];
    /**
     * The name of the workflow step.
     */
    name: string;
}

export interface IncidentWorkflowStepInlineStepsInput {
    /**
     * The name of the input.
     */
    name: string;
    /**
     * The inline steps of the input. An inline step adheres to the step schema described above.
     */
    steps: outputs.IncidentWorkflowStepInlineStepsInputStep[];
}

export interface IncidentWorkflowStepInlineStepsInputStep {
    /**
     * The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
     */
    action: string;
    /**
     * The list of standard inputs for the workflow action.
     */
    inputs: outputs.IncidentWorkflowStepInlineStepsInputStepInput[];
    /**
     * The name of the workflow step.
     */
    name: string;
}

export interface IncidentWorkflowStepInlineStepsInputStepInput {
    generated: boolean;
    /**
     * The name of the input.
     */
    name: string;
    /**
     * The value of the input.
     */
    value: string;
}

export interface IncidentWorkflowStepInput {
    generated: boolean;
    /**
     * The name of the input.
     */
    name: string;
    /**
     * The value of the input.
     */
    value: string;
}

export interface ResponsePlayResponder {
    /**
     * Description of escalation policy
     */
    description?: string;
    /**
     * The escalation rules
     */
    escalationRules: outputs.ResponsePlayResponderEscalationRule[];
    /**
     * ID of the user defined as the responder
     */
    id?: string;
    /**
     * Name of the escalation policy
     */
    name?: string;
    /**
     * The number of times the escalation policy will repeat after reaching the end of its escalation.
     */
    numLoops: number;
    /**
     * Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "ifHasServices". Could be "ifHasServices", "always
     */
    onCallHandoffNotifications: string;
    /**
     * There can be multiple services associated with a policy.
     */
    services: outputs.ResponsePlayResponderService[];
    /**
     * Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
     */
    teams: outputs.ResponsePlayResponderTeam[];
    /**
     * Type of object of the target. Supported types are `userReference`, `scheduleReference`.
     */
    type?: string;
}

export interface ResponsePlayResponderEscalationRule {
    /**
     * The number of minutes before an unacknowledged incident escalates away from this rule.
     */
    escalationDelayInMinutes: number;
    /**
     * ID of the user defined as the responder
     */
    id: string;
    /**
     * The targets an incident should be assigned to upon reaching this rule.
     */
    targets: outputs.ResponsePlayResponderEscalationRuleTarget[];
}

export interface ResponsePlayResponderEscalationRuleTarget {
    /**
     * ID of the user defined as the responder
     */
    id: string;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type: string;
}

export interface ResponsePlayResponderService {
    /**
     * ID of the user defined as the responder
     */
    id: string;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type: string;
}

export interface ResponsePlayResponderTeam {
    /**
     * ID of the user defined as the responder
     */
    id: string;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type: string;
}

export interface ResponsePlaySubscriber {
    /**
     * ID of the user defined as the responder
     */
    id?: string;
    /**
     * A string that determines the schema of the object. If not set, the default value is "responsePlay".
     */
    type?: string;
}

export interface RulesetRuleActions {
    /**
     * Note added to the event.
     */
    annotates?: outputs.RulesetRuleActionsAnnotate[];
    /**
     * An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
     */
    eventActions?: outputs.RulesetRuleActionsEventAction[];
    /**
     * Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
     */
    extractions?: outputs.RulesetRuleActionsExtraction[];
    /**
     * The ID of the priority applied to the event.
     */
    priorities?: outputs.RulesetRuleActionsPriority[];
    /**
     * The ID of the service where the event will be routed.
     */
    routes?: outputs.RulesetRuleActionsRoute[];
    /**
     * The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
     */
    severities?: outputs.RulesetRuleActionsSeverity[];
    /**
     * Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
     */
    suppresses?: outputs.RulesetRuleActionsSuppress[];
    /**
     * An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
     */
    suspends?: outputs.RulesetRuleActionsSuspend[];
}

export interface RulesetRuleActionsAnnotate {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsEventAction {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsExtraction {
    /**
     * The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
     *
     * *- **OR** -*
     */
    regex?: string;
    /**
     * Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    source?: string;
    /**
     * Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     *
     * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
     */
    target?: string;
    /**
     * A customized field message. This can also include variables extracted from the payload by using string interpolation.
     */
    template?: string;
}

export interface RulesetRuleActionsPriority {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsRoute {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsSeverity {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleActionsSuppress {
    /**
     * The number value of the `thresholdTimeUnit` before an incident is created. Must be greater than 0.
     */
    thresholdTimeAmount?: number;
    /**
     * The `seconds`,`minutes`, or `hours` the `thresholdTimeAmount` should be measured.
     */
    thresholdTimeUnit?: string;
    /**
     * The number of alerts that should be suppressed. Must be greater than 0.
     */
    thresholdValue?: number;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: boolean;
}

export interface RulesetRuleActionsSuspend {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: number;
}

export interface RulesetRuleConditions {
    /**
     * Operator to combine sub-conditions. Can be `and` or `or`.
     */
    operator?: string;
    /**
     * List of sub-conditions that define the condition.
     */
    subconditions?: outputs.RulesetRuleConditionsSubcondition[];
}

export interface RulesetRuleConditionsSubcondition {
    /**
     * Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
     */
    operator?: string;
    /**
     * Parameter for the sub-condition. It requires both a `path` and `value` to be set.
     */
    parameters?: outputs.RulesetRuleConditionsSubconditionParameter[];
}

export interface RulesetRuleConditionsSubconditionParameter {
    path?: string;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetRuleTimeFrame {
    /**
     * Values for executing the rule during a specific time period.
     */
    activeBetweens?: outputs.RulesetRuleTimeFrameActiveBetween[];
    /**
     * Values for executing the rule on a recurring schedule.
     */
    scheduledWeeklies?: outputs.RulesetRuleTimeFrameScheduledWeekly[];
}

export interface RulesetRuleTimeFrameActiveBetween {
    endTime?: number;
    /**
     * A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `timeStatic` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
     */
    startTime?: number;
}

export interface RulesetRuleTimeFrameScheduledWeekly {
    /**
     * Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `startTime`.
     */
    duration?: number;
    /**
     * A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `timeStatic` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
     */
    startTime?: number;
    /**
     * [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
     */
    timezone?: string;
    /**
     * An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
     */
    weekdays?: number[];
}

export interface RulesetRuleVariable {
    name?: string;
    parameters?: outputs.RulesetRuleVariableParameter[];
    type?: string;
}

export interface RulesetRuleVariableParameter {
    path?: string;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface RulesetTeam {
    /**
     * The ID of the ruleset.
     */
    id: string;
}

export interface ScheduleFinalSchedule {
    /**
     * The name of the schedule.
     */
    name: string;
    renderedCoveragePercentage: string;
}

export interface ScheduleLayer {
    /**
     * The end time of the schedule layer. If not specified, the layer does not end.
     */
    end?: string;
    /**
     * The ID of the schedule.
     */
    id: string;
    /**
     * The name of the schedule layer.
     */
    name: string;
    renderedCoveragePercentage: string;
    /**
     * A schedule layer restriction block. Restriction blocks documented below.
     */
    restrictions?: outputs.ScheduleLayerRestriction[];
    /**
     * The duration of each on-call shift in `seconds`.
     */
    rotationTurnLengthSeconds: number;
    /**
     * The effective start time of the schedule layer. This can be before the start time of the schedule.
     */
    rotationVirtualStart: string;
    /**
     * The start time of the schedule layer.
     */
    start: string;
    /**
     * The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
     */
    users: string[];
}

export interface ScheduleLayerRestriction {
    /**
     * The duration of the restriction in `seconds`.
     */
    durationSeconds: number;
    /**
     * Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
     */
    startDayOfWeek?: number;
    /**
     * The start time in `HH:mm:ss` format.
     */
    startTimeOfDay: string;
    /**
     * Can be `dailyRestriction` or `weeklyRestriction`.
     */
    type: string;
}

export interface ServiceAlertGroupingParameters {
    /**
     * Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
     */
    config: outputs.ServiceAlertGroupingParametersConfig;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: string;
}

export interface ServiceAlertGroupingParametersConfig {
    /**
     * One of `any` or `all`. This setting applies only when `type` is set to `contentBased`. Group alerts based on one or all of `fields` value(s).
     */
    aggregate?: string;
    /**
     * Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `contentBased`.
     */
    fields?: string[];
    /**
     * The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent` or `contentBased`. Value must be between `300` and `3600`. Any Alerts arriving greater than `timeWindow` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours.
     */
    timeWindow: number;
    /**
     * The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
     */
    timeout?: number;
}

export interface ServiceAutoPauseNotificationsParameters {
    /**
     * Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
     */
    enabled: boolean;
    /**
     * Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
     *
     *
     * You may specify one optional `incidentUrgencyRule` block configuring what urgencies to use.
     * Your PagerDuty account must have the `urgencies` ability to assign an incident urgency rule.
     * The block contains the following arguments:
     */
    timeout: number;
}

export interface ServiceDependencyDependency {
    /**
     * The service that dependents on the supporting service. Dependency dependent service documented below.
     */
    dependentServices: outputs.ServiceDependencyDependencyDependentService[];
    /**
     * The service that supports the dependent service. Dependency supporting service documented below.
     */
    supportingServices: outputs.ServiceDependencyDependencySupportingService[];
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type?: string;
}

export interface ServiceDependencyDependencyDependentService {
    /**
     * The ID of the service dependency.
     */
    id: string;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: string;
}

export interface ServiceDependencyDependencySupportingService {
    /**
     * The ID of the service dependency.
     */
    id: string;
    /**
     * Can be `businessService`,  `service`, `businessServiceReference` or `technicalServiceReference`.
     */
    type: string;
}

export interface ServiceEventRuleActions {
    /**
     * Note added to the event.
     */
    annotates?: outputs.ServiceEventRuleActionsAnnotate[];
    /**
     * An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
     */
    eventActions?: outputs.ServiceEventRuleActionsEventAction[];
    /**
     * Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
     */
    extractions?: outputs.ServiceEventRuleActionsExtraction[];
    /**
     * The ID of the priority applied to the event.
     */
    priorities?: outputs.ServiceEventRuleActionsPriority[];
    /**
     * The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
     */
    severities?: outputs.ServiceEventRuleActionsSeverity[];
    /**
     * Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
     */
    suppresses?: outputs.ServiceEventRuleActionsSuppress[];
    /**
     * An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
     */
    suspends?: outputs.ServiceEventRuleActionsSuspend[];
}

export interface ServiceEventRuleActionsAnnotate {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface ServiceEventRuleActionsEventAction {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface ServiceEventRuleActionsExtraction {
    /**
     * The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
     *
     * *- **OR** -*
     */
    regex?: string;
    /**
     * Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    source?: string;
    /**
     * Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     *
     * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
     */
    target?: string;
    /**
     * A customized field message. This can also include variables extracted from the payload by using string interpolation.
     */
    template?: string;
}

export interface ServiceEventRuleActionsPriority {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface ServiceEventRuleActionsSeverity {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface ServiceEventRuleActionsSuppress {
    /**
     * The number value of the `thresholdTimeUnit` before an incident is created.
     */
    thresholdTimeAmount?: number;
    /**
     * The `seconds`,`minutes`, or `hours` the `thresholdTimeAmount` should be measured.
     */
    thresholdTimeUnit?: string;
    /**
     * The number of alerts that should be suppressed.
     */
    thresholdValue?: number;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: boolean;
}

export interface ServiceEventRuleActionsSuspend {
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: number;
}

export interface ServiceEventRuleConditions {
    /**
     * Operator to combine sub-conditions. Can be `and` or `or`.
     */
    operator?: string;
    /**
     * List of sub-conditions that define the condition.
     */
    subconditions?: outputs.ServiceEventRuleConditionsSubcondition[];
}

export interface ServiceEventRuleConditionsSubcondition {
    /**
     * Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
     */
    operator?: string;
    /**
     * Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
     */
    parameters?: outputs.ServiceEventRuleConditionsSubconditionParameter[];
}

export interface ServiceEventRuleConditionsSubconditionParameter {
    /**
     * Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
     */
    path?: string;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface ServiceEventRuleTimeFrame {
    /**
     * Values for executing the rule during a specific time period.
     */
    activeBetweens?: outputs.ServiceEventRuleTimeFrameActiveBetween[];
    /**
     * Values for executing the rule on a recurring schedule.
     */
    scheduledWeeklies?: outputs.ServiceEventRuleTimeFrameScheduledWeekly[];
}

export interface ServiceEventRuleTimeFrameActiveBetween {
    /**
     * Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
     */
    endTime?: number;
    /**
     * Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
     */
    startTime?: number;
}

export interface ServiceEventRuleTimeFrameScheduledWeekly {
    /**
     * Length of time the schedule will be active.  Unix timestamp in milliseconds.
     */
    duration?: number;
    /**
     * Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
     */
    startTime?: number;
    /**
     * Timezone for the given schedule.
     */
    timezone?: string;
    /**
     * An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
     */
    weekdays?: number[];
}

export interface ServiceEventRuleVariable {
    /**
     * The name of the variable.
     */
    name?: string;
    /**
     * The parameters for performing the operation to populate the variable.
     */
    parameters?: outputs.ServiceEventRuleVariableParameter[];
    /**
     * Type of operation to populate the variable. Usually `regex`.
     */
    type?: string;
}

export interface ServiceEventRuleVariableParameter {
    /**
     * Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
     */
    path?: string;
    /**
     * Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
     */
    value?: string;
}

export interface ServiceIncidentUrgencyRule {
    /**
     * Incidents' urgency during support hours.
     */
    duringSupportHours?: outputs.ServiceIncidentUrgencyRuleDuringSupportHours;
    /**
     * Incidents' urgency outside support hours.
     *
     * When using `type = "useSupportHours"` in `incidentUrgencyRule` you must specify exactly one (otherwise optional) `supportHours` block.
     * Your PagerDuty account must have the `serviceSupportHours` ability to assign support hours.
     * The block contains the following arguments:
     */
    outsideSupportHours?: outputs.ServiceIncidentUrgencyRuleOutsideSupportHours;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type: string;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: string;
}

export interface ServiceIncidentUrgencyRuleDuringSupportHours {
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: string;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: string;
}

export interface ServiceIncidentUrgencyRuleOutsideSupportHours {
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: string;
    /**
     * The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severityBased` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
     */
    urgency?: string;
}

export interface ServiceIntegrationEmailFilter {
    /**
     * Can be `always` or `match`.
     */
    bodyMode?: string;
    /**
     * Should be a valid regex or `null`
     */
    bodyRegex?: string;
    /**
     * Can be `always` or `match`.
     */
    fromEmailMode?: string;
    /**
     * Should be a valid regex or `null`
     */
    fromEmailRegex?: string;
    /**
     * The ID of the service integration.
     */
    id: string;
    /**
     * Can be `always` or `match`.
     */
    subjectMode?: string;
    /**
     * Should be a valid regex or `null`
     */
    subjectRegex?: string;
}

export interface ServiceIntegrationEmailParser {
    /**
     * Can be `resolve` or `trigger`.
     */
    action: string;
    /**
     * The ID of the service integration.
     */
    id: number;
    matchPredicate: outputs.ServiceIntegrationEmailParserMatchPredicate;
    valueExtractors?: outputs.ServiceIntegrationEmailParserValueExtractor[];
}

export interface ServiceIntegrationEmailParserMatchPredicate {
    predicates?: outputs.ServiceIntegrationEmailParserMatchPredicatePredicate[];
    /**
     * Can be `any` or `all`.
     */
    type: string;
}

export interface ServiceIntegrationEmailParserMatchPredicatePredicate {
    /**
     * Predicate value or valid regex.
     */
    matcher?: string;
    /**
     * Can be `subject`, `body` or `fromAddresses`.
     */
    part?: string;
    predicates?: outputs.ServiceIntegrationEmailParserMatchPredicatePredicatePredicate[];
    /**
     * Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
     */
    type: string;
}

export interface ServiceIntegrationEmailParserMatchPredicatePredicatePredicate {
    /**
     * Predicate value or valid regex.
     */
    matcher: string;
    /**
     * Can be `subject`, `body` or `fromAddresses`.
     */
    part: string;
    /**
     * Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
     */
    type: string;
}

export interface ServiceIntegrationEmailParserValueExtractor {
    endsBefore?: string;
    /**
     * Can be `subject` or `body`.
     */
    part: string;
    /**
     * If `type` has value `regex` this value should contain valid regex.
     *
     * **Note:** You can use the `pagerduty.getVendor` data source to locate the appropriate vendor ID.
     */
    regex?: string;
    startsAfter?: string;
    /**
     * Can be `between`, `entire` or `regex`.
     */
    type: string;
    /**
     * First value extractor should have name `incidentKey` other value extractors should contain custom names.
     */
    valueName: string;
}

export interface ServiceScheduledAction {
    /**
     * A block representing when the scheduled action will occur.
     */
    ats?: outputs.ServiceScheduledActionAt[];
    /**
     * The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
     */
    toUrgency?: string;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: string;
}

export interface ServiceScheduledActionAt {
    /**
     * Designates either the start or the end of the scheduled action. Can be `supportHoursStart` or `supportHoursEnd`.
     *
     * Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `duringSupportHours` and to `low`  for `outsideSupportHours` in `incidentUrgencyRule`.
     *
     * Below is an example for a `pagerduty.Service` resource with `incidentUrgencyRules` with `type = "useSupportHours"`, `supportHours` and a default `scheduledAction` as well.
     *
     * ```typescript
     * import * as pulumi from "@pulumi/pulumi";
     * import * as pagerduty from "@pulumi/pagerduty";
     *
     * const foo = new pagerduty.Service("foo", {
     *     name: "bar",
     *     description: "bar bar bar",
     *     autoResolveTimeout: "3600",
     *     acknowledgementTimeout: "3600",
     *     escalationPolicy: fooPagerdutyEscalationPolicy.id,
     *     incidentUrgencyRule: {
     *         type: "use_support_hours",
     *         duringSupportHours: {
     *             type: "constant",
     *             urgency: "high",
     *         },
     *         outsideSupportHours: {
     *             type: "constant",
     *             urgency: "low",
     *         },
     *     },
     *     supportHours: {
     *         type: "fixed_time_per_day",
     *         timeZone: "America/Lima",
     *         startTime: "09:00:00",
     *         endTime: "17:00:00",
     *         daysOfWeeks: [
     *             1,
     *             2,
     *             3,
     *             4,
     *             5,
     *         ],
     *     },
     *     scheduledActions: [{
     *         type: "urgency_change",
     *         toUrgency: "high",
     *         ats: [{
     *             type: "named_time",
     *             name: "support_hours_start",
     *         }],
     *     }],
     * });
     * ```
     */
    name?: string;
    /**
     * The type of time specification. Currently, this must be set to `namedTime`.
     */
    type?: string;
}

export interface ServiceSupportHours {
    /**
     * Array of days of week as integers. `1` to `7`, `1` being
     * Monday and `7` being Sunday.
     */
    daysOfWeeks?: number[];
    /**
     * The support hours' ending time of day.
     *
     * A `scheduledActions` block is required when using `type = "useSupportHours"` in `incidentUrgencyRule`.
     *
     * The block contains the following arguments:
     */
    endTime?: string;
    /**
     * The support hours' starting time of day.
     */
    startTime?: string;
    /**
     * The time zone for the support hours.
     */
    timeZone?: string;
    /**
     * The type of alert grouping; one of `intelligent`, `time` or `contentBased`.
     */
    type?: string;
}

export interface SlackConnectionConfig {
    /**
     * A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
     * - `incident.acknowledged`
     * - `incident.escalated`
     * - `incident.resolved`
     * - `incident.reassigned`
     * - `incident.annotated`
     * - `incident.unacknowledged`
     * - `incident.delegated`
     * - `incident.priority_updated`
     * - `incident.responder.added`
     * - `incident.responder.replied`
     * - `incident.status_update_published`
     * - `incident.reopened`
     */
    events: string[];
    /**
     * Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through pagerduty.getPriority data source.
     * - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behaviour is to set `priorities` to `No Priority` value.
     * - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
     */
    priorities?: string[];
    /**
     * Allows you to filter events by urgency. Either `high` or `low`.
     */
    urgency?: string;
}

export interface WebhookSubscriptionDeliveryMethod {
    /**
     * The customHeader of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
     */
    customHeaders?: outputs.WebhookSubscriptionDeliveryMethodCustomHeader[];
    /**
     * Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
     */
    temporarilyDisabled: boolean;
    /**
     * Indicates the type of the delivery method. Allowed and default value: `httpDeliveryMethod`.
     */
    type?: string;
    /**
     * The destination URL for webhook delivery.
     */
    url?: string;
}

export interface WebhookSubscriptionDeliveryMethodCustomHeader {
    name: string;
    value: string;
}

export interface WebhookSubscriptionFilter {
    /**
     * The id of the object being used as the filter. This field is required for all filter types except account_reference.
     */
    id?: string;
    /**
     * The type of object being used as the filter. Allowed values are `accountReference`, `serviceReference`, and `teamReference`.
     */
    type: string;
}

export namespace config {
    export interface UseAppOauthScopedToken {
        pdClientId?: string;
        pdClientSecret?: string;
        pdSubdomain?: string;
    }

}
