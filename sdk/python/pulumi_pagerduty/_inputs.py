# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AlertGroupingSettingConfigArgs',
    'AlertGroupingSettingConfigArgsDict',
    'AutomationActionsActionActionDataReferenceArgs',
    'AutomationActionsActionActionDataReferenceArgsDict',
    'EscalationPolicyRuleArgs',
    'EscalationPolicyRuleArgsDict',
    'EscalationPolicyRuleEscalationRuleAssignmentStrategyArgs',
    'EscalationPolicyRuleEscalationRuleAssignmentStrategyArgsDict',
    'EscalationPolicyRuleTargetArgs',
    'EscalationPolicyRuleTargetArgsDict',
    'EventOrchestrationGlobalCacheVariableConditionArgs',
    'EventOrchestrationGlobalCacheVariableConditionArgsDict',
    'EventOrchestrationGlobalCacheVariableConfigurationArgs',
    'EventOrchestrationGlobalCacheVariableConfigurationArgsDict',
    'EventOrchestrationGlobalCatchAllArgs',
    'EventOrchestrationGlobalCatchAllArgsDict',
    'EventOrchestrationGlobalCatchAllActionsArgs',
    'EventOrchestrationGlobalCatchAllActionsArgsDict',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionArgs',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionArgsDict',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgsDict',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgsDict',
    'EventOrchestrationGlobalCatchAllActionsExtractionArgs',
    'EventOrchestrationGlobalCatchAllActionsExtractionArgsDict',
    'EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgs',
    'EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgsDict',
    'EventOrchestrationGlobalCatchAllActionsVariableArgs',
    'EventOrchestrationGlobalCatchAllActionsVariableArgsDict',
    'EventOrchestrationGlobalSetArgs',
    'EventOrchestrationGlobalSetArgsDict',
    'EventOrchestrationGlobalSetRuleArgs',
    'EventOrchestrationGlobalSetRuleArgsDict',
    'EventOrchestrationGlobalSetRuleActionsArgs',
    'EventOrchestrationGlobalSetRuleActionsArgsDict',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionArgs',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionArgsDict',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgsDict',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgsDict',
    'EventOrchestrationGlobalSetRuleActionsExtractionArgs',
    'EventOrchestrationGlobalSetRuleActionsExtractionArgsDict',
    'EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgs',
    'EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgsDict',
    'EventOrchestrationGlobalSetRuleActionsVariableArgs',
    'EventOrchestrationGlobalSetRuleActionsVariableArgsDict',
    'EventOrchestrationGlobalSetRuleConditionArgs',
    'EventOrchestrationGlobalSetRuleConditionArgsDict',
    'EventOrchestrationIntegrationArgs',
    'EventOrchestrationIntegrationArgsDict',
    'EventOrchestrationIntegrationParameterArgs',
    'EventOrchestrationIntegrationParameterArgsDict',
    'EventOrchestrationRouterCatchAllArgs',
    'EventOrchestrationRouterCatchAllArgsDict',
    'EventOrchestrationRouterCatchAllActionsArgs',
    'EventOrchestrationRouterCatchAllActionsArgsDict',
    'EventOrchestrationRouterSetArgs',
    'EventOrchestrationRouterSetArgsDict',
    'EventOrchestrationRouterSetRuleArgs',
    'EventOrchestrationRouterSetRuleArgsDict',
    'EventOrchestrationRouterSetRuleActionsArgs',
    'EventOrchestrationRouterSetRuleActionsArgsDict',
    'EventOrchestrationRouterSetRuleActionsDynamicRouteToArgs',
    'EventOrchestrationRouterSetRuleActionsDynamicRouteToArgsDict',
    'EventOrchestrationRouterSetRuleConditionArgs',
    'EventOrchestrationRouterSetRuleConditionArgsDict',
    'EventOrchestrationServiceCacheVariableConditionArgs',
    'EventOrchestrationServiceCacheVariableConditionArgsDict',
    'EventOrchestrationServiceCacheVariableConfigurationArgs',
    'EventOrchestrationServiceCacheVariableConfigurationArgsDict',
    'EventOrchestrationServiceCatchAllArgs',
    'EventOrchestrationServiceCatchAllArgsDict',
    'EventOrchestrationServiceCatchAllActionsArgs',
    'EventOrchestrationServiceCatchAllActionsArgsDict',
    'EventOrchestrationServiceCatchAllActionsAutomationActionArgs',
    'EventOrchestrationServiceCatchAllActionsAutomationActionArgsDict',
    'EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs',
    'EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgsDict',
    'EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs',
    'EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgsDict',
    'EventOrchestrationServiceCatchAllActionsExtractionArgs',
    'EventOrchestrationServiceCatchAllActionsExtractionArgsDict',
    'EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgs',
    'EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgsDict',
    'EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs',
    'EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgsDict',
    'EventOrchestrationServiceCatchAllActionsVariableArgs',
    'EventOrchestrationServiceCatchAllActionsVariableArgsDict',
    'EventOrchestrationServiceSetArgs',
    'EventOrchestrationServiceSetArgsDict',
    'EventOrchestrationServiceSetRuleArgs',
    'EventOrchestrationServiceSetRuleArgsDict',
    'EventOrchestrationServiceSetRuleActionsArgs',
    'EventOrchestrationServiceSetRuleActionsArgsDict',
    'EventOrchestrationServiceSetRuleActionsAutomationActionArgs',
    'EventOrchestrationServiceSetRuleActionsAutomationActionArgsDict',
    'EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs',
    'EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgsDict',
    'EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs',
    'EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgsDict',
    'EventOrchestrationServiceSetRuleActionsExtractionArgs',
    'EventOrchestrationServiceSetRuleActionsExtractionArgsDict',
    'EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgs',
    'EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgsDict',
    'EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs',
    'EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgsDict',
    'EventOrchestrationServiceSetRuleActionsVariableArgs',
    'EventOrchestrationServiceSetRuleActionsVariableArgsDict',
    'EventOrchestrationServiceSetRuleConditionArgs',
    'EventOrchestrationServiceSetRuleConditionArgsDict',
    'EventOrchestrationUnroutedCatchAllArgs',
    'EventOrchestrationUnroutedCatchAllArgsDict',
    'EventOrchestrationUnroutedCatchAllActionsArgs',
    'EventOrchestrationUnroutedCatchAllActionsArgsDict',
    'EventOrchestrationUnroutedCatchAllActionsExtractionArgs',
    'EventOrchestrationUnroutedCatchAllActionsExtractionArgsDict',
    'EventOrchestrationUnroutedCatchAllActionsVariableArgs',
    'EventOrchestrationUnroutedCatchAllActionsVariableArgsDict',
    'EventOrchestrationUnroutedSetArgs',
    'EventOrchestrationUnroutedSetArgsDict',
    'EventOrchestrationUnroutedSetRuleArgs',
    'EventOrchestrationUnroutedSetRuleArgsDict',
    'EventOrchestrationUnroutedSetRuleActionsArgs',
    'EventOrchestrationUnroutedSetRuleActionsArgsDict',
    'EventOrchestrationUnroutedSetRuleActionsExtractionArgs',
    'EventOrchestrationUnroutedSetRuleActionsExtractionArgsDict',
    'EventOrchestrationUnroutedSetRuleActionsVariableArgs',
    'EventOrchestrationUnroutedSetRuleActionsVariableArgsDict',
    'EventOrchestrationUnroutedSetRuleConditionArgs',
    'EventOrchestrationUnroutedSetRuleConditionArgsDict',
    'IncidentWorkflowStepArgs',
    'IncidentWorkflowStepArgsDict',
    'IncidentWorkflowStepInlineStepsInputArgs',
    'IncidentWorkflowStepInlineStepsInputArgsDict',
    'IncidentWorkflowStepInlineStepsInputStepArgs',
    'IncidentWorkflowStepInlineStepsInputStepArgsDict',
    'IncidentWorkflowStepInlineStepsInputStepInputArgs',
    'IncidentWorkflowStepInlineStepsInputStepInputArgsDict',
    'IncidentWorkflowStepInputArgs',
    'IncidentWorkflowStepInputArgsDict',
    'IncidentWorkflowTriggerPermissionsArgs',
    'IncidentWorkflowTriggerPermissionsArgsDict',
    'JiraCloudAccountMappingRuleConfigArgs',
    'JiraCloudAccountMappingRuleConfigArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraArgs',
    'JiraCloudAccountMappingRuleConfigJiraArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraCustomFieldArgs',
    'JiraCloudAccountMappingRuleConfigJiraCustomFieldArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraIssueTypeArgs',
    'JiraCloudAccountMappingRuleConfigJiraIssueTypeArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraPriorityArgs',
    'JiraCloudAccountMappingRuleConfigJiraPriorityArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraProjectArgs',
    'JiraCloudAccountMappingRuleConfigJiraProjectArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingArgs',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgs',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgs',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgsDict',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgs',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgsDict',
    'ProviderUseAppOauthScopedTokenArgs',
    'ProviderUseAppOauthScopedTokenArgsDict',
    'ResponsePlayResponderArgs',
    'ResponsePlayResponderArgsDict',
    'ResponsePlayResponderEscalationRuleArgs',
    'ResponsePlayResponderEscalationRuleArgsDict',
    'ResponsePlayResponderEscalationRuleTargetArgs',
    'ResponsePlayResponderEscalationRuleTargetArgsDict',
    'ResponsePlayResponderServiceArgs',
    'ResponsePlayResponderServiceArgsDict',
    'ResponsePlayResponderTeamArgs',
    'ResponsePlayResponderTeamArgsDict',
    'ResponsePlaySubscriberArgs',
    'ResponsePlaySubscriberArgsDict',
    'RulesetRuleActionsArgs',
    'RulesetRuleActionsArgsDict',
    'RulesetRuleActionsAnnotateArgs',
    'RulesetRuleActionsAnnotateArgsDict',
    'RulesetRuleActionsEventActionArgs',
    'RulesetRuleActionsEventActionArgsDict',
    'RulesetRuleActionsExtractionArgs',
    'RulesetRuleActionsExtractionArgsDict',
    'RulesetRuleActionsPriorityArgs',
    'RulesetRuleActionsPriorityArgsDict',
    'RulesetRuleActionsRouteArgs',
    'RulesetRuleActionsRouteArgsDict',
    'RulesetRuleActionsSeverityArgs',
    'RulesetRuleActionsSeverityArgsDict',
    'RulesetRuleActionsSuppressArgs',
    'RulesetRuleActionsSuppressArgsDict',
    'RulesetRuleActionsSuspendArgs',
    'RulesetRuleActionsSuspendArgsDict',
    'RulesetRuleConditionsArgs',
    'RulesetRuleConditionsArgsDict',
    'RulesetRuleConditionsSubconditionArgs',
    'RulesetRuleConditionsSubconditionArgsDict',
    'RulesetRuleConditionsSubconditionParameterArgs',
    'RulesetRuleConditionsSubconditionParameterArgsDict',
    'RulesetRuleTimeFrameArgs',
    'RulesetRuleTimeFrameArgsDict',
    'RulesetRuleTimeFrameActiveBetweenArgs',
    'RulesetRuleTimeFrameActiveBetweenArgsDict',
    'RulesetRuleTimeFrameScheduledWeeklyArgs',
    'RulesetRuleTimeFrameScheduledWeeklyArgsDict',
    'RulesetRuleVariableArgs',
    'RulesetRuleVariableArgsDict',
    'RulesetRuleVariableParameterArgs',
    'RulesetRuleVariableParameterArgsDict',
    'RulesetTeamArgs',
    'RulesetTeamArgsDict',
    'ScheduleFinalScheduleArgs',
    'ScheduleFinalScheduleArgsDict',
    'ScheduleLayerArgs',
    'ScheduleLayerArgsDict',
    'ScheduleLayerRestrictionArgs',
    'ScheduleLayerRestrictionArgsDict',
    'ServiceAlertGroupingParametersArgs',
    'ServiceAlertGroupingParametersArgsDict',
    'ServiceAlertGroupingParametersConfigArgs',
    'ServiceAlertGroupingParametersConfigArgsDict',
    'ServiceAutoPauseNotificationsParametersArgs',
    'ServiceAutoPauseNotificationsParametersArgsDict',
    'ServiceDependencyDependencyArgs',
    'ServiceDependencyDependencyArgsDict',
    'ServiceDependencyDependencyDependentServiceArgs',
    'ServiceDependencyDependencyDependentServiceArgsDict',
    'ServiceDependencyDependencySupportingServiceArgs',
    'ServiceDependencyDependencySupportingServiceArgsDict',
    'ServiceEventRuleActionsArgs',
    'ServiceEventRuleActionsArgsDict',
    'ServiceEventRuleActionsAnnotateArgs',
    'ServiceEventRuleActionsAnnotateArgsDict',
    'ServiceEventRuleActionsEventActionArgs',
    'ServiceEventRuleActionsEventActionArgsDict',
    'ServiceEventRuleActionsExtractionArgs',
    'ServiceEventRuleActionsExtractionArgsDict',
    'ServiceEventRuleActionsPriorityArgs',
    'ServiceEventRuleActionsPriorityArgsDict',
    'ServiceEventRuleActionsSeverityArgs',
    'ServiceEventRuleActionsSeverityArgsDict',
    'ServiceEventRuleActionsSuppressArgs',
    'ServiceEventRuleActionsSuppressArgsDict',
    'ServiceEventRuleActionsSuspendArgs',
    'ServiceEventRuleActionsSuspendArgsDict',
    'ServiceEventRuleConditionsArgs',
    'ServiceEventRuleConditionsArgsDict',
    'ServiceEventRuleConditionsSubconditionArgs',
    'ServiceEventRuleConditionsSubconditionArgsDict',
    'ServiceEventRuleConditionsSubconditionParameterArgs',
    'ServiceEventRuleConditionsSubconditionParameterArgsDict',
    'ServiceEventRuleTimeFrameArgs',
    'ServiceEventRuleTimeFrameArgsDict',
    'ServiceEventRuleTimeFrameActiveBetweenArgs',
    'ServiceEventRuleTimeFrameActiveBetweenArgsDict',
    'ServiceEventRuleTimeFrameScheduledWeeklyArgs',
    'ServiceEventRuleTimeFrameScheduledWeeklyArgsDict',
    'ServiceEventRuleVariableArgs',
    'ServiceEventRuleVariableArgsDict',
    'ServiceEventRuleVariableParameterArgs',
    'ServiceEventRuleVariableParameterArgsDict',
    'ServiceIncidentUrgencyRuleArgs',
    'ServiceIncidentUrgencyRuleArgsDict',
    'ServiceIncidentUrgencyRuleDuringSupportHoursArgs',
    'ServiceIncidentUrgencyRuleDuringSupportHoursArgsDict',
    'ServiceIncidentUrgencyRuleOutsideSupportHoursArgs',
    'ServiceIncidentUrgencyRuleOutsideSupportHoursArgsDict',
    'ServiceIntegrationEmailFilterArgs',
    'ServiceIntegrationEmailFilterArgsDict',
    'ServiceIntegrationEmailParserArgs',
    'ServiceIntegrationEmailParserArgsDict',
    'ServiceIntegrationEmailParserMatchPredicateArgs',
    'ServiceIntegrationEmailParserMatchPredicateArgsDict',
    'ServiceIntegrationEmailParserMatchPredicatePredicateArgs',
    'ServiceIntegrationEmailParserMatchPredicatePredicateArgsDict',
    'ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs',
    'ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgsDict',
    'ServiceIntegrationEmailParserValueExtractorArgs',
    'ServiceIntegrationEmailParserValueExtractorArgsDict',
    'ServiceScheduledActionArgs',
    'ServiceScheduledActionArgsDict',
    'ServiceScheduledActionAtArgs',
    'ServiceScheduledActionAtArgsDict',
    'ServiceSupportHoursArgs',
    'ServiceSupportHoursArgsDict',
    'SlackConnectionConfigArgs',
    'SlackConnectionConfigArgsDict',
    'UserHandoffNotificationRuleContactMethodArgs',
    'UserHandoffNotificationRuleContactMethodArgsDict',
    'WebhookSubscriptionDeliveryMethodArgs',
    'WebhookSubscriptionDeliveryMethodArgsDict',
    'WebhookSubscriptionDeliveryMethodCustomHeaderArgs',
    'WebhookSubscriptionDeliveryMethodCustomHeaderArgsDict',
    'WebhookSubscriptionFilterArgs',
    'WebhookSubscriptionFilterArgsDict',
    'GetAlertGroupingSettingConfigArgs',
    'GetAlertGroupingSettingConfigArgsDict',
    'GetEventOrchestrationIntegrationDetailArgs',
    'GetEventOrchestrationIntegrationDetailArgsDict',
    'GetEventOrchestrationIntegrationDetailParameterArgs',
    'GetEventOrchestrationIntegrationDetailParameterArgsDict',
]

MYPY = False

if not MYPY:
    class AlertGroupingSettingConfigArgsDict(TypedDict):
        aggregate: NotRequired[pulumi.Input[str]]
        """
        One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        """
        fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        """
        time_window: NotRequired[pulumi.Input[int]]
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The duration in seconds within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        """
elif False:
    AlertGroupingSettingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AlertGroupingSettingConfigArgs:
    def __init__(__self__, *,
                 aggregate: Optional[pulumi.Input[str]] = None,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_window: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregate: One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fields: Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        :param pulumi.Input[int] time_window: The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        :param pulumi.Input[int] timeout: The duration in seconds within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        """
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def aggregate(self) -> Optional[pulumi.Input[str]]:
        """
        One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @aggregate.setter
    def aggregate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregate", value)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_window", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The duration in seconds within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class AutomationActionsActionActionDataReferenceArgsDict(TypedDict):
        invocation_command: NotRequired[pulumi.Input[str]]
        """
        The command to execute the script with.
        """
        process_automation_job_arguments: NotRequired[pulumi.Input[str]]
        """
        The arguments to pass to the Process Automation job execution.
        """
        process_automation_job_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Process Automation job to execute.
        """
        process_automation_node_filter: NotRequired[pulumi.Input[str]]
        """
        The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        """
        script: NotRequired[pulumi.Input[str]]
        """
        Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
elif False:
    AutomationActionsActionActionDataReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AutomationActionsActionActionDataReferenceArgs:
    def __init__(__self__, *,
                 invocation_command: Optional[pulumi.Input[str]] = None,
                 process_automation_job_arguments: Optional[pulumi.Input[str]] = None,
                 process_automation_job_id: Optional[pulumi.Input[str]] = None,
                 process_automation_node_filter: Optional[pulumi.Input[str]] = None,
                 script: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] invocation_command: The command to execute the script with.
        :param pulumi.Input[str] process_automation_job_arguments: The arguments to pass to the Process Automation job execution.
        :param pulumi.Input[str] process_automation_job_id: The ID of the Process Automation job to execute.
        :param pulumi.Input[str] process_automation_node_filter: The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        :param pulumi.Input[str] script: Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        if invocation_command is not None:
            pulumi.set(__self__, "invocation_command", invocation_command)
        if process_automation_job_arguments is not None:
            pulumi.set(__self__, "process_automation_job_arguments", process_automation_job_arguments)
        if process_automation_job_id is not None:
            pulumi.set(__self__, "process_automation_job_id", process_automation_job_id)
        if process_automation_node_filter is not None:
            pulumi.set(__self__, "process_automation_node_filter", process_automation_node_filter)
        if script is not None:
            pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter(name="invocationCommand")
    def invocation_command(self) -> Optional[pulumi.Input[str]]:
        """
        The command to execute the script with.
        """
        return pulumi.get(self, "invocation_command")

    @invocation_command.setter
    def invocation_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invocation_command", value)

    @property
    @pulumi.getter(name="processAutomationJobArguments")
    def process_automation_job_arguments(self) -> Optional[pulumi.Input[str]]:
        """
        The arguments to pass to the Process Automation job execution.
        """
        return pulumi.get(self, "process_automation_job_arguments")

    @process_automation_job_arguments.setter
    def process_automation_job_arguments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "process_automation_job_arguments", value)

    @property
    @pulumi.getter(name="processAutomationJobId")
    def process_automation_job_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Process Automation job to execute.
        """
        return pulumi.get(self, "process_automation_job_id")

    @process_automation_job_id.setter
    def process_automation_job_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "process_automation_job_id", value)

    @property
    @pulumi.getter(name="processAutomationNodeFilter")
    def process_automation_node_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        """
        return pulumi.get(self, "process_automation_node_filter")

    @process_automation_node_filter.setter
    def process_automation_node_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "process_automation_node_filter", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)


if not MYPY:
    class EscalationPolicyRuleArgsDict(TypedDict):
        escalation_delay_in_minutes: pulumi.Input[int]
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        targets: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgsDict']]]
        escalation_rule_assignment_strategy: NotRequired[pulumi.Input['EscalationPolicyRuleEscalationRuleAssignmentStrategyArgsDict']]
        """
        The strategy used to assign the escalation rule to an incident. Documented below.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the escalation policy.
        """
elif False:
    EscalationPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EscalationPolicyRuleArgs:
    def __init__(__self__, *,
                 escalation_delay_in_minutes: pulumi.Input[int],
                 targets: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]],
                 escalation_rule_assignment_strategy: Optional[pulumi.Input['EscalationPolicyRuleEscalationRuleAssignmentStrategyArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param pulumi.Input['EscalationPolicyRuleEscalationRuleAssignmentStrategyArgs'] escalation_rule_assignment_strategy: The strategy used to assign the escalation rule to an incident. Documented below.
        :param pulumi.Input[str] id: The ID of the escalation policy.
        """
        pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        pulumi.set(__self__, "targets", targets)
        if escalation_rule_assignment_strategy is not None:
            pulumi.set(__self__, "escalation_rule_assignment_strategy", escalation_rule_assignment_strategy)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> pulumi.Input[int]:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @escalation_delay_in_minutes.setter
    def escalation_delay_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "escalation_delay_in_minutes", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter(name="escalationRuleAssignmentStrategy")
    def escalation_rule_assignment_strategy(self) -> Optional[pulumi.Input['EscalationPolicyRuleEscalationRuleAssignmentStrategyArgs']]:
        """
        The strategy used to assign the escalation rule to an incident. Documented below.
        """
        return pulumi.get(self, "escalation_rule_assignment_strategy")

    @escalation_rule_assignment_strategy.setter
    def escalation_rule_assignment_strategy(self, value: Optional[pulumi.Input['EscalationPolicyRuleEscalationRuleAssignmentStrategyArgs']]):
        pulumi.set(self, "escalation_rule_assignment_strategy", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the escalation policy.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class EscalationPolicyRuleEscalationRuleAssignmentStrategyArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        Can be `round_robin` or `assign_to_everyone`.
        """
elif False:
    EscalationPolicyRuleEscalationRuleAssignmentStrategyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EscalationPolicyRuleEscalationRuleAssignmentStrategyArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Can be `round_robin` or `assign_to_everyone`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `round_robin` or `assign_to_everyone`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EscalationPolicyRuleTargetArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        A target ID
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
elif False:
    EscalationPolicyRuleTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EscalationPolicyRuleTargetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: A target ID
        :param pulumi.Input[str] type: Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EventOrchestrationGlobalCacheVariableConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
elif False:
    EventOrchestrationGlobalCacheVariableConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCacheVariableConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class EventOrchestrationGlobalCacheVariableConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value` or `trigger_event_count`.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        """
        ttl_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count`
        """
elif False:
    EventOrchestrationGlobalCacheVariableConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCacheVariableConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 ttl_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value` or `trigger_event_count`.
        :param pulumi.Input[str] regex: A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        :param pulumi.Input[int] ttl_seconds: The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count`
        """
        pulumi.set(__self__, "type", type)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if ttl_seconds is not None:
            pulumi.set(__self__, "ttl_seconds", ttl_seconds)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value` or `trigger_event_count`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count`
        """
        return pulumi.get(self, "ttl_seconds")

    @ttl_seconds.setter
    def ttl_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl_seconds", value)


if not MYPY:
    class EventOrchestrationGlobalCatchAllArgsDict(TypedDict):
        actions: pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgsDict']
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
elif False:
    EventOrchestrationGlobalCatchAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCatchAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs']):
        """
        :param pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs'] actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs']:
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs']):
        pulumi.set(self, "actions", value)


if not MYPY:
    class EventOrchestrationGlobalCatchAllActionsArgsDict(TypedDict):
        annotate: NotRequired[pulumi.Input[str]]
        """
        Add this text as a note on the resulting incident.
        """
        automation_action: NotRequired[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgsDict']]
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        drop_event: NotRequired[pulumi.Input[bool]]
        """
        When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        """
        escalation_policy: NotRequired[pulumi.Input[str]]
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        event_action: NotRequired[pulumi.Input[str]]
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        extractions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgsDict']]]]
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        incident_custom_field_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgsDict']]]]
        """
        Assign a custom field to the resulting incident.
        """
        priority: NotRequired[pulumi.Input[str]]
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        route_to: NotRequired[pulumi.Input[str]]
        """
        The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        suppress: NotRequired[pulumi.Input[bool]]
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        suspend: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgsDict']]]]
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
elif False:
    EventOrchestrationGlobalCatchAllActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsArgs:
    def __init__(__self__, *,
                 annotate: Optional[pulumi.Input[str]] = None,
                 automation_action: Optional[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs']] = None,
                 drop_event: Optional[pulumi.Input[bool]] = None,
                 escalation_policy: Optional[pulumi.Input[str]] = None,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]]] = None,
                 incident_custom_field_updates: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgs']]]] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 suspend: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] annotate: Add this text as a note on the resulting incident.
        :param pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs'] automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param pulumi.Input[bool] drop_event: When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        :param pulumi.Input[str] escalation_policy: The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgs']]] incident_custom_field_updates: Assign a custom field to the resulting incident.
        :param pulumi.Input[str] priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param pulumi.Input[str] route_to: The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[bool] suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param pulumi.Input[int] suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if drop_event is not None:
            pulumi.set(__self__, "drop_event", drop_event)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if incident_custom_field_updates is not None:
            pulumi.set(__self__, "incident_custom_field_updates", incident_custom_field_updates)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[pulumi.Input[str]]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @annotate.setter
    def annotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotate", value)

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs']]:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @automation_action.setter
    def automation_action(self, value: Optional[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs']]):
        pulumi.set(self, "automation_action", value)

    @property
    @pulumi.getter(name="dropEvent")
    def drop_event(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        """
        return pulumi.get(self, "drop_event")

    @drop_event.setter
    def drop_event(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drop_event", value)

    @property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        return pulumi.get(self, "escalation_policy")

    @escalation_policy.setter
    def escalation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_policy", value)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter(name="incidentCustomFieldUpdates")
    def incident_custom_field_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgs']]]]:
        """
        Assign a custom field to the resulting incident.
        """
        return pulumi.get(self, "incident_custom_field_updates")

    @incident_custom_field_updates.setter
    def incident_custom_field_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgs']]]]):
        pulumi.set(self, "incident_custom_field_updates", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suspend", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class EventOrchestrationGlobalCatchAllActionsAutomationActionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of this Webhook.
        """
        url: pulumi.Input[str]
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        auto_send: NotRequired[pulumi.Input[bool]]
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgsDict']]]]
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgsDict']]]]
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
elif False:
    EventOrchestrationGlobalCatchAllActionsAutomationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsAutomationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auto_send: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name of this Webhook.
        :param pulumi.Input[str] url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param pulumi.Input[bool] auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @auto_send.setter
    def auto_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_send", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]]]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]]]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Name to identify the header
        """
        value: pulumi.Input[str]
        """
        Value of this header
        """
elif False:
    EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the header
        :param pulumi.Input[str] value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this header
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Name to identify the parameter
        """
        value: pulumi.Input[str]
        """
        Value of this parameter
        """
elif False:
    EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: Value of this parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationGlobalCatchAllActionsExtractionArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        template: NotRequired[pulumi.Input[str]]
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
elif False:
    EventOrchestrationGlobalCatchAllActionsExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The custom field id
        """
        value: pulumi.Input[str]
        """
        The value to assign to this custom field
        """
elif False:
    EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The custom field id
        :param pulumi.Input[str] value: The value to assign to this custom field
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The custom field id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to assign to this custom field
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationGlobalCatchAllActionsVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the variable
        """
        path: pulumi.Input[str]
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        type: pulumi.Input[str]
        """
        Only `regex` is supported
        """
        value: pulumi.Input[str]
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
elif False:
    EventOrchestrationGlobalCatchAllActionsVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationGlobalSetArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleArgsDict']]]]
elif False:
    EventOrchestrationGlobalSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleArgsDict(TypedDict):
        actions: pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgsDict']
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgsDict']]]]
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the rule within the set.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        A description of this rule's purpose.
        """
elif False:
    EventOrchestrationGlobalSetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs'],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs'] actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param pulumi.Input[bool] disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param pulumi.Input[str] id: The ID of the rule within the set.
        :param pulumi.Input[str] label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs']:
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]]]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the rule within the set.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleActionsArgsDict(TypedDict):
        annotate: NotRequired[pulumi.Input[str]]
        """
        Add this text as a note on the resulting incident.
        """
        automation_action: NotRequired[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgsDict']]
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        drop_event: NotRequired[pulumi.Input[bool]]
        """
        When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        """
        escalation_policy: NotRequired[pulumi.Input[str]]
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        event_action: NotRequired[pulumi.Input[str]]
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        extractions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgsDict']]]]
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        incident_custom_field_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgsDict']]]]
        """
        Assign a custom field to the resulting incident.
        """
        priority: NotRequired[pulumi.Input[str]]
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        route_to: NotRequired[pulumi.Input[str]]
        """
        The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        suppress: NotRequired[pulumi.Input[bool]]
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        suspend: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgsDict']]]]
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
elif False:
    EventOrchestrationGlobalSetRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsArgs:
    def __init__(__self__, *,
                 annotate: Optional[pulumi.Input[str]] = None,
                 automation_action: Optional[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs']] = None,
                 drop_event: Optional[pulumi.Input[bool]] = None,
                 escalation_policy: Optional[pulumi.Input[str]] = None,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]]] = None,
                 incident_custom_field_updates: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgs']]]] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 suspend: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] annotate: Add this text as a note on the resulting incident.
        :param pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs'] automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param pulumi.Input[bool] drop_event: When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        :param pulumi.Input[str] escalation_policy: The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgs']]] incident_custom_field_updates: Assign a custom field to the resulting incident.
        :param pulumi.Input[str] priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param pulumi.Input[str] route_to: The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[bool] suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param pulumi.Input[int] suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if drop_event is not None:
            pulumi.set(__self__, "drop_event", drop_event)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if incident_custom_field_updates is not None:
            pulumi.set(__self__, "incident_custom_field_updates", incident_custom_field_updates)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[pulumi.Input[str]]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @annotate.setter
    def annotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotate", value)

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs']]:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @automation_action.setter
    def automation_action(self, value: Optional[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs']]):
        pulumi.set(self, "automation_action", value)

    @property
    @pulumi.getter(name="dropEvent")
    def drop_event(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        """
        return pulumi.get(self, "drop_event")

    @drop_event.setter
    def drop_event(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drop_event", value)

    @property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        return pulumi.get(self, "escalation_policy")

    @escalation_policy.setter
    def escalation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_policy", value)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter(name="incidentCustomFieldUpdates")
    def incident_custom_field_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgs']]]]:
        """
        Assign a custom field to the resulting incident.
        """
        return pulumi.get(self, "incident_custom_field_updates")

    @incident_custom_field_updates.setter
    def incident_custom_field_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgs']]]]):
        pulumi.set(self, "incident_custom_field_updates", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suspend", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleActionsAutomationActionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of this Webhook.
        """
        url: pulumi.Input[str]
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        auto_send: NotRequired[pulumi.Input[bool]]
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgsDict']]]]
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgsDict']]]]
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
elif False:
    EventOrchestrationGlobalSetRuleActionsAutomationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsAutomationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auto_send: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name of this Webhook.
        :param pulumi.Input[str] url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param pulumi.Input[bool] auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @auto_send.setter
    def auto_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_send", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]]]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]]]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Name to identify the header
        """
        value: pulumi.Input[str]
        """
        Value of this header
        """
elif False:
    EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the header
        :param pulumi.Input[str] value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this header
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Name to identify the parameter
        """
        value: pulumi.Input[str]
        """
        Value of this parameter
        """
elif False:
    EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: Value of this parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleActionsExtractionArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        template: NotRequired[pulumi.Input[str]]
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
elif False:
    EventOrchestrationGlobalSetRuleActionsExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The custom field id
        """
        value: pulumi.Input[str]
        """
        The value to assign to this custom field
        """
elif False:
    EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The custom field id
        :param pulumi.Input[str] value: The value to assign to this custom field
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The custom field id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to assign to this custom field
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleActionsVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the variable
        """
        path: pulumi.Input[str]
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        type: pulumi.Input[str]
        """
        Only `regex` is supported
        """
        value: pulumi.Input[str]
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
elif False:
    EventOrchestrationGlobalSetRuleActionsVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationGlobalSetRuleConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
elif False:
    EventOrchestrationGlobalSetRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationGlobalSetRuleConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class EventOrchestrationIntegrationArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the integration
        """
        label: NotRequired[pulumi.Input[str]]
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgsDict']]]]
        """
        A single-item list containing a parameter object describing the integration
        """
elif False:
    EventOrchestrationIntegrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationIntegrationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] id: ID of the integration
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgs']]] parameters: A single-item list containing a parameter object describing the integration
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgs']]]]:
        """
        A single-item list containing a parameter object describing the integration
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class EventOrchestrationIntegrationParameterArgsDict(TypedDict):
        routing_key: NotRequired[pulumi.Input[str]]
        """
        Routing key that routes to this Orchestration.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of the routing key. `global` is the default type.
        """
elif False:
    EventOrchestrationIntegrationParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationIntegrationParameterArgs:
    def __init__(__self__, *,
                 routing_key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] routing_key: Routing key that routes to this Orchestration.
        :param pulumi.Input[str] type: Type of the routing key. `global` is the default type.
        """
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[pulumi.Input[str]]:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @routing_key.setter
    def routing_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class EventOrchestrationRouterCatchAllArgsDict(TypedDict):
        actions: pulumi.Input['EventOrchestrationRouterCatchAllActionsArgsDict']
        """
        These are the actions that will be taken to change the resulting alert and incident.
        """
elif False:
    EventOrchestrationRouterCatchAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationRouterCatchAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs']):
        """
        :param pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs'] actions: These are the actions that will be taken to change the resulting alert and incident.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs']:
        """
        These are the actions that will be taken to change the resulting alert and incident.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs']):
        pulumi.set(self, "actions", value)


if not MYPY:
    class EventOrchestrationRouterCatchAllActionsArgsDict(TypedDict):
        route_to: pulumi.Input[str]
        """
        Defines where an alert will be sent if doesn't match any rules. Can either be the ID of a Service _or_ the string `"unrouted"` to send events to the Unrouted Orchestration.
        """
elif False:
    EventOrchestrationRouterCatchAllActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationRouterCatchAllActionsArgs:
    def __init__(__self__, *,
                 route_to: pulumi.Input[str]):
        """
        :param pulumi.Input[str] route_to: Defines where an alert will be sent if doesn't match any rules. Can either be the ID of a Service _or_ the string `"unrouted"` to send events to the Unrouted Orchestration.
        """
        pulumi.set(__self__, "route_to", route_to)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> pulumi.Input[str]:
        """
        Defines where an alert will be sent if doesn't match any rules. Can either be the ID of a Service _or_ the string `"unrouted"` to send events to the Unrouted Orchestration.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: pulumi.Input[str]):
        pulumi.set(self, "route_to", value)


if not MYPY:
    class EventOrchestrationRouterSetArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleArgsDict']]]]
elif False:
    EventOrchestrationRouterSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationRouterSetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] id: ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class EventOrchestrationRouterSetRuleArgsDict(TypedDict):
        actions: pulumi.Input['EventOrchestrationRouterSetRuleActionsArgsDict']
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgsDict']]]]
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the rule within the `start` set.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        A description of this rule's purpose.
        """
elif False:
    EventOrchestrationRouterSetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationRouterSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs'],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs'] actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        :param pulumi.Input[bool] disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param pulumi.Input[str] id: The ID of the rule within the `start` set.
        :param pulumi.Input[str] label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs']:
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]]]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the rule within the `start` set.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


if not MYPY:
    class EventOrchestrationRouterSetRuleActionsArgsDict(TypedDict):
        dynamic_route_tos: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleActionsDynamicRouteToArgsDict']]]]
        """
        supports the following:
        """
        route_to: NotRequired[pulumi.Input[str]]
elif False:
    EventOrchestrationRouterSetRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationRouterSetRuleActionsArgs:
    def __init__(__self__, *,
                 dynamic_route_tos: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleActionsDynamicRouteToArgs']]]] = None,
                 route_to: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleActionsDynamicRouteToArgs']]] dynamic_route_tos: supports the following:
        """
        if dynamic_route_tos is not None:
            pulumi.set(__self__, "dynamic_route_tos", dynamic_route_tos)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)

    @property
    @pulumi.getter(name="dynamicRouteTos")
    def dynamic_route_tos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleActionsDynamicRouteToArgs']]]]:
        """
        supports the following:
        """
        return pulumi.get(self, "dynamic_route_tos")

    @dynamic_route_tos.setter
    def dynamic_route_tos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleActionsDynamicRouteToArgs']]]]):
        pulumi.set(self, "dynamic_route_tos", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)


if not MYPY:
    class EventOrchestrationRouterSetRuleActionsDynamicRouteToArgsDict(TypedDict):
        lookup_by: pulumi.Input[str]
        """
        Indicates whether the extracted value from the source is a service's name or ID. Allowed values are: `service_name`, `service_id`

        If an event has a value at the specified `source`, and if the `regex` successfully matches the value, and if the matching portion is valid Service ID or Name, then the event will be routed to that service. Otherwise the event will be checked against any subsequent router rules.
        """
        regex: pulumi.Input[str]
        """
        The regular expression, used to extract a value from the source field. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        source: pulumi.Input[str]
        """
        The path to a field in an event.
        """
elif False:
    EventOrchestrationRouterSetRuleActionsDynamicRouteToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationRouterSetRuleActionsDynamicRouteToArgs:
    def __init__(__self__, *,
                 lookup_by: pulumi.Input[str],
                 regex: pulumi.Input[str],
                 source: pulumi.Input[str]):
        """
        :param pulumi.Input[str] lookup_by: Indicates whether the extracted value from the source is a service's name or ID. Allowed values are: `service_name`, `service_id`
               
               If an event has a value at the specified `source`, and if the `regex` successfully matches the value, and if the matching portion is valid Service ID or Name, then the event will be routed to that service. Otherwise the event will be checked against any subsequent router rules.
        :param pulumi.Input[str] regex: The regular expression, used to extract a value from the source field. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        :param pulumi.Input[str] source: The path to a field in an event.
        """
        pulumi.set(__self__, "lookup_by", lookup_by)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "source", source)

    @property
    @pulumi.getter(name="lookupBy")
    def lookup_by(self) -> pulumi.Input[str]:
        """
        Indicates whether the extracted value from the source is a service's name or ID. Allowed values are: `service_name`, `service_id`

        If an event has a value at the specified `source`, and if the `regex` successfully matches the value, and if the matching portion is valid Service ID or Name, then the event will be routed to that service. Otherwise the event will be checked against any subsequent router rules.
        """
        return pulumi.get(self, "lookup_by")

    @lookup_by.setter
    def lookup_by(self, value: pulumi.Input[str]):
        pulumi.set(self, "lookup_by", value)

    @property
    @pulumi.getter
    def regex(self) -> pulumi.Input[str]:
        """
        The regular expression, used to extract a value from the source field. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: pulumi.Input[str]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> pulumi.Input[str]:
        """
        The path to a field in an event.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[str]):
        pulumi.set(self, "source", value)


if not MYPY:
    class EventOrchestrationRouterSetRuleConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
elif False:
    EventOrchestrationRouterSetRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationRouterSetRuleConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class EventOrchestrationServiceCacheVariableConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
elif False:
    EventOrchestrationServiceCacheVariableConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCacheVariableConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class EventOrchestrationServiceCacheVariableConfigurationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value` or `trigger_event_count`.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        """
        ttl_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count`
        """
elif False:
    EventOrchestrationServiceCacheVariableConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCacheVariableConfigurationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 ttl_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] type: The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value` or `trigger_event_count`.
        :param pulumi.Input[str] regex: A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        :param pulumi.Input[int] ttl_seconds: The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count`
        """
        pulumi.set(__self__, "type", type)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if ttl_seconds is not None:
            pulumi.set(__self__, "ttl_seconds", ttl_seconds)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value` or `trigger_event_count`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count`
        """
        return pulumi.get(self, "ttl_seconds")

    @ttl_seconds.setter
    def ttl_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ttl_seconds", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllArgsDict(TypedDict):
        actions: pulumi.Input['EventOrchestrationServiceCatchAllActionsArgsDict']
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
elif False:
    EventOrchestrationServiceCatchAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs']):
        """
        :param pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs'] actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs']:
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs']):
        pulumi.set(self, "actions", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllActionsArgsDict(TypedDict):
        annotate: NotRequired[pulumi.Input[str]]
        """
        Add this text as a note on the resulting incident.
        """
        automation_action: NotRequired[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgsDict']]
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        escalation_policy: NotRequired[pulumi.Input[str]]
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        event_action: NotRequired[pulumi.Input[str]]
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        extractions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgsDict']]]]
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        incident_custom_field_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgsDict']]]]
        """
        Assign a custom field to the resulting incident.
        """
        pagerduty_automation_action: NotRequired[pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgsDict']]
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        """
        priority: NotRequired[pulumi.Input[str]]
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        route_to: NotRequired[pulumi.Input[str]]
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        suppress: NotRequired[pulumi.Input[bool]]
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        suspend: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgsDict']]]]
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
elif False:
    EventOrchestrationServiceCatchAllActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsArgs:
    def __init__(__self__, *,
                 annotate: Optional[pulumi.Input[str]] = None,
                 automation_action: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs']] = None,
                 escalation_policy: Optional[pulumi.Input[str]] = None,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]]] = None,
                 incident_custom_field_updates: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgs']]]] = None,
                 pagerduty_automation_action: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs']] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 suspend: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] annotate: Add this text as a note on the resulting incident.
        :param pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs'] automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param pulumi.Input[str] escalation_policy: The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgs']]] incident_custom_field_updates: Assign a custom field to the resulting incident.
        :param pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs'] pagerduty_automation_action: Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        :param pulumi.Input[str] priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param pulumi.Input[str] route_to: The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[bool] suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param pulumi.Input[int] suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if incident_custom_field_updates is not None:
            pulumi.set(__self__, "incident_custom_field_updates", incident_custom_field_updates)
        if pagerduty_automation_action is not None:
            pulumi.set(__self__, "pagerduty_automation_action", pagerduty_automation_action)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            warnings.warn("""The 'route_to' attribute is no longer supported for catch-all rules.""", DeprecationWarning)
            pulumi.log.warn("""route_to is deprecated: The 'route_to' attribute is no longer supported for catch-all rules.""")
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[pulumi.Input[str]]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @annotate.setter
    def annotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotate", value)

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs']]:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @automation_action.setter
    def automation_action(self, value: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs']]):
        pulumi.set(self, "automation_action", value)

    @property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        return pulumi.get(self, "escalation_policy")

    @escalation_policy.setter
    def escalation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_policy", value)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter(name="incidentCustomFieldUpdates")
    def incident_custom_field_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgs']]]]:
        """
        Assign a custom field to the resulting incident.
        """
        return pulumi.get(self, "incident_custom_field_updates")

    @incident_custom_field_updates.setter
    def incident_custom_field_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgs']]]]):
        pulumi.set(self, "incident_custom_field_updates", value)

    @property
    @pulumi.getter(name="pagerdutyAutomationAction")
    def pagerduty_automation_action(self) -> Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs']]:
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        """
        return pulumi.get(self, "pagerduty_automation_action")

    @pagerduty_automation_action.setter
    def pagerduty_automation_action(self, value: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs']]):
        pulumi.set(self, "pagerduty_automation_action", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="routeTo")
    @_utilities.deprecated("""The 'route_to' attribute is no longer supported for catch-all rules.""")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suspend", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllActionsAutomationActionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of this Webhook.
        """
        url: pulumi.Input[str]
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        auto_send: NotRequired[pulumi.Input[bool]]
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgsDict']]]]
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgsDict']]]]
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
elif False:
    EventOrchestrationServiceCatchAllActionsAutomationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsAutomationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auto_send: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name of this Webhook.
        :param pulumi.Input[str] url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param pulumi.Input[bool] auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @auto_send.setter
    def auto_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_send", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]]]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]]]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Name to identify the header
        """
        value: pulumi.Input[str]
        """
        Value of this header
        """
elif False:
    EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the header
        :param pulumi.Input[str] value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this header
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Name to identify the parameter
        """
        value: pulumi.Input[str]
        """
        Value of this parameter
        """
elif False:
    EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: Value of this parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllActionsExtractionArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        template: NotRequired[pulumi.Input[str]]
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
elif False:
    EventOrchestrationServiceCatchAllActionsExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The custom field id
        """
        value: pulumi.Input[str]
        """
        The value to assign to this custom field
        """
elif False:
    EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The custom field id
        :param pulumi.Input[str] value: The value to assign to this custom field
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The custom field id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to assign to this custom field
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgsDict(TypedDict):
        action_id: pulumi.Input[str]
        """
        Id of the Process Automation action to be triggered.
        """
elif False:
    EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs:
    def __init__(__self__, *,
                 action_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action_id: Id of the Process Automation action to be triggered.
        """
        pulumi.set(__self__, "action_id", action_id)

    @property
    @pulumi.getter(name="actionId")
    def action_id(self) -> pulumi.Input[str]:
        """
        Id of the Process Automation action to be triggered.
        """
        return pulumi.get(self, "action_id")

    @action_id.setter
    def action_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_id", value)


if not MYPY:
    class EventOrchestrationServiceCatchAllActionsVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the variable
        """
        path: pulumi.Input[str]
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        type: pulumi.Input[str]
        """
        Only `regex` is supported
        """
        value: pulumi.Input[str]
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
elif False:
    EventOrchestrationServiceCatchAllActionsVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationServiceSetArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleArgsDict']]]]
elif False:
    EventOrchestrationServiceSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleArgsDict(TypedDict):
        actions: pulumi.Input['EventOrchestrationServiceSetRuleActionsArgsDict']
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgsDict']]]]
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the rule within the set.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        A description of this rule's purpose.
        """
elif False:
    EventOrchestrationServiceSetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs'],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs'] actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param pulumi.Input[bool] disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param pulumi.Input[str] id: The ID of the rule within the set.
        :param pulumi.Input[str] label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs']:
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]]]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the rule within the set.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleActionsArgsDict(TypedDict):
        annotate: NotRequired[pulumi.Input[str]]
        """
        Add this text as a note on the resulting incident.
        """
        automation_action: NotRequired[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgsDict']]
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        escalation_policy: NotRequired[pulumi.Input[str]]
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        event_action: NotRequired[pulumi.Input[str]]
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        extractions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgsDict']]]]
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        incident_custom_field_updates: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgsDict']]]]
        """
        Assign a custom field to the resulting incident.
        """
        pagerduty_automation_action: NotRequired[pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgsDict']]
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        """
        priority: NotRequired[pulumi.Input[str]]
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        route_to: NotRequired[pulumi.Input[str]]
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        suppress: NotRequired[pulumi.Input[bool]]
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        suspend: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgsDict']]]]
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
elif False:
    EventOrchestrationServiceSetRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsArgs:
    def __init__(__self__, *,
                 annotate: Optional[pulumi.Input[str]] = None,
                 automation_action: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs']] = None,
                 escalation_policy: Optional[pulumi.Input[str]] = None,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]]] = None,
                 incident_custom_field_updates: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgs']]]] = None,
                 pagerduty_automation_action: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs']] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 suspend: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] annotate: Add this text as a note on the resulting incident.
        :param pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs'] automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param pulumi.Input[str] escalation_policy: The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgs']]] incident_custom_field_updates: Assign a custom field to the resulting incident.
        :param pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs'] pagerduty_automation_action: Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        :param pulumi.Input[str] priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param pulumi.Input[str] route_to: The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[bool] suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param pulumi.Input[int] suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if incident_custom_field_updates is not None:
            pulumi.set(__self__, "incident_custom_field_updates", incident_custom_field_updates)
        if pagerduty_automation_action is not None:
            pulumi.set(__self__, "pagerduty_automation_action", pagerduty_automation_action)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[pulumi.Input[str]]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @annotate.setter
    def annotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotate", value)

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs']]:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @automation_action.setter
    def automation_action(self, value: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs']]):
        pulumi.set(self, "automation_action", value)

    @property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        return pulumi.get(self, "escalation_policy")

    @escalation_policy.setter
    def escalation_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "escalation_policy", value)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter(name="incidentCustomFieldUpdates")
    def incident_custom_field_updates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgs']]]]:
        """
        Assign a custom field to the resulting incident.
        """
        return pulumi.get(self, "incident_custom_field_updates")

    @incident_custom_field_updates.setter
    def incident_custom_field_updates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgs']]]]):
        pulumi.set(self, "incident_custom_field_updates", value)

    @property
    @pulumi.getter(name="pagerdutyAutomationAction")
    def pagerduty_automation_action(self) -> Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs']]:
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        """
        return pulumi.get(self, "pagerduty_automation_action")

    @pagerduty_automation_action.setter
    def pagerduty_automation_action(self, value: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs']]):
        pulumi.set(self, "pagerduty_automation_action", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suspend", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleActionsAutomationActionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of this Webhook.
        """
        url: pulumi.Input[str]
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        auto_send: NotRequired[pulumi.Input[bool]]
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgsDict']]]]
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgsDict']]]]
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
elif False:
    EventOrchestrationServiceSetRuleActionsAutomationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsAutomationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auto_send: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: Name of this Webhook.
        :param pulumi.Input[str] url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param pulumi.Input[bool] auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @auto_send.setter
    def auto_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_send", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]]]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]]]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Name to identify the header
        """
        value: pulumi.Input[str]
        """
        Value of this header
        """
elif False:
    EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the header
        :param pulumi.Input[str] value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this header
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Name to identify the parameter
        """
        value: pulumi.Input[str]
        """
        Value of this parameter
        """
elif False:
    EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: Value of this parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value of this parameter
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleActionsExtractionArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        template: NotRequired[pulumi.Input[str]]
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
elif False:
    EventOrchestrationServiceSetRuleActionsExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The custom field id
        """
        value: pulumi.Input[str]
        """
        The value to assign to this custom field
        """
elif False:
    EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The custom field id
        :param pulumi.Input[str] value: The value to assign to this custom field
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The custom field id
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value to assign to this custom field
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgsDict(TypedDict):
        action_id: pulumi.Input[str]
        """
        Id of the Process Automation action to be triggered.
        """
elif False:
    EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs:
    def __init__(__self__, *,
                 action_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action_id: Id of the Process Automation action to be triggered.
        """
        pulumi.set(__self__, "action_id", action_id)

    @property
    @pulumi.getter(name="actionId")
    def action_id(self) -> pulumi.Input[str]:
        """
        Id of the Process Automation action to be triggered.
        """
        return pulumi.get(self, "action_id")

    @action_id.setter
    def action_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_id", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleActionsVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the variable
        """
        path: pulumi.Input[str]
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        type: pulumi.Input[str]
        """
        Only `regex` is supported
        """
        value: pulumi.Input[str]
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
elif False:
    EventOrchestrationServiceSetRuleActionsVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationServiceSetRuleConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
elif False:
    EventOrchestrationServiceSetRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationServiceSetRuleConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class EventOrchestrationUnroutedCatchAllArgsDict(TypedDict):
        actions: pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgsDict']
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
elif False:
    EventOrchestrationUnroutedCatchAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedCatchAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs']):
        """
        :param pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs'] actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs']:
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs']):
        pulumi.set(self, "actions", value)


if not MYPY:
    class EventOrchestrationUnroutedCatchAllActionsArgsDict(TypedDict):
        event_action: NotRequired[pulumi.Input[str]]
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        extractions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgsDict']]]]
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        suppress: NotRequired[pulumi.Input[bool]]
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgsDict']]]]
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
elif False:
    EventOrchestrationUnroutedCatchAllActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedCatchAllActionsArgs:
    def __init__(__self__, *,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class EventOrchestrationUnroutedCatchAllActionsExtractionArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        template: NotRequired[pulumi.Input[str]]
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
elif False:
    EventOrchestrationUnroutedCatchAllActionsExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedCatchAllActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class EventOrchestrationUnroutedCatchAllActionsVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the variable
        """
        path: pulumi.Input[str]
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        type: pulumi.Input[str]
        """
        Only `regex` is supported
        """
        value: pulumi.Input[str]
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
elif False:
    EventOrchestrationUnroutedCatchAllActionsVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedCatchAllActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationUnroutedSetArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleArgsDict']]]]
elif False:
    EventOrchestrationUnroutedSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedSetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class EventOrchestrationUnroutedSetRuleArgsDict(TypedDict):
        actions: pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgsDict']
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgsDict']]]]
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the rule within the set.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        A description of this rule's purpose.
        """
elif False:
    EventOrchestrationUnroutedSetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs'],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs'] actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param pulumi.Input[bool] disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param pulumi.Input[str] id: The ID of the rule within the set.
        :param pulumi.Input[str] label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs']:
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]]]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the rule within the set.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


if not MYPY:
    class EventOrchestrationUnroutedSetRuleActionsArgsDict(TypedDict):
        event_action: NotRequired[pulumi.Input[str]]
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        extractions: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgsDict']]]]
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        route_to: NotRequired[pulumi.Input[str]]
        """
        The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
        """
        severity: NotRequired[pulumi.Input[str]]
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        variables: NotRequired[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgsDict']]]]
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
elif False:
    EventOrchestrationUnroutedSetRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedSetRuleActionsArgs:
    def __init__(__self__, *,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[str] route_to: The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


if not MYPY:
    class EventOrchestrationUnroutedSetRuleActionsExtractionArgsDict(TypedDict):
        target: pulumi.Input[str]
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        source: NotRequired[pulumi.Input[str]]
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        template: NotRequired[pulumi.Input[str]]
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
elif False:
    EventOrchestrationUnroutedSetRuleActionsExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedSetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class EventOrchestrationUnroutedSetRuleActionsVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the variable
        """
        path: pulumi.Input[str]
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        type: pulumi.Input[str]
        """
        Only `regex` is supported
        """
        value: pulumi.Input[str]
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
elif False:
    EventOrchestrationUnroutedSetRuleActionsVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedSetRuleActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class EventOrchestrationUnroutedSetRuleConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
elif False:
    EventOrchestrationUnroutedSetRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EventOrchestrationUnroutedSetRuleConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class IncidentWorkflowStepArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        """
        name: pulumi.Input[str]
        """
        The name of the workflow step.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the incident workflow.
        """
        inline_steps_inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputArgsDict']]]]
        """
        The list of inputs that contain a series of inline steps for the workflow action.
        """
        inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgsDict']]]]
        """
        The list of standard inputs for the workflow action.
        """
elif False:
    IncidentWorkflowStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentWorkflowStepArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 inline_steps_inputs: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputArgs']]]] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]]] = None):
        """
        :param pulumi.Input[str] action: The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        :param pulumi.Input[str] name: The name of the workflow step.
        :param pulumi.Input[str] id: The ID of the incident workflow.
        :param pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputArgs']]] inline_steps_inputs: The list of inputs that contain a series of inline steps for the workflow action.
        :param pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]] inputs: The list of standard inputs for the workflow action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if inline_steps_inputs is not None:
            pulumi.set(__self__, "inline_steps_inputs", inline_steps_inputs)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the workflow step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the incident workflow.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="inlineStepsInputs")
    def inline_steps_inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputArgs']]]]:
        """
        The list of inputs that contain a series of inline steps for the workflow action.
        """
        return pulumi.get(self, "inline_steps_inputs")

    @inline_steps_inputs.setter
    def inline_steps_inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputArgs']]]]):
        pulumi.set(self, "inline_steps_inputs", value)

    @property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]]]:
        """
        The list of standard inputs for the workflow action.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]]]):
        pulumi.set(self, "inputs", value)


if not MYPY:
    class IncidentWorkflowStepInlineStepsInputArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the input.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepArgsDict']]]]
        """
        The inline steps of the input. An inline step adheres to the step schema described above.
        """
elif False:
    IncidentWorkflowStepInlineStepsInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentWorkflowStepInlineStepsInputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the input.
        :param pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepArgs']]] steps: The inline steps of the input. An inline step adheres to the step schema described above.
        """
        pulumi.set(__self__, "name", name)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the input.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepArgs']]]]:
        """
        The inline steps of the input. An inline step adheres to the step schema described above.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepArgs']]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class IncidentWorkflowStepInlineStepsInputStepArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        """
        name: pulumi.Input[str]
        """
        The name of the workflow step.
        """
        inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepInputArgsDict']]]]
        """
        The list of standard inputs for the workflow action.
        """
elif False:
    IncidentWorkflowStepInlineStepsInputStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentWorkflowStepInlineStepsInputStepArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepInputArgs']]]] = None):
        """
        :param pulumi.Input[str] action: The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        :param pulumi.Input[str] name: The name of the workflow step.
        :param pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepInputArgs']]] inputs: The list of standard inputs for the workflow action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the workflow step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepInputArgs']]]]:
        """
        The list of standard inputs for the workflow action.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInlineStepsInputStepInputArgs']]]]):
        pulumi.set(self, "inputs", value)


if not MYPY:
    class IncidentWorkflowStepInlineStepsInputStepInputArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the input.
        """
        value: pulumi.Input[str]
        """
        The value of the input.
        """
        generated: NotRequired[pulumi.Input[bool]]
elif False:
    IncidentWorkflowStepInlineStepsInputStepInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentWorkflowStepInlineStepsInputStepInputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str],
                 generated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name of the input.
        :param pulumi.Input[str] value: The value of the input.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if generated is not None:
            pulumi.set(__self__, "generated", generated)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the input.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the input.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def generated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "generated")

    @generated.setter
    def generated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generated", value)


if not MYPY:
    class IncidentWorkflowStepInputArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the input.
        """
        value: pulumi.Input[str]
        """
        The value of the input.
        """
        generated: NotRequired[pulumi.Input[bool]]
elif False:
    IncidentWorkflowStepInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentWorkflowStepInputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str],
                 generated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name of the input.
        :param pulumi.Input[str] value: The value of the input.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if generated is not None:
            pulumi.set(__self__, "generated", generated)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the input.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the input.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def generated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "generated")

    @generated.setter
    def generated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generated", value)


if not MYPY:
    class IncidentWorkflowTriggerPermissionsArgsDict(TypedDict):
        restricted: NotRequired[pulumi.Input[bool]]
        """
        If `true`, indicates that the Trigger can only be started by authorized Users. If `false` (default), any user can start this Trigger. Applicable only to `manual`-type triggers.
        """
        team_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the Team whose members can manually start this Trigger. Required and allowed only if `restricted` is `true`.
        """
elif False:
    IncidentWorkflowTriggerPermissionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IncidentWorkflowTriggerPermissionsArgs:
    def __init__(__self__, *,
                 restricted: Optional[pulumi.Input[bool]] = None,
                 team_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] restricted: If `true`, indicates that the Trigger can only be started by authorized Users. If `false` (default), any user can start this Trigger. Applicable only to `manual`-type triggers.
        :param pulumi.Input[str] team_id: The ID of the Team whose members can manually start this Trigger. Required and allowed only if `restricted` is `true`.
        """
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)

    @property
    @pulumi.getter
    def restricted(self) -> Optional[pulumi.Input[bool]]:
        """
        If `true`, indicates that the Trigger can only be started by authorized Users. If `false` (default), any user can start this Trigger. Applicable only to `manual`-type triggers.
        """
        return pulumi.get(self, "restricted")

    @restricted.setter
    def restricted(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "restricted", value)

    @property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Team whose members can manually start this Trigger. Required and allowed only if `restricted` is `true`.
        """
        return pulumi.get(self, "team_id")

    @team_id.setter
    def team_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "team_id", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigArgsDict(TypedDict):
        service: pulumi.Input[str]
        """
        [Updating can cause a resource replacement] The ID of the linked PagerDuty service.
        """
        jira: NotRequired[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraArgsDict']]
        """
        Synchronization settings.
        """
elif False:
    JiraCloudAccountMappingRuleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[str],
                 jira: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraArgs']] = None):
        """
        :param pulumi.Input[str] service: [Updating can cause a resource replacement] The ID of the linked PagerDuty service.
        :param pulumi.Input['JiraCloudAccountMappingRuleConfigJiraArgs'] jira: Synchronization settings.
        """
        pulumi.set(__self__, "service", service)
        if jira is not None:
            pulumi.set(__self__, "jira", jira)

    @property
    @pulumi.getter
    def service(self) -> pulumi.Input[str]:
        """
        [Updating can cause a resource replacement] The ID of the linked PagerDuty service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[str]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter
    def jira(self) -> Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraArgs']]:
        """
        Synchronization settings.
        """
        return pulumi.get(self, "jira")

    @jira.setter
    def jira(self, value: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraArgs']]):
        pulumi.set(self, "jira", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraArgsDict(TypedDict):
        autocreate_jql: NotRequired[pulumi.Input[str]]
        """
        JQL query to automatically create PagerDuty incidents when matching Jira issues are created. Leave empty to disable this feature.
        """
        create_issue_on_incident_trigger: NotRequired[pulumi.Input[bool]]
        """
        When enabled, automatically creates a Jira issue whenever a PagerDuty incident is triggered.
        """
        custom_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraCustomFieldArgsDict']]]]
        """
        Defines how Jira fields are populated when a Jira Issue is created from a PagerDuty Incident.
        """
        issue_type: NotRequired[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraIssueTypeArgsDict']]
        """
        Specifies the Jira issue type to be created or synchronized with PagerDuty incidents.
        """
        priorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraPriorityArgsDict']]]]
        """
        Maps PagerDuty incident priorities to Jira issue priorities for synchronization.
        """
        project: NotRequired[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraProjectArgsDict']]
        """
        [Updating can cause a resource replacement] Defines the Jira project where issues will be created or synchronized.
        """
        status_mapping: NotRequired[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingArgsDict']]
        """
        Maps PagerDuty incident statuses to corresponding Jira issue statuses for synchronization.
        """
        sync_notes_user: NotRequired[pulumi.Input[str]]
        """
        ID of the PagerDuty user for syncing notes and comments between Jira issues and PagerDuty incidents. If not provided, note synchronization is disabled.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraArgs:
    def __init__(__self__, *,
                 autocreate_jql: Optional[pulumi.Input[str]] = None,
                 create_issue_on_incident_trigger: Optional[pulumi.Input[bool]] = None,
                 custom_fields: Optional[pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraCustomFieldArgs']]]] = None,
                 issue_type: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraIssueTypeArgs']] = None,
                 priorities: Optional[pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraPriorityArgs']]]] = None,
                 project: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraProjectArgs']] = None,
                 status_mapping: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingArgs']] = None,
                 sync_notes_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] autocreate_jql: JQL query to automatically create PagerDuty incidents when matching Jira issues are created. Leave empty to disable this feature.
        :param pulumi.Input[bool] create_issue_on_incident_trigger: When enabled, automatically creates a Jira issue whenever a PagerDuty incident is triggered.
        :param pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraCustomFieldArgs']]] custom_fields: Defines how Jira fields are populated when a Jira Issue is created from a PagerDuty Incident.
        :param pulumi.Input['JiraCloudAccountMappingRuleConfigJiraIssueTypeArgs'] issue_type: Specifies the Jira issue type to be created or synchronized with PagerDuty incidents.
        :param pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraPriorityArgs']]] priorities: Maps PagerDuty incident priorities to Jira issue priorities for synchronization.
        :param pulumi.Input['JiraCloudAccountMappingRuleConfigJiraProjectArgs'] project: [Updating can cause a resource replacement] Defines the Jira project where issues will be created or synchronized.
        :param pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingArgs'] status_mapping: Maps PagerDuty incident statuses to corresponding Jira issue statuses for synchronization.
        :param pulumi.Input[str] sync_notes_user: ID of the PagerDuty user for syncing notes and comments between Jira issues and PagerDuty incidents. If not provided, note synchronization is disabled.
        """
        if autocreate_jql is not None:
            pulumi.set(__self__, "autocreate_jql", autocreate_jql)
        if create_issue_on_incident_trigger is not None:
            pulumi.set(__self__, "create_issue_on_incident_trigger", create_issue_on_incident_trigger)
        if custom_fields is not None:
            pulumi.set(__self__, "custom_fields", custom_fields)
        if issue_type is not None:
            pulumi.set(__self__, "issue_type", issue_type)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if status_mapping is not None:
            pulumi.set(__self__, "status_mapping", status_mapping)
        if sync_notes_user is not None:
            pulumi.set(__self__, "sync_notes_user", sync_notes_user)

    @property
    @pulumi.getter(name="autocreateJql")
    def autocreate_jql(self) -> Optional[pulumi.Input[str]]:
        """
        JQL query to automatically create PagerDuty incidents when matching Jira issues are created. Leave empty to disable this feature.
        """
        return pulumi.get(self, "autocreate_jql")

    @autocreate_jql.setter
    def autocreate_jql(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autocreate_jql", value)

    @property
    @pulumi.getter(name="createIssueOnIncidentTrigger")
    def create_issue_on_incident_trigger(self) -> Optional[pulumi.Input[bool]]:
        """
        When enabled, automatically creates a Jira issue whenever a PagerDuty incident is triggered.
        """
        return pulumi.get(self, "create_issue_on_incident_trigger")

    @create_issue_on_incident_trigger.setter
    def create_issue_on_incident_trigger(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "create_issue_on_incident_trigger", value)

    @property
    @pulumi.getter(name="customFields")
    def custom_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraCustomFieldArgs']]]]:
        """
        Defines how Jira fields are populated when a Jira Issue is created from a PagerDuty Incident.
        """
        return pulumi.get(self, "custom_fields")

    @custom_fields.setter
    def custom_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraCustomFieldArgs']]]]):
        pulumi.set(self, "custom_fields", value)

    @property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraIssueTypeArgs']]:
        """
        Specifies the Jira issue type to be created or synchronized with PagerDuty incidents.
        """
        return pulumi.get(self, "issue_type")

    @issue_type.setter
    def issue_type(self, value: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraIssueTypeArgs']]):
        pulumi.set(self, "issue_type", value)

    @property
    @pulumi.getter
    def priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraPriorityArgs']]]]:
        """
        Maps PagerDuty incident priorities to Jira issue priorities for synchronization.
        """
        return pulumi.get(self, "priorities")

    @priorities.setter
    def priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraPriorityArgs']]]]):
        pulumi.set(self, "priorities", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraProjectArgs']]:
        """
        [Updating can cause a resource replacement] Defines the Jira project where issues will be created or synchronized.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraProjectArgs']]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter(name="statusMapping")
    def status_mapping(self) -> Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingArgs']]:
        """
        Maps PagerDuty incident statuses to corresponding Jira issue statuses for synchronization.
        """
        return pulumi.get(self, "status_mapping")

    @status_mapping.setter
    def status_mapping(self, value: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingArgs']]):
        pulumi.set(self, "status_mapping", value)

    @property
    @pulumi.getter(name="syncNotesUser")
    def sync_notes_user(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the PagerDuty user for syncing notes and comments between Jira issues and PagerDuty incidents. If not provided, note synchronization is disabled.
        """
        return pulumi.get(self, "sync_notes_user")

    @sync_notes_user.setter
    def sync_notes_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sync_notes_user", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraCustomFieldArgsDict(TypedDict):
        target_issue_field: pulumi.Input[str]
        """
        The unique identifier key of the Jira field that will be set.
        """
        target_issue_field_name: pulumi.Input[str]
        """
        The human-readable name of the Jira field.
        """
        type: pulumi.Input[str]
        """
        The type of the value that will be set; one of `attribute`, `const` or `jira_value`.
        """
        source_incident_field: NotRequired[pulumi.Input[str]]
        """
        The PagerDuty incident field from which the value will be extracted (only applicable if `type` is `attribute`); one of `incident_number`, `incident_title`, `incident_description`, `incident_status`, `incident_created_at`, `incident_service`, `incident_escalation_policy`, `incident_impacted_services`, `incident_html_url`, `incident_assignees`, `incident_acknowledgers`, `incident_last_status_change_at`, `incident_last_status_change_by`, `incident_urgency` or `incident_priority`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value to be set for the Jira field (only applicable if `type` is `const` or `jira_value`). It must be set as a JSON string.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraCustomFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraCustomFieldArgs:
    def __init__(__self__, *,
                 target_issue_field: pulumi.Input[str],
                 target_issue_field_name: pulumi.Input[str],
                 type: pulumi.Input[str],
                 source_incident_field: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target_issue_field: The unique identifier key of the Jira field that will be set.
        :param pulumi.Input[str] target_issue_field_name: The human-readable name of the Jira field.
        :param pulumi.Input[str] type: The type of the value that will be set; one of `attribute`, `const` or `jira_value`.
        :param pulumi.Input[str] source_incident_field: The PagerDuty incident field from which the value will be extracted (only applicable if `type` is `attribute`); one of `incident_number`, `incident_title`, `incident_description`, `incident_status`, `incident_created_at`, `incident_service`, `incident_escalation_policy`, `incident_impacted_services`, `incident_html_url`, `incident_assignees`, `incident_acknowledgers`, `incident_last_status_change_at`, `incident_last_status_change_by`, `incident_urgency` or `incident_priority`.
        :param pulumi.Input[str] value: The value to be set for the Jira field (only applicable if `type` is `const` or `jira_value`). It must be set as a JSON string.
        """
        pulumi.set(__self__, "target_issue_field", target_issue_field)
        pulumi.set(__self__, "target_issue_field_name", target_issue_field_name)
        pulumi.set(__self__, "type", type)
        if source_incident_field is not None:
            pulumi.set(__self__, "source_incident_field", source_incident_field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="targetIssueField")
    def target_issue_field(self) -> pulumi.Input[str]:
        """
        The unique identifier key of the Jira field that will be set.
        """
        return pulumi.get(self, "target_issue_field")

    @target_issue_field.setter
    def target_issue_field(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_issue_field", value)

    @property
    @pulumi.getter(name="targetIssueFieldName")
    def target_issue_field_name(self) -> pulumi.Input[str]:
        """
        The human-readable name of the Jira field.
        """
        return pulumi.get(self, "target_issue_field_name")

    @target_issue_field_name.setter
    def target_issue_field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_issue_field_name", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the value that will be set; one of `attribute`, `const` or `jira_value`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="sourceIncidentField")
    def source_incident_field(self) -> Optional[pulumi.Input[str]]:
        """
        The PagerDuty incident field from which the value will be extracted (only applicable if `type` is `attribute`); one of `incident_number`, `incident_title`, `incident_description`, `incident_status`, `incident_created_at`, `incident_service`, `incident_escalation_policy`, `incident_impacted_services`, `incident_html_url`, `incident_assignees`, `incident_acknowledgers`, `incident_last_status_change_at`, `incident_last_status_change_by`, `incident_urgency` or `incident_priority`.
        """
        return pulumi.get(self, "source_incident_field")

    @source_incident_field.setter
    def source_incident_field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_incident_field", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value to be set for the Jira field (only applicable if `type` is `const` or `jira_value`). It must be set as a JSON string.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraIssueTypeArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Unique identifier for the Jira issue type.
        """
        name: pulumi.Input[str]
        """
        The name of the Jira issue type.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraIssueTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraIssueTypeArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Unique identifier for the Jira issue type.
        :param pulumi.Input[str] name: The name of the Jira issue type.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique identifier for the Jira issue type.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Jira issue type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraPriorityArgsDict(TypedDict):
        jira_id: pulumi.Input[str]
        """
        The ID of the Jira priority.
        """
        pagerduty_id: pulumi.Input[str]
        """
        The ID of the PagerDuty priority.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraPriorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraPriorityArgs:
    def __init__(__self__, *,
                 jira_id: pulumi.Input[str],
                 pagerduty_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] jira_id: The ID of the Jira priority.
        :param pulumi.Input[str] pagerduty_id: The ID of the PagerDuty priority.
        """
        pulumi.set(__self__, "jira_id", jira_id)
        pulumi.set(__self__, "pagerduty_id", pagerduty_id)

    @property
    @pulumi.getter(name="jiraId")
    def jira_id(self) -> pulumi.Input[str]:
        """
        The ID of the Jira priority.
        """
        return pulumi.get(self, "jira_id")

    @jira_id.setter
    def jira_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "jira_id", value)

    @property
    @pulumi.getter(name="pagerdutyId")
    def pagerduty_id(self) -> pulumi.Input[str]:
        """
        The ID of the PagerDuty priority.
        """
        return pulumi.get(self, "pagerduty_id")

    @pagerduty_id.setter
    def pagerduty_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pagerduty_id", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraProjectArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Unique identifier for the Jira project.
        """
        key: pulumi.Input[str]
        """
        The short key name of the Jira project.
        """
        name: pulumi.Input[str]
        """
        The name of the Jira project.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraProjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraProjectArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 key: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Unique identifier for the Jira project.
        :param pulumi.Input[str] key: The short key name of the Jira project.
        :param pulumi.Input[str] name: The name of the Jira project.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique identifier for the Jira project.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        The short key name of the Jira project.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Jira project.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraStatusMappingArgsDict(TypedDict):
        acknowledged: NotRequired[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgsDict']]
        """
        Jira status that maps to the PagerDuty `acknowledged` status.
        """
        resolved: NotRequired[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgsDict']]
        """
        Jira status that maps to the PagerDuty `resolved` status.
        """
        triggered: NotRequired[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgsDict']]
        """
        Jira status that maps to the PagerDuty `triggered` status.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraStatusMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraStatusMappingArgs:
    def __init__(__self__, *,
                 acknowledged: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgs']] = None,
                 resolved: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgs']] = None,
                 triggered: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgs']] = None):
        """
        :param pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgs'] acknowledged: Jira status that maps to the PagerDuty `acknowledged` status.
        :param pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgs'] resolved: Jira status that maps to the PagerDuty `resolved` status.
        :param pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgs'] triggered: Jira status that maps to the PagerDuty `triggered` status.
        """
        if acknowledged is not None:
            pulumi.set(__self__, "acknowledged", acknowledged)
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)
        if triggered is not None:
            pulumi.set(__self__, "triggered", triggered)

    @property
    @pulumi.getter
    def acknowledged(self) -> Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgs']]:
        """
        Jira status that maps to the PagerDuty `acknowledged` status.
        """
        return pulumi.get(self, "acknowledged")

    @acknowledged.setter
    def acknowledged(self, value: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgs']]):
        pulumi.set(self, "acknowledged", value)

    @property
    @pulumi.getter
    def resolved(self) -> Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgs']]:
        """
        Jira status that maps to the PagerDuty `resolved` status.
        """
        return pulumi.get(self, "resolved")

    @resolved.setter
    def resolved(self, value: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgs']]):
        pulumi.set(self, "resolved", value)

    @property
    @pulumi.getter
    def triggered(self) -> Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgs']]:
        """
        Jira status that maps to the PagerDuty `triggered` status.
        """
        return pulumi.get(self, "triggered")

    @triggered.setter
    def triggered(self, value: Optional[pulumi.Input['JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgs']]):
        pulumi.set(self, "triggered", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the Jira status.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Jira status.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Unique identifier for the Jira status.
        :param pulumi.Input[str] name: Name of the Jira status.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the Jira status.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Jira status.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the Jira status.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the Jira status.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: Unique identifier for the Jira status.
        :param pulumi.Input[str] name: Name of the Jira status.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the Jira status.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the Jira status.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        Unique identifier for the Jira status.
        """
        name: pulumi.Input[str]
        """
        Name of the Jira status.
        """
elif False:
    JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: Unique identifier for the Jira status.
        :param pulumi.Input[str] name: Name of the Jira status.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        Unique identifier for the Jira status.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the Jira status.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ProviderUseAppOauthScopedTokenArgsDict(TypedDict):
        pd_client_id: NotRequired[pulumi.Input[str]]
        pd_client_secret: NotRequired[pulumi.Input[str]]
        pd_subdomain: NotRequired[pulumi.Input[str]]
elif False:
    ProviderUseAppOauthScopedTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ProviderUseAppOauthScopedTokenArgs:
    def __init__(__self__, *,
                 pd_client_id: Optional[pulumi.Input[str]] = None,
                 pd_client_secret: Optional[pulumi.Input[str]] = None,
                 pd_subdomain: Optional[pulumi.Input[str]] = None):
        if pd_client_id is not None:
            pulumi.set(__self__, "pd_client_id", pd_client_id)
        if pd_client_secret is not None:
            pulumi.set(__self__, "pd_client_secret", pd_client_secret)
        if pd_subdomain is not None:
            pulumi.set(__self__, "pd_subdomain", pd_subdomain)

    @property
    @pulumi.getter(name="pdClientId")
    def pd_client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pd_client_id")

    @pd_client_id.setter
    def pd_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pd_client_id", value)

    @property
    @pulumi.getter(name="pdClientSecret")
    def pd_client_secret(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pd_client_secret")

    @pd_client_secret.setter
    def pd_client_secret(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pd_client_secret", value)

    @property
    @pulumi.getter(name="pdSubdomain")
    def pd_subdomain(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "pd_subdomain")

    @pd_subdomain.setter
    def pd_subdomain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pd_subdomain", value)


if not MYPY:
    class ResponsePlayResponderArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        Description of escalation policy
        """
        escalation_rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgsDict']]]]
        """
        The escalation rules
        """
        id: NotRequired[pulumi.Input[str]]
        """
        ID of the user defined as the responder
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the escalation policy
        """
        num_loops: NotRequired[pulumi.Input[int]]
        """
        The number of times the escalation policy will repeat after reaching the end of its escalation.
        """
        on_call_handoff_notifications: NotRequired[pulumi.Input[str]]
        """
        Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgsDict']]]]
        """
        There can be multiple services associated with a policy.
        """
        teams: NotRequired[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgsDict']]]]
        """
        Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Should be set as `escalation_policy` for escalation policy responders.
        """
elif False:
    ResponsePlayResponderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponsePlayResponderArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 escalation_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_loops: Optional[pulumi.Input[int]] = None,
                 on_call_handoff_notifications: Optional[pulumi.Input[str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Description of escalation policy
        :param pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]] escalation_rules: The escalation rules
        :param pulumi.Input[str] id: ID of the user defined as the responder
        :param pulumi.Input[str] name: Name of the escalation policy
        :param pulumi.Input[int] num_loops: The number of times the escalation policy will repeat after reaching the end of its escalation.
        :param pulumi.Input[str] on_call_handoff_notifications: Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        :param pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]] services: There can be multiple services associated with a policy.
        :param pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]] teams: Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        :param pulumi.Input[str] type: Should be set as `escalation_policy` for escalation policy responders.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if escalation_rules is not None:
            pulumi.set(__self__, "escalation_rules", escalation_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_loops is not None:
            pulumi.set(__self__, "num_loops", num_loops)
        if on_call_handoff_notifications is not None:
            pulumi.set(__self__, "on_call_handoff_notifications", on_call_handoff_notifications)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of escalation policy
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="escalationRules")
    def escalation_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]]]:
        """
        The escalation rules
        """
        return pulumi.get(self, "escalation_rules")

    @escalation_rules.setter
    def escalation_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]]]):
        pulumi.set(self, "escalation_rules", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the escalation policy
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numLoops")
    def num_loops(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times the escalation policy will repeat after reaching the end of its escalation.
        """
        return pulumi.get(self, "num_loops")

    @num_loops.setter
    def num_loops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_loops", value)

    @property
    @pulumi.getter(name="onCallHandoffNotifications")
    def on_call_handoff_notifications(self) -> Optional[pulumi.Input[str]]:
        """
        Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        """
        return pulumi.get(self, "on_call_handoff_notifications")

    @on_call_handoff_notifications.setter
    def on_call_handoff_notifications(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_call_handoff_notifications", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]]]:
        """
        There can be multiple services associated with a policy.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]]]:
        """
        Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]]]):
        pulumi.set(self, "teams", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Should be set as `escalation_policy` for escalation policy responders.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResponsePlayResponderEscalationRuleArgsDict(TypedDict):
        targets: pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgsDict']]]
        """
        The targets an incident should be assigned to upon reaching this rule.
        """
        escalation_delay_in_minutes: NotRequired[pulumi.Input[int]]
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the response play.
        """
elif False:
    ResponsePlayResponderEscalationRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponsePlayResponderEscalationRuleArgs:
    def __init__(__self__, *,
                 targets: pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]],
                 escalation_delay_in_minutes: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]] targets: The targets an incident should be assigned to upon reaching this rule.
        :param pulumi.Input[int] escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param pulumi.Input[str] id: The ID of the response play.
        """
        pulumi.set(__self__, "targets", targets)
        if escalation_delay_in_minutes is not None:
            pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]]:
        """
        The targets an incident should be assigned to upon reaching this rule.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @escalation_delay_in_minutes.setter
    def escalation_delay_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "escalation_delay_in_minutes", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ResponsePlayResponderEscalationRuleTargetArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the response play.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
elif False:
    ResponsePlayResponderEscalationRuleTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponsePlayResponderEscalationRuleTargetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the response play.
        :param pulumi.Input[str] type: Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResponsePlayResponderServiceArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the response play.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
elif False:
    ResponsePlayResponderServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponsePlayResponderServiceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the response play.
        :param pulumi.Input[str] type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ResponsePlayResponderTeamArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the response play.
        """
elif False:
    ResponsePlayResponderTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponsePlayResponderTeamArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: A string that determines the schema of the object. If not set, the default value is "response_play".
        :param pulumi.Input[str] id: The ID of the response play.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ResponsePlaySubscriberArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the response play.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
elif False:
    ResponsePlaySubscriberArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ResponsePlaySubscriberArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the response play.
        :param pulumi.Input[str] type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RulesetRuleActionsArgsDict(TypedDict):
        annotates: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgsDict']]]]
        """
        Note added to the event.
        """
        event_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgsDict']]]]
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        extractions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgsDict']]]]
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        priorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgsDict']]]]
        """
        The ID of the priority applied to the event.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgsDict']]]]
        """
        The ID of the service where the event will be routed.
        """
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgsDict']]]]
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        """
        suppresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgsDict']]]]
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        """
        suspends: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgsDict']]]]
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
elif False:
    RulesetRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsArgs:
    def __init__(__self__, *,
                 annotates: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]] = None,
                 event_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]] = None,
                 priorities: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]] = None,
                 suppresses: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]] = None,
                 suspends: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]] annotates: Note added to the event.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]] priorities: The ID of the priority applied to the event.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]] routes: The ID of the service where the event will be routed.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)
        if suspends is not None:
            pulumi.set(__self__, "suspends", suspends)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @annotates.setter
    def annotates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]]):
        pulumi.set(self, "annotates", value)

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @event_actions.setter
    def event_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]]):
        pulumi.set(self, "event_actions", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @priorities.setter
    def priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]]):
        pulumi.set(self, "priorities", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]]:
        """
        The ID of the service where the event will be routed.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]]):
        pulumi.set(self, "severities", value)

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        """
        return pulumi.get(self, "suppresses")

    @suppresses.setter
    def suppresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]]):
        pulumi.set(self, "suppresses", value)

    @property
    @pulumi.getter
    def suspends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]]]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        return pulumi.get(self, "suspends")

    @suspends.setter
    def suspends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]]]):
        pulumi.set(self, "suspends", value)


if not MYPY:
    class RulesetRuleActionsAnnotateArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleActionsAnnotateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsAnnotateArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionsEventActionArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleActionsEventActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsEventActionArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionsExtractionArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[str]]
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        *- **OR** -*
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        target: NotRequired[pulumi.Input[str]]
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.

        *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        template: NotRequired[pulumi.Input[str]]
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
elif False:
    RulesetRuleActionsExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
               
               *- **OR** -*
        :param pulumi.Input[str] source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param pulumi.Input[str] target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
               
               *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        :param pulumi.Input[str] template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        *- **OR** -*
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.

        *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class RulesetRuleActionsPriorityArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleActionsPriorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsPriorityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionsRouteArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleActionsRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsRouteArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionsSeverityArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleActionsSeverityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsSeverityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionsSuppressArgsDict(TypedDict):
        threshold_time_amount: NotRequired[pulumi.Input[int]]
        """
        The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        """
        threshold_time_unit: NotRequired[pulumi.Input[str]]
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        threshold_value: NotRequired[pulumi.Input[int]]
        """
        The number of alerts that should be suppressed. Must be greater than 0.
        """
        value: NotRequired[pulumi.Input[bool]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleActionsSuppressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsSuppressArgs:
    def __init__(__self__, *,
                 threshold_time_amount: Optional[pulumi.Input[int]] = None,
                 threshold_time_unit: Optional[pulumi.Input[str]] = None,
                 threshold_value: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        :param pulumi.Input[str] threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param pulumi.Input[int] threshold_value: The number of alerts that should be suppressed. Must be greater than 0.
        :param pulumi.Input[bool] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[pulumi.Input[int]]:
        """
        The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_time_amount")

    @threshold_time_amount.setter
    def threshold_time_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_time_amount", value)

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @threshold_time_unit.setter
    def threshold_time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_time_unit", value)

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[pulumi.Input[int]]:
        """
        The number of alerts that should be suppressed. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_value")

    @threshold_value.setter
    def threshold_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleActionsSuspendArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[int]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleActionsSuspendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleActionsSuspendArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleConditionsArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[str]]
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        subconditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgsDict']]]]
        """
        List of sub-conditions that define the condition.
        """
elif False:
    RulesetRuleConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleConditionsArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 subconditions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]] subconditions: List of sub-conditions that define the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")

    @subconditions.setter
    def subconditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]]):
        pulumi.set(self, "subconditions", value)


if not MYPY:
    class RulesetRuleConditionsSubconditionArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[str]]
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgsDict']]]]
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
elif False:
    RulesetRuleConditionsSubconditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleConditionsSubconditionArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class RulesetRuleConditionsSubconditionParameterArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleConditionsSubconditionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleConditionsSubconditionParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetRuleTimeFrameArgsDict(TypedDict):
        active_betweens: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgsDict']]]]
        """
        Values for executing the rule during a specific time period.
        """
        scheduled_weeklies: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgsDict']]]]
        """
        Values for executing the rule on a recurring schedule.
        """
elif False:
    RulesetRuleTimeFrameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleTimeFrameArgs:
    def __init__(__self__, *,
                 active_betweens: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]] = None,
                 scheduled_weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]] active_betweens: Values for executing the rule during a specific time period.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @active_betweens.setter
    def active_betweens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]]):
        pulumi.set(self, "active_betweens", value)

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")

    @scheduled_weeklies.setter
    def scheduled_weeklies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]]):
        pulumi.set(self, "scheduled_weeklies", value)


if not MYPY:
    class RulesetRuleTimeFrameActiveBetweenArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[int]]
        start_time: NotRequired[pulumi.Input[int]]
        """
        A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
elif False:
    RulesetRuleTimeFrameActiveBetweenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleTimeFrameActiveBetweenArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] start_time: A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class RulesetRuleTimeFrameScheduledWeeklyArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[int]]
        """
        Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        """
        start_time: NotRequired[pulumi.Input[int]]
        """
        A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
elif False:
    RulesetRuleTimeFrameScheduledWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleTimeFrameScheduledWeeklyArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] duration: Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        :param pulumi.Input[int] start_time: A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        :param pulumi.Input[str] timezone: [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weekdays", value)


if not MYPY:
    class RulesetRuleVariableArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['RulesetRuleVariableParameterArgsDict']]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    RulesetRuleVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleVariableParameterArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleVariableParameterArgs']]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleVariableParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RulesetRuleVariableParameterArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
        value: NotRequired[pulumi.Input[str]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    RulesetRuleVariableParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetRuleVariableParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class RulesetTeamArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of the ruleset.
        """
elif False:
    RulesetTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RulesetTeamArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the ruleset.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the ruleset.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class ScheduleFinalScheduleArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the schedule.
        """
        rendered_coverage_percentage: NotRequired[pulumi.Input[str]]
elif False:
    ScheduleFinalScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleFinalScheduleArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 rendered_coverage_percentage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the schedule.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rendered_coverage_percentage is not None:
            pulumi.set(__self__, "rendered_coverage_percentage", rendered_coverage_percentage)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schedule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="renderedCoveragePercentage")
    def rendered_coverage_percentage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rendered_coverage_percentage")

    @rendered_coverage_percentage.setter
    def rendered_coverage_percentage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rendered_coverage_percentage", value)


if not MYPY:
    class ScheduleLayerArgsDict(TypedDict):
        rotation_turn_length_seconds: pulumi.Input[int]
        """
        The duration of each on-call shift in `seconds`.
        """
        rotation_virtual_start: pulumi.Input[str]
        """
        The effective start time of the schedule layer. This can be before the start time of the schedule.
        """
        start: pulumi.Input[str]
        """
        The start time of the schedule layer.
        """
        users: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        """
        end: NotRequired[pulumi.Input[str]]
        """
        The end time of the schedule layer. If not specified, the layer does not end.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the schedule.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the schedule layer.
        """
        rendered_coverage_percentage: NotRequired[pulumi.Input[str]]
        restrictions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgsDict']]]]
        """
        A schedule layer restriction block. Restriction blocks documented below.
        """
elif False:
    ScheduleLayerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleLayerArgs:
    def __init__(__self__, *,
                 rotation_turn_length_seconds: pulumi.Input[int],
                 rotation_virtual_start: pulumi.Input[str],
                 start: pulumi.Input[str],
                 users: pulumi.Input[Sequence[pulumi.Input[str]]],
                 end: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 rendered_coverage_percentage: Optional[pulumi.Input[str]] = None,
                 restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]] = None):
        """
        :param pulumi.Input[int] rotation_turn_length_seconds: The duration of each on-call shift in `seconds`.
        :param pulumi.Input[str] rotation_virtual_start: The effective start time of the schedule layer. This can be before the start time of the schedule.
        :param pulumi.Input[str] start: The start time of the schedule layer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] users: The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        :param pulumi.Input[str] end: The end time of the schedule layer. If not specified, the layer does not end.
        :param pulumi.Input[str] id: The ID of the schedule.
        :param pulumi.Input[str] name: The name of the schedule layer.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]] restrictions: A schedule layer restriction block. Restriction blocks documented below.
        """
        pulumi.set(__self__, "rotation_turn_length_seconds", rotation_turn_length_seconds)
        pulumi.set(__self__, "rotation_virtual_start", rotation_virtual_start)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "users", users)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rendered_coverage_percentage is not None:
            pulumi.set(__self__, "rendered_coverage_percentage", rendered_coverage_percentage)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter(name="rotationTurnLengthSeconds")
    def rotation_turn_length_seconds(self) -> pulumi.Input[int]:
        """
        The duration of each on-call shift in `seconds`.
        """
        return pulumi.get(self, "rotation_turn_length_seconds")

    @rotation_turn_length_seconds.setter
    def rotation_turn_length_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "rotation_turn_length_seconds", value)

    @property
    @pulumi.getter(name="rotationVirtualStart")
    def rotation_virtual_start(self) -> pulumi.Input[str]:
        """
        The effective start time of the schedule layer. This can be before the start time of the schedule.
        """
        return pulumi.get(self, "rotation_virtual_start")

    @rotation_virtual_start.setter
    def rotation_virtual_start(self, value: pulumi.Input[str]):
        pulumi.set(self, "rotation_virtual_start", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The start time of the schedule layer.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter
    def users(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        The end time of the schedule layer. If not specified, the layer does not end.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the schedule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schedule layer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="renderedCoveragePercentage")
    def rendered_coverage_percentage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rendered_coverage_percentage")

    @rendered_coverage_percentage.setter
    def rendered_coverage_percentage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rendered_coverage_percentage", value)

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]]:
        """
        A schedule layer restriction block. Restriction blocks documented below.
        """
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]]):
        pulumi.set(self, "restrictions", value)


if not MYPY:
    class ScheduleLayerRestrictionArgsDict(TypedDict):
        duration_seconds: pulumi.Input[int]
        """
        The duration of the restriction in `seconds`.
        """
        start_time_of_day: pulumi.Input[str]
        """
        The start time in `HH:mm:ss` format.
        """
        type: pulumi.Input[str]
        """
        Can be `daily_restriction` or `weekly_restriction`.
        """
        start_day_of_week: NotRequired[pulumi.Input[int]]
        """
        Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
elif False:
    ScheduleLayerRestrictionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ScheduleLayerRestrictionArgs:
    def __init__(__self__, *,
                 duration_seconds: pulumi.Input[int],
                 start_time_of_day: pulumi.Input[str],
                 type: pulumi.Input[str],
                 start_day_of_week: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] duration_seconds: The duration of the restriction in `seconds`.
        :param pulumi.Input[str] start_time_of_day: The start time in `HH:mm:ss` format.
        :param pulumi.Input[str] type: Can be `daily_restriction` or `weekly_restriction`.
        :param pulumi.Input[int] start_day_of_week: Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        pulumi.set(__self__, "duration_seconds", duration_seconds)
        pulumi.set(__self__, "start_time_of_day", start_time_of_day)
        pulumi.set(__self__, "type", type)
        if start_day_of_week is not None:
            pulumi.set(__self__, "start_day_of_week", start_day_of_week)

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> pulumi.Input[int]:
        """
        The duration of the restriction in `seconds`.
        """
        return pulumi.get(self, "duration_seconds")

    @duration_seconds.setter
    def duration_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "duration_seconds", value)

    @property
    @pulumi.getter(name="startTimeOfDay")
    def start_time_of_day(self) -> pulumi.Input[str]:
        """
        The start time in `HH:mm:ss` format.
        """
        return pulumi.get(self, "start_time_of_day")

    @start_time_of_day.setter
    def start_time_of_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time_of_day", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `daily_restriction` or `weekly_restriction`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[pulumi.Input[int]]:
        """
        Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        return pulumi.get(self, "start_day_of_week")

    @start_day_of_week.setter
    def start_day_of_week(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_day_of_week", value)


if not MYPY:
    class ServiceAlertGroupingParametersArgsDict(TypedDict):
        config: NotRequired[pulumi.Input['ServiceAlertGroupingParametersConfigArgsDict']]
        """
        Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
elif False:
    ServiceAlertGroupingParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAlertGroupingParametersArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['ServiceAlertGroupingParametersConfigArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ServiceAlertGroupingParametersConfigArgs'] config: Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        :param pulumi.Input[str] type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['ServiceAlertGroupingParametersConfigArgs']]:
        """
        Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['ServiceAlertGroupingParametersConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceAlertGroupingParametersConfigArgsDict(TypedDict):
        aggregate: NotRequired[pulumi.Input[str]]
        """
        One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        """
        fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        """
        time_window: NotRequired[pulumi.Input[int]]
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent` or `content_based`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
elif False:
    ServiceAlertGroupingParametersConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAlertGroupingParametersConfigArgs:
    def __init__(__self__, *,
                 aggregate: Optional[pulumi.Input[str]] = None,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 time_window: Optional[pulumi.Input[int]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregate: One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fields: Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        :param pulumi.Input[int] time_window: The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent` or `content_based`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours.
        :param pulumi.Input[int] timeout: The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def aggregate(self) -> Optional[pulumi.Input[str]]:
        """
        One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @aggregate.setter
    def aggregate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregate", value)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent` or `content_based`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours.
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "time_window", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ServiceAutoPauseNotificationsParametersArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
        """
elif False:
    ServiceAutoPauseNotificationsParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceAutoPauseNotificationsParametersArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        :param pulumi.Input[int] timeout: Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class ServiceDependencyDependencyArgsDict(TypedDict):
        dependent_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgsDict']]]
        """
        The service that dependents on the supporting service. Dependency dependent service documented below. One and only one `dependent_service` dependency block must be defined.
        """
        supporting_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgsDict']]]
        """
        The service that supports the dependent service. Dependency supporting service documented below. One and only one `supporting_service` dependency block must be defined.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
elif False:
    ServiceDependencyDependencyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDependencyDependencyArgs:
    def __init__(__self__, *,
                 dependent_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]],
                 supporting_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]] dependent_services: The service that dependents on the supporting service. Dependency dependent service documented below. One and only one `dependent_service` dependency block must be defined.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]] supporting_services: The service that supports the dependent service. Dependency supporting service documented below. One and only one `supporting_service` dependency block must be defined.
        :param pulumi.Input[str] type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "dependent_services", dependent_services)
        pulumi.set(__self__, "supporting_services", supporting_services)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dependentServices")
    def dependent_services(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]]:
        """
        The service that dependents on the supporting service. Dependency dependent service documented below. One and only one `dependent_service` dependency block must be defined.
        """
        return pulumi.get(self, "dependent_services")

    @dependent_services.setter
    def dependent_services(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]]):
        pulumi.set(self, "dependent_services", value)

    @property
    @pulumi.getter(name="supportingServices")
    def supporting_services(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]]:
        """
        The service that supports the dependent service. Dependency supporting service documented below. One and only one `supporting_service` dependency block must be defined.
        """
        return pulumi.get(self, "supporting_services")

    @supporting_services.setter
    def supporting_services(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]]):
        pulumi.set(self, "supporting_services", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceDependencyDependencyDependentServiceArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of the service dependency.
        """
        type: pulumi.Input[str]
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
elif False:
    ServiceDependencyDependencyDependentServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDependencyDependencyDependentServiceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the service dependency.
        :param pulumi.Input[str] type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceDependencyDependencySupportingServiceArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of the service dependency.
        """
        type: pulumi.Input[str]
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
elif False:
    ServiceDependencyDependencySupportingServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceDependencyDependencySupportingServiceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the service dependency.
        :param pulumi.Input[str] type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceEventRuleActionsArgsDict(TypedDict):
        annotates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgsDict']]]]
        """
        Note added to the event.
        """
        event_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgsDict']]]]
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        extractions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgsDict']]]]
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        priorities: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgsDict']]]]
        """
        The ID of the priority applied to the event.
        """
        severities: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgsDict']]]]
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        """
        suppresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgsDict']]]]
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        suspends: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgsDict']]]]
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
elif False:
    ServiceEventRuleActionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleActionsArgs:
    def __init__(__self__, *,
                 annotates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]]] = None,
                 event_actions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]]] = None,
                 priorities: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]]] = None,
                 suppresses: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]]] = None,
                 suspends: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]] annotates: Note added to the event.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]] priorities: The ID of the priority applied to the event.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)
        if suspends is not None:
            pulumi.set(__self__, "suspends", suspends)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]]]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @annotates.setter
    def annotates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]]]):
        pulumi.set(self, "annotates", value)

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]]]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @event_actions.setter
    def event_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]]]):
        pulumi.set(self, "event_actions", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]]]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]]]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @priorities.setter
    def priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]]]):
        pulumi.set(self, "priorities", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]]]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]]]):
        pulumi.set(self, "severities", value)

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]]]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        return pulumi.get(self, "suppresses")

    @suppresses.setter
    def suppresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]]]):
        pulumi.set(self, "suppresses", value)

    @property
    @pulumi.getter
    def suspends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]]]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        return pulumi.get(self, "suspends")

    @suspends.setter
    def suspends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]]]):
        pulumi.set(self, "suspends", value)


if not MYPY:
    class ServiceEventRuleActionsAnnotateArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    ServiceEventRuleActionsAnnotateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleActionsAnnotateArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceEventRuleActionsEventActionArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    ServiceEventRuleActionsEventActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleActionsEventActionArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceEventRuleActionsExtractionArgsDict(TypedDict):
        regex: NotRequired[pulumi.Input[str]]
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        *- **OR** -*
        """
        source: NotRequired[pulumi.Input[str]]
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        target: NotRequired[pulumi.Input[str]]
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.

        *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        template: NotRequired[pulumi.Input[str]]
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
elif False:
    ServiceEventRuleActionsExtractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
               
               *- **OR** -*
        :param pulumi.Input[str] source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param pulumi.Input[str] target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
               
               *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        :param pulumi.Input[str] template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        *- **OR** -*
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.

        *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


if not MYPY:
    class ServiceEventRuleActionsPriorityArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    ServiceEventRuleActionsPriorityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleActionsPriorityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceEventRuleActionsSeverityArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[str]]
elif False:
    ServiceEventRuleActionsSeverityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleActionsSeverityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceEventRuleActionsSuppressArgsDict(TypedDict):
        threshold_time_amount: NotRequired[pulumi.Input[int]]
        """
        The number value of the `threshold_time_unit` before an incident is created.
        """
        threshold_time_unit: NotRequired[pulumi.Input[str]]
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        threshold_value: NotRequired[pulumi.Input[int]]
        """
        The number of alerts that should be suppressed.
        """
        value: NotRequired[pulumi.Input[bool]]
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
elif False:
    ServiceEventRuleActionsSuppressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleActionsSuppressArgs:
    def __init__(__self__, *,
                 threshold_time_amount: Optional[pulumi.Input[int]] = None,
                 threshold_time_unit: Optional[pulumi.Input[str]] = None,
                 threshold_value: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created.
        :param pulumi.Input[str] threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param pulumi.Input[int] threshold_value: The number of alerts that should be suppressed.
        :param pulumi.Input[bool] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[pulumi.Input[int]]:
        """
        The number value of the `threshold_time_unit` before an incident is created.
        """
        return pulumi.get(self, "threshold_time_amount")

    @threshold_time_amount.setter
    def threshold_time_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_time_amount", value)

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @threshold_time_unit.setter
    def threshold_time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_time_unit", value)

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[pulumi.Input[int]]:
        """
        The number of alerts that should be suppressed.
        """
        return pulumi.get(self, "threshold_value")

    @threshold_value.setter
    def threshold_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceEventRuleActionsSuspendArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[int]]
elif False:
    ServiceEventRuleActionsSuspendArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleActionsSuspendArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[int]] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceEventRuleConditionsArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[str]]
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        subconditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgsDict']]]]
        """
        List of sub-conditions that define the condition.
        """
elif False:
    ServiceEventRuleConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleConditionsArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 subconditions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]] subconditions: List of sub-conditions that define the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]]]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")

    @subconditions.setter
    def subconditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]]]):
        pulumi.set(self, "subconditions", value)


if not MYPY:
    class ServiceEventRuleConditionsSubconditionArgsDict(TypedDict):
        operator: NotRequired[pulumi.Input[str]]
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgsDict']]]]
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
elif False:
    ServiceEventRuleConditionsSubconditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleConditionsSubconditionArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]]]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class ServiceEventRuleConditionsSubconditionParameterArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    ServiceEventRuleConditionsSubconditionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleConditionsSubconditionParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceEventRuleTimeFrameArgsDict(TypedDict):
        active_betweens: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgsDict']]]]
        """
        Values for executing the rule during a specific time period.
        """
        scheduled_weeklies: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgsDict']]]]
        """
        Values for executing the rule on a recurring schedule.
        """
elif False:
    ServiceEventRuleTimeFrameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleTimeFrameArgs:
    def __init__(__self__, *,
                 active_betweens: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]]] = None,
                 scheduled_weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]] active_betweens: Values for executing the rule during a specific time period.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]]]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @active_betweens.setter
    def active_betweens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]]]):
        pulumi.set(self, "active_betweens", value)

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]]]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")

    @scheduled_weeklies.setter
    def scheduled_weeklies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]]]):
        pulumi.set(self, "scheduled_weeklies", value)


if not MYPY:
    class ServiceEventRuleTimeFrameActiveBetweenArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[int]]
        """
        Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        start_time: NotRequired[pulumi.Input[int]]
        """
        Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
elif False:
    ServiceEventRuleTimeFrameActiveBetweenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleTimeFrameActiveBetweenArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] end_time: Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        :param pulumi.Input[int] start_time: Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[int]]:
        """
        Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class ServiceEventRuleTimeFrameScheduledWeeklyArgsDict(TypedDict):
        duration: NotRequired[pulumi.Input[int]]
        """
        Length of time the schedule will be active.  Unix timestamp in milliseconds.
        """
        start_time: NotRequired[pulumi.Input[int]]
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        timezone: NotRequired[pulumi.Input[str]]
        """
        Timezone for the given schedule.
        """
        weekdays: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
elif False:
    ServiceEventRuleTimeFrameScheduledWeeklyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleTimeFrameScheduledWeeklyArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] duration: Length of time the schedule will be active.  Unix timestamp in milliseconds.
        :param pulumi.Input[int] start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        :param pulumi.Input[str] timezone: Timezone for the given schedule.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        Length of time the schedule will be active.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Timezone for the given schedule.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weekdays", value)


if not MYPY:
    class ServiceEventRuleVariableArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the variable.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgsDict']]]]
        """
        The parameters for performing the operation to populate the variable.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Type of operation to populate the variable. Usually `regex`.
        """
elif False:
    ServiceEventRuleVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]] parameters: The parameters for performing the operation to populate the variable.
        :param pulumi.Input[str] type: Type of operation to populate the variable. Usually `regex`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]]]:
        """
        The parameters for performing the operation to populate the variable.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of operation to populate the variable. Usually `regex`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceEventRuleVariableParameterArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        value: NotRequired[pulumi.Input[str]]
elif False:
    ServiceEventRuleVariableParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceEventRuleVariableParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ServiceIncidentUrgencyRuleArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of incident urgency: `constant` or `use_support_hours` (when depending on specific support hours; see `support_hours`).
        """
        during_support_hours: NotRequired[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgsDict']]
        """
        Incidents' urgency during support hours.
        """
        outside_support_hours: NotRequired[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgsDict']]
        """
        Incidents' urgency outside support hours.
        """
        urgency: NotRequired[pulumi.Input[str]]
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
elif False:
    ServiceIncidentUrgencyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIncidentUrgencyRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 during_support_hours: Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']] = None,
                 outside_support_hours: Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of incident urgency: `constant` or `use_support_hours` (when depending on specific support hours; see `support_hours`).
        :param pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs'] during_support_hours: Incidents' urgency during support hours.
        :param pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs'] outside_support_hours: Incidents' urgency outside support hours.
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        pulumi.set(__self__, "type", type)
        if during_support_hours is not None:
            pulumi.set(__self__, "during_support_hours", during_support_hours)
        if outside_support_hours is not None:
            pulumi.set(__self__, "outside_support_hours", outside_support_hours)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of incident urgency: `constant` or `use_support_hours` (when depending on specific support hours; see `support_hours`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="duringSupportHours")
    def during_support_hours(self) -> Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']]:
        """
        Incidents' urgency during support hours.
        """
        return pulumi.get(self, "during_support_hours")

    @during_support_hours.setter
    def during_support_hours(self, value: Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']]):
        pulumi.set(self, "during_support_hours", value)

    @property
    @pulumi.getter(name="outsideSupportHours")
    def outside_support_hours(self) -> Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']]:
        """
        Incidents' urgency outside support hours.
        """
        return pulumi.get(self, "outside_support_hours")

    @outside_support_hours.setter
    def outside_support_hours(self, value: Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']]):
        pulumi.set(self, "outside_support_hours", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


if not MYPY:
    class ServiceIncidentUrgencyRuleDuringSupportHoursArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        """
        urgency: NotRequired[pulumi.Input[str]]
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
elif False:
    ServiceIncidentUrgencyRuleDuringSupportHoursArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIncidentUrgencyRuleDuringSupportHoursArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


if not MYPY:
    class ServiceIncidentUrgencyRuleOutsideSupportHoursArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        """
        urgency: NotRequired[pulumi.Input[str]]
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
elif False:
    ServiceIncidentUrgencyRuleOutsideSupportHoursArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIncidentUrgencyRuleOutsideSupportHoursArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


if not MYPY:
    class ServiceIntegrationEmailFilterArgsDict(TypedDict):
        body_mode: NotRequired[pulumi.Input[str]]
        """
        Can be `always` or `match`.
        """
        body_regex: NotRequired[pulumi.Input[str]]
        """
        Should be a valid regex or `null`
        """
        from_email_mode: NotRequired[pulumi.Input[str]]
        """
        Can be `always` or `match`.
        """
        from_email_regex: NotRequired[pulumi.Input[str]]
        """
        Should be a valid regex or `null`
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the service integration.
        """
        subject_mode: NotRequired[pulumi.Input[str]]
        """
        Can be `always` or `match`.
        """
        subject_regex: NotRequired[pulumi.Input[str]]
        """
        Should be a valid regex or `null`
        """
elif False:
    ServiceIntegrationEmailFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationEmailFilterArgs:
    def __init__(__self__, *,
                 body_mode: Optional[pulumi.Input[str]] = None,
                 body_regex: Optional[pulumi.Input[str]] = None,
                 from_email_mode: Optional[pulumi.Input[str]] = None,
                 from_email_regex: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 subject_mode: Optional[pulumi.Input[str]] = None,
                 subject_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] body_mode: Can be `always` or `match`.
        :param pulumi.Input[str] body_regex: Should be a valid regex or `null`
        :param pulumi.Input[str] from_email_mode: Can be `always` or `match`.
        :param pulumi.Input[str] from_email_regex: Should be a valid regex or `null`
        :param pulumi.Input[str] id: The ID of the service integration.
        :param pulumi.Input[str] subject_mode: Can be `always` or `match`.
        :param pulumi.Input[str] subject_regex: Should be a valid regex or `null`
        """
        if body_mode is not None:
            pulumi.set(__self__, "body_mode", body_mode)
        if body_regex is not None:
            pulumi.set(__self__, "body_regex", body_regex)
        if from_email_mode is not None:
            pulumi.set(__self__, "from_email_mode", from_email_mode)
        if from_email_regex is not None:
            pulumi.set(__self__, "from_email_regex", from_email_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subject_mode is not None:
            pulumi.set(__self__, "subject_mode", subject_mode)
        if subject_regex is not None:
            pulumi.set(__self__, "subject_regex", subject_regex)

    @property
    @pulumi.getter(name="bodyMode")
    def body_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "body_mode")

    @body_mode.setter
    def body_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_mode", value)

    @property
    @pulumi.getter(name="bodyRegex")
    def body_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "body_regex")

    @body_regex.setter
    def body_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_regex", value)

    @property
    @pulumi.getter(name="fromEmailMode")
    def from_email_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "from_email_mode")

    @from_email_mode.setter
    def from_email_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_email_mode", value)

    @property
    @pulumi.getter(name="fromEmailRegex")
    def from_email_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "from_email_regex")

    @from_email_regex.setter
    def from_email_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_email_regex", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the service integration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="subjectMode")
    def subject_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "subject_mode")

    @subject_mode.setter
    def subject_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_mode", value)

    @property
    @pulumi.getter(name="subjectRegex")
    def subject_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "subject_regex")

    @subject_regex.setter
    def subject_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_regex", value)


if not MYPY:
    class ServiceIntegrationEmailParserArgsDict(TypedDict):
        action: pulumi.Input[str]
        """
        Can be `resolve` or `trigger`.
        """
        match_predicate: pulumi.Input['ServiceIntegrationEmailParserMatchPredicateArgsDict']
        id: NotRequired[pulumi.Input[int]]
        """
        The ID of the service integration.
        """
        value_extractors: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserValueExtractorArgsDict']]]]
elif False:
    ServiceIntegrationEmailParserArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationEmailParserArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 match_predicate: pulumi.Input['ServiceIntegrationEmailParserMatchPredicateArgs'],
                 id: Optional[pulumi.Input[int]] = None,
                 value_extractors: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserValueExtractorArgs']]]] = None):
        """
        :param pulumi.Input[str] action: Can be `resolve` or `trigger`.
        :param pulumi.Input[int] id: The ID of the service integration.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match_predicate", match_predicate)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if value_extractors is not None:
            pulumi.set(__self__, "value_extractors", value_extractors)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Can be `resolve` or `trigger`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="matchPredicate")
    def match_predicate(self) -> pulumi.Input['ServiceIntegrationEmailParserMatchPredicateArgs']:
        return pulumi.get(self, "match_predicate")

    @match_predicate.setter
    def match_predicate(self, value: pulumi.Input['ServiceIntegrationEmailParserMatchPredicateArgs']):
        pulumi.set(self, "match_predicate", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the service integration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="valueExtractors")
    def value_extractors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserValueExtractorArgs']]]]:
        return pulumi.get(self, "value_extractors")

    @value_extractors.setter
    def value_extractors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserValueExtractorArgs']]]]):
        pulumi.set(self, "value_extractors", value)


if not MYPY:
    class ServiceIntegrationEmailParserMatchPredicateArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Can be `any` or `all`.
        """
        predicates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicateArgsDict']]]]
elif False:
    ServiceIntegrationEmailParserMatchPredicateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationEmailParserMatchPredicateArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 predicates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicateArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Can be `any` or `all`.
        """
        pulumi.set(__self__, "type", type)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `any` or `all`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def predicates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicateArgs']]]]:
        return pulumi.get(self, "predicates")

    @predicates.setter
    def predicates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicateArgs']]]]):
        pulumi.set(self, "predicates", value)


if not MYPY:
    class ServiceIntegrationEmailParserMatchPredicatePredicateArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        matcher: NotRequired[pulumi.Input[str]]
        """
        Predicate value or valid regex.
        """
        part: NotRequired[pulumi.Input[str]]
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        predicates: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgsDict']]]]
elif False:
    ServiceIntegrationEmailParserMatchPredicatePredicateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationEmailParserMatchPredicatePredicateArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 matcher: Optional[pulumi.Input[str]] = None,
                 part: Optional[pulumi.Input[str]] = None,
                 predicates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        :param pulumi.Input[str] matcher: Predicate value or valid regex.
        :param pulumi.Input[str] part: Can be `subject`, `body` or `from_addresses`.
        """
        pulumi.set(__self__, "type", type)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)
        if part is not None:
            pulumi.set(__self__, "part", part)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def matcher(self) -> Optional[pulumi.Input[str]]:
        """
        Predicate value or valid regex.
        """
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "matcher", value)

    @property
    @pulumi.getter
    def part(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        return pulumi.get(self, "part")

    @part.setter
    def part(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "part", value)

    @property
    @pulumi.getter
    def predicates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs']]]]:
        return pulumi.get(self, "predicates")

    @predicates.setter
    def predicates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs']]]]):
        pulumi.set(self, "predicates", value)


if not MYPY:
    class ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgsDict(TypedDict):
        matcher: pulumi.Input[str]
        """
        Predicate value or valid regex.
        """
        part: pulumi.Input[str]
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        type: pulumi.Input[str]
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
elif False:
    ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs:
    def __init__(__self__, *,
                 matcher: pulumi.Input[str],
                 part: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] matcher: Predicate value or valid regex.
        :param pulumi.Input[str] part: Can be `subject`, `body` or `from_addresses`.
        :param pulumi.Input[str] type: Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        pulumi.set(__self__, "matcher", matcher)
        pulumi.set(__self__, "part", part)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def matcher(self) -> pulumi.Input[str]:
        """
        Predicate value or valid regex.
        """
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: pulumi.Input[str]):
        pulumi.set(self, "matcher", value)

    @property
    @pulumi.getter
    def part(self) -> pulumi.Input[str]:
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        return pulumi.get(self, "part")

    @part.setter
    def part(self, value: pulumi.Input[str]):
        pulumi.set(self, "part", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceIntegrationEmailParserValueExtractorArgsDict(TypedDict):
        part: pulumi.Input[str]
        """
        Can be `subject` or `body`.
        """
        type: pulumi.Input[str]
        """
        Can be `between`, `entire` or `regex`.
        """
        value_name: pulumi.Input[str]
        """
        First value extractor should have name `incident_key` other value extractors should contain custom names.
        """
        ends_before: NotRequired[pulumi.Input[str]]
        regex: NotRequired[pulumi.Input[str]]
        """
        If `type` has value `regex` this value should contain valid regex.

        **Note:** You can use the `get_vendor` data source to locate the appropriate vendor ID.
        """
        starts_after: NotRequired[pulumi.Input[str]]
elif False:
    ServiceIntegrationEmailParserValueExtractorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceIntegrationEmailParserValueExtractorArgs:
    def __init__(__self__, *,
                 part: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value_name: pulumi.Input[str],
                 ends_before: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 starts_after: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] part: Can be `subject` or `body`.
        :param pulumi.Input[str] type: Can be `between`, `entire` or `regex`.
        :param pulumi.Input[str] value_name: First value extractor should have name `incident_key` other value extractors should contain custom names.
        :param pulumi.Input[str] regex: If `type` has value `regex` this value should contain valid regex.
               
               **Note:** You can use the `get_vendor` data source to locate the appropriate vendor ID.
        """
        pulumi.set(__self__, "part", part)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value_name", value_name)
        if ends_before is not None:
            pulumi.set(__self__, "ends_before", ends_before)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if starts_after is not None:
            pulumi.set(__self__, "starts_after", starts_after)

    @property
    @pulumi.getter
    def part(self) -> pulumi.Input[str]:
        """
        Can be `subject` or `body`.
        """
        return pulumi.get(self, "part")

    @part.setter
    def part(self, value: pulumi.Input[str]):
        pulumi.set(self, "part", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `between`, `entire` or `regex`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="valueName")
    def value_name(self) -> pulumi.Input[str]:
        """
        First value extractor should have name `incident_key` other value extractors should contain custom names.
        """
        return pulumi.get(self, "value_name")

    @value_name.setter
    def value_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "value_name", value)

    @property
    @pulumi.getter(name="endsBefore")
    def ends_before(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ends_before")

    @ends_before.setter
    def ends_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ends_before", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        If `type` has value `regex` this value should contain valid regex.

        **Note:** You can use the `get_vendor` data source to locate the appropriate vendor ID.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter(name="startsAfter")
    def starts_after(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "starts_after")

    @starts_after.setter
    def starts_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "starts_after", value)


if not MYPY:
    class ServiceScheduledActionArgsDict(TypedDict):
        ats: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgsDict']]]]
        """
        A block representing when the scheduled action will occur.
        """
        to_urgency: NotRequired[pulumi.Input[str]]
        """
        The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
elif False:
    ServiceScheduledActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceScheduledActionArgs:
    def __init__(__self__, *,
                 ats: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]] = None,
                 to_urgency: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]] ats: A block representing when the scheduled action will occur.
        :param pulumi.Input[str] to_urgency: The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        :param pulumi.Input[str] type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if to_urgency is not None:
            pulumi.set(__self__, "to_urgency", to_urgency)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]]:
        """
        A block representing when the scheduled action will occur.
        """
        return pulumi.get(self, "ats")

    @ats.setter
    def ats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]]):
        pulumi.set(self, "ats", value)

    @property
    @pulumi.getter(name="toUrgency")
    def to_urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        """
        return pulumi.get(self, "to_urgency")

    @to_urgency.setter
    def to_urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to_urgency", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceScheduledActionAtArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.

        Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `during_support_hours` and to `low`  for `outside_support_hours` in `incident_urgency_rule`.

        Below is an example for a `Service` resource with `incident_urgency_rules` with `type = "use_support_hours"`, `support_hours` and a default `scheduled_action` as well.

        ```python
        import pulumi
        import pulumi_pagerduty as pagerduty

        foo = pagerduty.Service("foo",
            name="bar",
            description="bar bar bar",
            auto_resolve_timeout="3600",
            acknowledgement_timeout="3600",
            escalation_policy=foo_pagerduty_escalation_policy["id"],
            incident_urgency_rule={
                "type": "use_support_hours",
                "during_support_hours": {
                    "type": "constant",
                    "urgency": "high",
                },
                "outside_support_hours": {
                    "type": "constant",
                    "urgency": "low",
                },
            },
            support_hours={
                "type": "fixed_time_per_day",
                "time_zone": "America/Lima",
                "start_time": "09:00:00",
                "end_time": "17:00:00",
                "days_of_weeks": [
                    1,
                    2,
                    3,
                    4,
                    5,
                ],
            },
            scheduled_actions=[{
                "type": "urgency_change",
                "to_urgency": "high",
                "ats": [{
                    "type": "named_time",
                    "name": "support_hours_start",
                }],
            }])
        ```
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of time specification. Currently, this must be set to `named_time`.
        """
elif False:
    ServiceScheduledActionAtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceScheduledActionAtArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
               
               Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `during_support_hours` and to `low`  for `outside_support_hours` in `incident_urgency_rule`.
               
               Below is an example for a `Service` resource with `incident_urgency_rules` with `type = "use_support_hours"`, `support_hours` and a default `scheduled_action` as well.
               
               ```python
               import pulumi
               import pulumi_pagerduty as pagerduty
               
               foo = pagerduty.Service("foo",
                   name="bar",
                   description="bar bar bar",
                   auto_resolve_timeout="3600",
                   acknowledgement_timeout="3600",
                   escalation_policy=foo_pagerduty_escalation_policy["id"],
                   incident_urgency_rule={
                       "type": "use_support_hours",
                       "during_support_hours": {
                           "type": "constant",
                           "urgency": "high",
                       },
                       "outside_support_hours": {
                           "type": "constant",
                           "urgency": "low",
                       },
                   },
                   support_hours={
                       "type": "fixed_time_per_day",
                       "time_zone": "America/Lima",
                       "start_time": "09:00:00",
                       "end_time": "17:00:00",
                       "days_of_weeks": [
                           1,
                           2,
                           3,
                           4,
                           5,
                       ],
                   },
                   scheduled_actions=[{
                       "type": "urgency_change",
                       "to_urgency": "high",
                       "ats": [{
                           "type": "named_time",
                           "name": "support_hours_start",
                       }],
                   }])
               ```
        :param pulumi.Input[str] type: The type of time specification. Currently, this must be set to `named_time`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.

        Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `during_support_hours` and to `low`  for `outside_support_hours` in `incident_urgency_rule`.

        Below is an example for a `Service` resource with `incident_urgency_rules` with `type = "use_support_hours"`, `support_hours` and a default `scheduled_action` as well.

        ```python
        import pulumi
        import pulumi_pagerduty as pagerduty

        foo = pagerduty.Service("foo",
            name="bar",
            description="bar bar bar",
            auto_resolve_timeout="3600",
            acknowledgement_timeout="3600",
            escalation_policy=foo_pagerduty_escalation_policy["id"],
            incident_urgency_rule={
                "type": "use_support_hours",
                "during_support_hours": {
                    "type": "constant",
                    "urgency": "high",
                },
                "outside_support_hours": {
                    "type": "constant",
                    "urgency": "low",
                },
            },
            support_hours={
                "type": "fixed_time_per_day",
                "time_zone": "America/Lima",
                "start_time": "09:00:00",
                "end_time": "17:00:00",
                "days_of_weeks": [
                    1,
                    2,
                    3,
                    4,
                    5,
                ],
            },
            scheduled_actions=[{
                "type": "urgency_change",
                "to_urgency": "high",
                "ats": [{
                    "type": "named_time",
                    "name": "support_hours_start",
                }],
            }])
        ```
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of time specification. Currently, this must be set to `named_time`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ServiceSupportHoursArgsDict(TypedDict):
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        Array of days of week as integers. `1` to `7`, `1` being
        Monday and `7` being Sunday.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        The support hours' ending time of day.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        The support hours' starting time of day.
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        The time zone for the support hours.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of support hours. Can be `fixed_time_per_day`.
        """
elif False:
    ServiceSupportHoursArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceSupportHoursArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] days_of_weeks: Array of days of week as integers. `1` to `7`, `1` being
               Monday and `7` being Sunday.
        :param pulumi.Input[str] end_time: The support hours' ending time of day.
        :param pulumi.Input[str] start_time: The support hours' starting time of day.
        :param pulumi.Input[str] time_zone: The time zone for the support hours.
        :param pulumi.Input[str] type: The type of support hours. Can be `fixed_time_per_day`.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Array of days of week as integers. `1` to `7`, `1` being
        Monday and `7` being Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        The support hours' ending time of day.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The support hours' starting time of day.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone for the support hours.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of support hours. Can be `fixed_time_per_day`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SlackConnectionConfigArgsDict(TypedDict):
        events: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
        - `incident.acknowledged`
        - `incident.escalated`
        - `incident.resolved`
        - `incident.reassigned`
        - `incident.annotated`
        - `incident.unacknowledged`
        - `incident.delegated`
        - `incident.priority_updated`
        - `incident.responder.added`
        - `incident.responder.replied`
        - `incident.status_update_published`
        - `incident.reopened`
        """
        priorities: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through get_priority data source.
        - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behavior is to set `priorities` to `No Priority` value.
        - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
        """
        urgency: NotRequired[pulumi.Input[str]]
        """
        Allows you to filter events by urgency. Either `high`, `low` or `null` for Any urgency. Default is `null`.
        """
elif False:
    SlackConnectionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SlackConnectionConfigArgs:
    def __init__(__self__, *,
                 events: pulumi.Input[Sequence[pulumi.Input[str]]],
                 priorities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
               - `incident.acknowledged`
               - `incident.escalated`
               - `incident.resolved`
               - `incident.reassigned`
               - `incident.annotated`
               - `incident.unacknowledged`
               - `incident.delegated`
               - `incident.priority_updated`
               - `incident.responder.added`
               - `incident.responder.replied`
               - `incident.status_update_published`
               - `incident.reopened`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] priorities: Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through get_priority data source.
               - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behavior is to set `priorities` to `No Priority` value.
               - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
        :param pulumi.Input[str] urgency: Allows you to filter events by urgency. Either `high`, `low` or `null` for Any urgency. Default is `null`.
        """
        pulumi.set(__self__, "events", events)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
        - `incident.acknowledged`
        - `incident.escalated`
        - `incident.resolved`
        - `incident.reassigned`
        - `incident.annotated`
        - `incident.unacknowledged`
        - `incident.delegated`
        - `incident.priority_updated`
        - `incident.responder.added`
        - `incident.responder.replied`
        - `incident.status_update_published`
        - `incident.reopened`
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through get_priority data source.
        - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behavior is to set `priorities` to `No Priority` value.
        - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
        """
        return pulumi.get(self, "priorities")

    @priorities.setter
    def priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "priorities", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        Allows you to filter events by urgency. Either `high`, `low` or `null` for Any urgency. Default is `null`.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


if not MYPY:
    class UserHandoffNotificationRuleContactMethodArgsDict(TypedDict):
        id: pulumi.Input[str]
        """
        The ID of the contact method.
        """
        type: pulumi.Input[str]
        """
        The type of the contact method. May be (`email_contact_method`, `email_contact_method_reference`, `phone_contact_method`, `phone_contact_method_reference`, `push_notification_contact_method`, `push_notification_contact_method_reference`, `sms_contact_method`, `sms_contact_method_reference`).
        """
elif False:
    UserHandoffNotificationRuleContactMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UserHandoffNotificationRuleContactMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the contact method.
        :param pulumi.Input[str] type: The type of the contact method. May be (`email_contact_method`, `email_contact_method_reference`, `phone_contact_method`, `phone_contact_method_reference`, `push_notification_contact_method`, `push_notification_contact_method_reference`, `sms_contact_method`, `sms_contact_method_reference`).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the contact method.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of the contact method. May be (`email_contact_method`, `email_contact_method_reference`, `phone_contact_method`, `phone_contact_method_reference`, `push_notification_contact_method`, `push_notification_contact_method_reference`, `sms_contact_method`, `sms_contact_method_reference`).
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class WebhookSubscriptionDeliveryMethodArgsDict(TypedDict):
        custom_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgsDict']]]]
        """
        The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        """
        temporarily_disabled: NotRequired[pulumi.Input[bool]]
        """
        Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The destination URL for webhook delivery.
        """
elif False:
    WebhookSubscriptionDeliveryMethodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookSubscriptionDeliveryMethodArgs:
    def __init__(__self__, *,
                 custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]]] = None,
                 temporarily_disabled: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]] custom_headers: The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        :param pulumi.Input[bool] temporarily_disabled: Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        :param pulumi.Input[str] type: Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        :param pulumi.Input[str] url: The destination URL for webhook delivery.
        """
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if temporarily_disabled is not None:
            pulumi.set(__self__, "temporarily_disabled", temporarily_disabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]]]:
        """
        The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        """
        return pulumi.get(self, "custom_headers")

    @custom_headers.setter
    def custom_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]]]):
        pulumi.set(self, "custom_headers", value)

    @property
    @pulumi.getter(name="temporarilyDisabled")
    def temporarily_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        """
        return pulumi.get(self, "temporarily_disabled")

    @temporarily_disabled.setter
    def temporarily_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "temporarily_disabled", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The destination URL for webhook delivery.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class WebhookSubscriptionDeliveryMethodCustomHeaderArgsDict(TypedDict):
        name: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    WebhookSubscriptionDeliveryMethodCustomHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookSubscriptionDeliveryMethodCustomHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class WebhookSubscriptionFilterArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
elif False:
    WebhookSubscriptionFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WebhookSubscriptionFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        :param pulumi.Input[str] id: The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class GetAlertGroupingSettingConfigArgsDict(TypedDict):
        time_window: int
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        """
        timeout: int
        """
        The duration in minutes within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        """
        aggregate: NotRequired[str]
        """
        One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        """
        fields: NotRequired[Sequence[str]]
        """
        Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        """
elif False:
    GetAlertGroupingSettingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAlertGroupingSettingConfigArgs:
    def __init__(__self__, *,
                 time_window: int,
                 timeout: int,
                 aggregate: Optional[str] = None,
                 fields: Optional[Sequence[str]] = None):
        """
        :param int time_window: The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        :param int timeout: The duration in minutes within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        :param str aggregate: One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        :param Sequence[str] fields: Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        """
        pulumi.set(__self__, "time_window", time_window)
        pulumi.set(__self__, "timeout", timeout)
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> int:
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        """
        return pulumi.get(self, "time_window")

    @time_window.setter
    def time_window(self, value: int):
        pulumi.set(self, "time_window", value)

    @property
    @pulumi.getter
    def timeout(self) -> int:
        """
        The duration in minutes within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: int):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter
    def aggregate(self) -> Optional[str]:
        """
        One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @aggregate.setter
    def aggregate(self, value: Optional[str]):
        pulumi.set(self, "aggregate", value)

    @property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[str]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "fields", value)


if not MYPY:
    class GetEventOrchestrationIntegrationDetailArgsDict(TypedDict):
        id: str
        """
        ID of the integration
        """
        label: str
        parameters: Sequence['GetEventOrchestrationIntegrationDetailParameterArgsDict']
        """
        A single-item list containing a parameter object describing the integration
        """
elif False:
    GetEventOrchestrationIntegrationDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEventOrchestrationIntegrationDetailArgs:
    def __init__(__self__, *,
                 id: str,
                 label: str,
                 parameters: Sequence['GetEventOrchestrationIntegrationDetailParameterArgs']):
        """
        :param str id: ID of the integration
        :param Sequence['GetEventOrchestrationIntegrationDetailParameterArgs'] parameters: A single-item list containing a parameter object describing the integration
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: str):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['GetEventOrchestrationIntegrationDetailParameterArgs']:
        """
        A single-item list containing a parameter object describing the integration
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Sequence['GetEventOrchestrationIntegrationDetailParameterArgs']):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class GetEventOrchestrationIntegrationDetailParameterArgsDict(TypedDict):
        routing_key: str
        """
        Routing key that routes to this Orchestration.
        """
        type: str
        """
        Type of the routing key. `global` is the default type.
        """
elif False:
    GetEventOrchestrationIntegrationDetailParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetEventOrchestrationIntegrationDetailParameterArgs:
    def __init__(__self__, *,
                 routing_key: str,
                 type: str):
        """
        :param str routing_key: Routing key that routes to this Orchestration.
        :param str type: Type of the routing key. `global` is the default type.
        """
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @routing_key.setter
    def routing_key(self, value: str):
        pulumi.set(self, "routing_key", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)


