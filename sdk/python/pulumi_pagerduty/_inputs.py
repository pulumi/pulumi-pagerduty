# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'AutomationActionsActionActionDataReferenceArgs',
    'EscalationPolicyRuleArgs',
    'EscalationPolicyRuleTargetArgs',
    'EventOrchestrationGlobalCatchAllArgs',
    'EventOrchestrationGlobalCatchAllActionsArgs',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionArgs',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs',
    'EventOrchestrationGlobalCatchAllActionsExtractionArgs',
    'EventOrchestrationGlobalCatchAllActionsVariableArgs',
    'EventOrchestrationGlobalSetArgs',
    'EventOrchestrationGlobalSetRuleArgs',
    'EventOrchestrationGlobalSetRuleActionsArgs',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionArgs',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs',
    'EventOrchestrationGlobalSetRuleActionsExtractionArgs',
    'EventOrchestrationGlobalSetRuleActionsVariableArgs',
    'EventOrchestrationGlobalSetRuleConditionArgs',
    'EventOrchestrationIntegrationArgs',
    'EventOrchestrationIntegrationParameterArgs',
    'EventOrchestrationRouterCatchAllArgs',
    'EventOrchestrationRouterCatchAllActionsArgs',
    'EventOrchestrationRouterSetArgs',
    'EventOrchestrationRouterSetRuleArgs',
    'EventOrchestrationRouterSetRuleActionsArgs',
    'EventOrchestrationRouterSetRuleConditionArgs',
    'EventOrchestrationServiceCatchAllArgs',
    'EventOrchestrationServiceCatchAllActionsArgs',
    'EventOrchestrationServiceCatchAllActionsAutomationActionArgs',
    'EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs',
    'EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs',
    'EventOrchestrationServiceCatchAllActionsExtractionArgs',
    'EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs',
    'EventOrchestrationServiceCatchAllActionsVariableArgs',
    'EventOrchestrationServiceSetArgs',
    'EventOrchestrationServiceSetRuleArgs',
    'EventOrchestrationServiceSetRuleActionsArgs',
    'EventOrchestrationServiceSetRuleActionsAutomationActionArgs',
    'EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs',
    'EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs',
    'EventOrchestrationServiceSetRuleActionsExtractionArgs',
    'EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs',
    'EventOrchestrationServiceSetRuleActionsVariableArgs',
    'EventOrchestrationServiceSetRuleConditionArgs',
    'EventOrchestrationUnroutedCatchAllArgs',
    'EventOrchestrationUnroutedCatchAllActionsArgs',
    'EventOrchestrationUnroutedCatchAllActionsExtractionArgs',
    'EventOrchestrationUnroutedCatchAllActionsVariableArgs',
    'EventOrchestrationUnroutedSetArgs',
    'EventOrchestrationUnroutedSetRuleArgs',
    'EventOrchestrationUnroutedSetRuleActionsArgs',
    'EventOrchestrationUnroutedSetRuleActionsExtractionArgs',
    'EventOrchestrationUnroutedSetRuleActionsVariableArgs',
    'EventOrchestrationUnroutedSetRuleConditionArgs',
    'IncidentWorkflowStepArgs',
    'IncidentWorkflowStepInputArgs',
    'ProviderUseAppOauthScopedTokenArgs',
    'ResponsePlayResponderArgs',
    'ResponsePlayResponderEscalationRuleArgs',
    'ResponsePlayResponderEscalationRuleTargetArgs',
    'ResponsePlayResponderServiceArgs',
    'ResponsePlayResponderTeamArgs',
    'ResponsePlaySubscriberArgs',
    'RulesetRuleActionsArgs',
    'RulesetRuleActionsAnnotateArgs',
    'RulesetRuleActionsEventActionArgs',
    'RulesetRuleActionsExtractionArgs',
    'RulesetRuleActionsPriorityArgs',
    'RulesetRuleActionsRouteArgs',
    'RulesetRuleActionsSeverityArgs',
    'RulesetRuleActionsSuppressArgs',
    'RulesetRuleActionsSuspendArgs',
    'RulesetRuleConditionsArgs',
    'RulesetRuleConditionsSubconditionArgs',
    'RulesetRuleConditionsSubconditionParameterArgs',
    'RulesetRuleTimeFrameArgs',
    'RulesetRuleTimeFrameActiveBetweenArgs',
    'RulesetRuleTimeFrameScheduledWeeklyArgs',
    'RulesetRuleVariableArgs',
    'RulesetRuleVariableParameterArgs',
    'RulesetTeamArgs',
    'ScheduleFinalScheduleArgs',
    'ScheduleLayerArgs',
    'ScheduleLayerRestrictionArgs',
    'ServiceAlertGroupingParametersArgs',
    'ServiceAlertGroupingParametersConfigArgs',
    'ServiceAutoPauseNotificationsParametersArgs',
    'ServiceDependencyDependencyArgs',
    'ServiceDependencyDependencyDependentServiceArgs',
    'ServiceDependencyDependencySupportingServiceArgs',
    'ServiceEventRuleActionsArgs',
    'ServiceEventRuleActionsAnnotateArgs',
    'ServiceEventRuleActionsEventActionArgs',
    'ServiceEventRuleActionsExtractionArgs',
    'ServiceEventRuleActionsPriorityArgs',
    'ServiceEventRuleActionsSeverityArgs',
    'ServiceEventRuleActionsSuppressArgs',
    'ServiceEventRuleActionsSuspendArgs',
    'ServiceEventRuleConditionsArgs',
    'ServiceEventRuleConditionsSubconditionArgs',
    'ServiceEventRuleConditionsSubconditionParameterArgs',
    'ServiceEventRuleTimeFrameArgs',
    'ServiceEventRuleTimeFrameActiveBetweenArgs',
    'ServiceEventRuleTimeFrameScheduledWeeklyArgs',
    'ServiceEventRuleVariableArgs',
    'ServiceEventRuleVariableParameterArgs',
    'ServiceIncidentUrgencyRuleArgs',
    'ServiceIncidentUrgencyRuleDuringSupportHoursArgs',
    'ServiceIncidentUrgencyRuleOutsideSupportHoursArgs',
    'ServiceIntegrationEmailFilterArgs',
    'ServiceIntegrationEmailParserArgs',
    'ServiceIntegrationEmailParserMatchPredicateArgs',
    'ServiceIntegrationEmailParserMatchPredicatePredicateArgs',
    'ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs',
    'ServiceIntegrationEmailParserValueExtractorArgs',
    'ServiceScheduledActionArgs',
    'ServiceScheduledActionAtArgs',
    'ServiceSupportHoursArgs',
    'SlackConnectionConfigArgs',
    'WebhookSubscriptionDeliveryMethodArgs',
    'WebhookSubscriptionDeliveryMethodCustomHeaderArgs',
    'WebhookSubscriptionFilterArgs',
    'GetEventOrchestrationIntegrationDetailArgs',
    'GetEventOrchestrationIntegrationDetailParameterArgs',
    'GetLicensesLicenseArgs',
]

@pulumi.input_type
class AutomationActionsActionActionDataReferenceArgs:
    def __init__(__self__, *,
                 invocation_command: Optional[pulumi.Input[str]] = None,
                 process_automation_job_arguments: Optional[pulumi.Input[str]] = None,
                 process_automation_job_id: Optional[pulumi.Input[str]] = None,
                 process_automation_node_filter: Optional[pulumi.Input[str]] = None,
                 script: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] invocation_command: The command to execute the script with.
        :param pulumi.Input[str] process_automation_job_arguments: The arguments to pass to the Process Automation job execution.
        :param pulumi.Input[str] process_automation_job_id: The ID of the Process Automation job to execute.
        :param pulumi.Input[str] process_automation_node_filter: The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        :param pulumi.Input[str] script: Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        AutomationActionsActionActionDataReferenceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            invocation_command=invocation_command,
            process_automation_job_arguments=process_automation_job_arguments,
            process_automation_job_id=process_automation_job_id,
            process_automation_node_filter=process_automation_node_filter,
            script=script,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             invocation_command: Optional[pulumi.Input[str]] = None,
             process_automation_job_arguments: Optional[pulumi.Input[str]] = None,
             process_automation_job_id: Optional[pulumi.Input[str]] = None,
             process_automation_node_filter: Optional[pulumi.Input[str]] = None,
             script: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if invocation_command is not None:
            _setter("invocation_command", invocation_command)
        if process_automation_job_arguments is not None:
            _setter("process_automation_job_arguments", process_automation_job_arguments)
        if process_automation_job_id is not None:
            _setter("process_automation_job_id", process_automation_job_id)
        if process_automation_node_filter is not None:
            _setter("process_automation_node_filter", process_automation_node_filter)
        if script is not None:
            _setter("script", script)

    @property
    @pulumi.getter(name="invocationCommand")
    def invocation_command(self) -> Optional[pulumi.Input[str]]:
        """
        The command to execute the script with.
        """
        return pulumi.get(self, "invocation_command")

    @invocation_command.setter
    def invocation_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "invocation_command", value)

    @property
    @pulumi.getter(name="processAutomationJobArguments")
    def process_automation_job_arguments(self) -> Optional[pulumi.Input[str]]:
        """
        The arguments to pass to the Process Automation job execution.
        """
        return pulumi.get(self, "process_automation_job_arguments")

    @process_automation_job_arguments.setter
    def process_automation_job_arguments(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "process_automation_job_arguments", value)

    @property
    @pulumi.getter(name="processAutomationJobId")
    def process_automation_job_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Process Automation job to execute.
        """
        return pulumi.get(self, "process_automation_job_id")

    @process_automation_job_id.setter
    def process_automation_job_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "process_automation_job_id", value)

    @property
    @pulumi.getter(name="processAutomationNodeFilter")
    def process_automation_node_filter(self) -> Optional[pulumi.Input[str]]:
        """
        The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        """
        return pulumi.get(self, "process_automation_node_filter")

    @process_automation_node_filter.setter
    def process_automation_node_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "process_automation_node_filter", value)

    @property
    @pulumi.getter
    def script(self) -> Optional[pulumi.Input[str]]:
        """
        Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        return pulumi.get(self, "script")

    @script.setter
    def script(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "script", value)


@pulumi.input_type
class EscalationPolicyRuleArgs:
    def __init__(__self__, *,
                 escalation_delay_in_minutes: pulumi.Input[int],
                 targets: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param pulumi.Input[str] id: A target ID
        """
        EscalationPolicyRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            escalation_delay_in_minutes=escalation_delay_in_minutes,
            targets=targets,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             escalation_delay_in_minutes: pulumi.Input[int],
             targets: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("escalation_delay_in_minutes", escalation_delay_in_minutes)
        _setter("targets", targets)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> pulumi.Input[int]:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @escalation_delay_in_minutes.setter
    def escalation_delay_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "escalation_delay_in_minutes", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class EscalationPolicyRuleTargetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: A target ID
        :param pulumi.Input[str] type: Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        EscalationPolicyRuleTargetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EventOrchestrationGlobalCatchAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs']):
        """
        :param pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs'] actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        EventOrchestrationGlobalCatchAllArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs']:
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationGlobalCatchAllActionsArgs']):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsArgs:
    def __init__(__self__, *,
                 annotate: Optional[pulumi.Input[str]] = None,
                 automation_action: Optional[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs']] = None,
                 drop_event: Optional[pulumi.Input[bool]] = None,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]]] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 suspend: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] annotate: Add this text as a note on the resulting incident.
        :param pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs'] automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param pulumi.Input[bool] drop_event: When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[str] priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param pulumi.Input[str] route_to: The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[bool] suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param pulumi.Input[int] suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        EventOrchestrationGlobalCatchAllActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotate=annotate,
            automation_action=automation_action,
            drop_event=drop_event,
            event_action=event_action,
            extractions=extractions,
            priority=priority,
            route_to=route_to,
            severity=severity,
            suppress=suppress,
            suspend=suspend,
            variables=variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotate: Optional[pulumi.Input[str]] = None,
             automation_action: Optional[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs']] = None,
             drop_event: Optional[pulumi.Input[bool]] = None,
             event_action: Optional[pulumi.Input[str]] = None,
             extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]]] = None,
             priority: Optional[pulumi.Input[str]] = None,
             route_to: Optional[pulumi.Input[str]] = None,
             severity: Optional[pulumi.Input[str]] = None,
             suppress: Optional[pulumi.Input[bool]] = None,
             suspend: Optional[pulumi.Input[int]] = None,
             variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if annotate is not None:
            _setter("annotate", annotate)
        if automation_action is not None:
            _setter("automation_action", automation_action)
        if drop_event is not None:
            _setter("drop_event", drop_event)
        if event_action is not None:
            _setter("event_action", event_action)
        if extractions is not None:
            _setter("extractions", extractions)
        if priority is not None:
            _setter("priority", priority)
        if route_to is not None:
            _setter("route_to", route_to)
        if severity is not None:
            _setter("severity", severity)
        if suppress is not None:
            _setter("suppress", suppress)
        if suspend is not None:
            _setter("suspend", suspend)
        if variables is not None:
            _setter("variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[pulumi.Input[str]]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @annotate.setter
    def annotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotate", value)

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs']]:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @automation_action.setter
    def automation_action(self, value: Optional[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionArgs']]):
        pulumi.set(self, "automation_action", value)

    @property
    @pulumi.getter(name="dropEvent")
    def drop_event(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        """
        return pulumi.get(self, "drop_event")

    @drop_event.setter
    def drop_event(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drop_event", value)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suspend", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsAutomationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auto_send: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param pulumi.Input[bool] auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        EventOrchestrationGlobalCatchAllActionsAutomationActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            url=url,
            auto_send=auto_send,
            headers=headers,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             url: pulumi.Input[str],
             auto_send: Optional[pulumi.Input[bool]] = None,
             headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("url", url)
        if auto_send is not None:
            _setter("auto_send", auto_send)
        if headers is not None:
            _setter("headers", headers)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @auto_send.setter
    def auto_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_send", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]]]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]]]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        EventOrchestrationGlobalCatchAllActionsExtractionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            regex=regex,
            source=source,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             regex: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             template: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if regex is not None:
            _setter("regex", regex)
        if source is not None:
            _setter("source", source)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class EventOrchestrationGlobalCatchAllActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationGlobalCatchAllActionsVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            path=path,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             path: pulumi.Input[str],
             type: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("path", path)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationGlobalSetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        EventOrchestrationGlobalSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class EventOrchestrationGlobalSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs'],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs'] actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param pulumi.Input[bool] disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        :param pulumi.Input[str] label: A description of this rule's purpose.
        """
        EventOrchestrationGlobalSetRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            conditions=conditions,
            disabled=disabled,
            id=id,
            label=label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs'],
             conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             label: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        if conditions is not None:
            _setter("conditions", conditions)
        if disabled is not None:
            _setter("disabled", disabled)
        if id is not None:
            _setter("id", id)
        if label is not None:
            _setter("label", label)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs']:
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationGlobalSetRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]]]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsArgs:
    def __init__(__self__, *,
                 annotate: Optional[pulumi.Input[str]] = None,
                 automation_action: Optional[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs']] = None,
                 drop_event: Optional[pulumi.Input[bool]] = None,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]]] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 suspend: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] annotate: Add this text as a note on the resulting incident.
        :param pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs'] automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param pulumi.Input[bool] drop_event: When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[str] priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param pulumi.Input[str] route_to: The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[bool] suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param pulumi.Input[int] suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        EventOrchestrationGlobalSetRuleActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotate=annotate,
            automation_action=automation_action,
            drop_event=drop_event,
            event_action=event_action,
            extractions=extractions,
            priority=priority,
            route_to=route_to,
            severity=severity,
            suppress=suppress,
            suspend=suspend,
            variables=variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotate: Optional[pulumi.Input[str]] = None,
             automation_action: Optional[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs']] = None,
             drop_event: Optional[pulumi.Input[bool]] = None,
             event_action: Optional[pulumi.Input[str]] = None,
             extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]]] = None,
             priority: Optional[pulumi.Input[str]] = None,
             route_to: Optional[pulumi.Input[str]] = None,
             severity: Optional[pulumi.Input[str]] = None,
             suppress: Optional[pulumi.Input[bool]] = None,
             suspend: Optional[pulumi.Input[int]] = None,
             variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if annotate is not None:
            _setter("annotate", annotate)
        if automation_action is not None:
            _setter("automation_action", automation_action)
        if drop_event is not None:
            _setter("drop_event", drop_event)
        if event_action is not None:
            _setter("event_action", event_action)
        if extractions is not None:
            _setter("extractions", extractions)
        if priority is not None:
            _setter("priority", priority)
        if route_to is not None:
            _setter("route_to", route_to)
        if severity is not None:
            _setter("severity", severity)
        if suppress is not None:
            _setter("suppress", suppress)
        if suspend is not None:
            _setter("suspend", suspend)
        if variables is not None:
            _setter("variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[pulumi.Input[str]]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @annotate.setter
    def annotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotate", value)

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs']]:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @automation_action.setter
    def automation_action(self, value: Optional[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionArgs']]):
        pulumi.set(self, "automation_action", value)

    @property
    @pulumi.getter(name="dropEvent")
    def drop_event(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        """
        return pulumi.get(self, "drop_event")

    @drop_event.setter
    def drop_event(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "drop_event", value)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suspend", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsAutomationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auto_send: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param pulumi.Input[bool] auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        EventOrchestrationGlobalSetRuleActionsAutomationActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            url=url,
            auto_send=auto_send,
            headers=headers,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             url: pulumi.Input[str],
             auto_send: Optional[pulumi.Input[bool]] = None,
             headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("url", url)
        if auto_send is not None:
            _setter("auto_send", auto_send)
        if headers is not None:
            _setter("headers", headers)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @auto_send.setter
    def auto_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_send", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]]]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]]]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        EventOrchestrationGlobalSetRuleActionsExtractionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            regex=regex,
            source=source,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             regex: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             template: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if regex is not None:
            _setter("regex", regex)
        if source is not None:
            _setter("source", source)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class EventOrchestrationGlobalSetRuleActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationGlobalSetRuleActionsVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            path=path,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             path: pulumi.Input[str],
             type: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("path", path)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationGlobalSetRuleConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        EventOrchestrationGlobalSetRuleConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class EventOrchestrationIntegrationArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] id: ID of the integration
        """
        EventOrchestrationIntegrationArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            label=label,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             label: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if label is not None:
            _setter("label", label)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgs']]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationIntegrationParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class EventOrchestrationIntegrationParameterArgs:
    def __init__(__self__, *,
                 routing_key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] routing_key: Routing key that routes to this Orchestration.
        :param pulumi.Input[str] type: Type of the routing key. `global` is the default type.
        """
        EventOrchestrationIntegrationParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            routing_key=routing_key,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             routing_key: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if routing_key is not None:
            _setter("routing_key", routing_key)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[pulumi.Input[str]]:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @routing_key.setter
    def routing_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "routing_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class EventOrchestrationRouterCatchAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs']):
        """
        :param pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs'] actions: These are the actions that will be taken to change the resulting alert and incident.
        """
        EventOrchestrationRouterCatchAllArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs']:
        """
        These are the actions that will be taken to change the resulting alert and incident.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationRouterCatchAllActionsArgs']):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class EventOrchestrationRouterCatchAllActionsArgs:
    def __init__(__self__, *,
                 route_to: pulumi.Input[str]):
        """
        :param pulumi.Input[str] route_to: The ID of the target Service for the resulting alert.
        """
        EventOrchestrationRouterCatchAllActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            route_to=route_to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             route_to: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("route_to", route_to)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> pulumi.Input[str]:
        """
        The ID of the target Service for the resulting alert.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: pulumi.Input[str]):
        pulumi.set(self, "route_to", value)


@pulumi.input_type
class EventOrchestrationRouterSetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] id: ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        EventOrchestrationRouterSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class EventOrchestrationRouterSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs'],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs'] actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        :param pulumi.Input[bool] disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param pulumi.Input[str] id: ID of the `start` set. Router supports only one set and it's id has to be `start`
        :param pulumi.Input[str] label: A description of this rule's purpose.
        """
        EventOrchestrationRouterSetRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            conditions=conditions,
            disabled=disabled,
            id=id,
            label=label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs'],
             conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             label: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        if conditions is not None:
            _setter("conditions", conditions)
        if disabled is not None:
            _setter("disabled", disabled)
        if id is not None:
            _setter("id", id)
        if label is not None:
            _setter("label", label)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs']:
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationRouterSetRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]]]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationRouterSetRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class EventOrchestrationRouterSetRuleActionsArgs:
    def __init__(__self__, *,
                 route_to: pulumi.Input[str]):
        """
        :param pulumi.Input[str] route_to: The ID of the target Service for the resulting alert.
        """
        EventOrchestrationRouterSetRuleActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            route_to=route_to,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             route_to: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("route_to", route_to)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> pulumi.Input[str]:
        """
        The ID of the target Service for the resulting alert.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: pulumi.Input[str]):
        pulumi.set(self, "route_to", value)


@pulumi.input_type
class EventOrchestrationRouterSetRuleConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        EventOrchestrationRouterSetRuleConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class EventOrchestrationServiceCatchAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs']):
        """
        :param pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs'] actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        EventOrchestrationServiceCatchAllArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs']:
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationServiceCatchAllActionsArgs']):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsArgs:
    def __init__(__self__, *,
                 annotate: Optional[pulumi.Input[str]] = None,
                 automation_action: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs']] = None,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]]] = None,
                 pagerduty_automation_action: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs']] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 suspend: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] annotate: Add this text as a note on the resulting incident.
        :param pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs'] automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs'] pagerduty_automation_action: Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        :param pulumi.Input[str] priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param pulumi.Input[str] route_to: The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[bool] suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param pulumi.Input[int] suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        EventOrchestrationServiceCatchAllActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotate=annotate,
            automation_action=automation_action,
            event_action=event_action,
            extractions=extractions,
            pagerduty_automation_action=pagerduty_automation_action,
            priority=priority,
            route_to=route_to,
            severity=severity,
            suppress=suppress,
            suspend=suspend,
            variables=variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotate: Optional[pulumi.Input[str]] = None,
             automation_action: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs']] = None,
             event_action: Optional[pulumi.Input[str]] = None,
             extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]]] = None,
             pagerduty_automation_action: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs']] = None,
             priority: Optional[pulumi.Input[str]] = None,
             route_to: Optional[pulumi.Input[str]] = None,
             severity: Optional[pulumi.Input[str]] = None,
             suppress: Optional[pulumi.Input[bool]] = None,
             suspend: Optional[pulumi.Input[int]] = None,
             variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if annotate is not None:
            _setter("annotate", annotate)
        if automation_action is not None:
            _setter("automation_action", automation_action)
        if event_action is not None:
            _setter("event_action", event_action)
        if extractions is not None:
            _setter("extractions", extractions)
        if pagerduty_automation_action is not None:
            _setter("pagerduty_automation_action", pagerduty_automation_action)
        if priority is not None:
            _setter("priority", priority)
        if route_to is not None:
            _setter("route_to", route_to)
        if severity is not None:
            _setter("severity", severity)
        if suppress is not None:
            _setter("suppress", suppress)
        if suspend is not None:
            _setter("suspend", suspend)
        if variables is not None:
            _setter("variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[pulumi.Input[str]]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @annotate.setter
    def annotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotate", value)

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs']]:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @automation_action.setter
    def automation_action(self, value: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionArgs']]):
        pulumi.set(self, "automation_action", value)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter(name="pagerdutyAutomationAction")
    def pagerduty_automation_action(self) -> Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs']]:
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        """
        return pulumi.get(self, "pagerduty_automation_action")

    @pagerduty_automation_action.setter
    def pagerduty_automation_action(self, value: Optional[pulumi.Input['EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs']]):
        pulumi.set(self, "pagerduty_automation_action", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suspend", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsAutomationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auto_send: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param pulumi.Input[bool] auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        EventOrchestrationServiceCatchAllActionsAutomationActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            url=url,
            auto_send=auto_send,
            headers=headers,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             url: pulumi.Input[str],
             auto_send: Optional[pulumi.Input[bool]] = None,
             headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("url", url)
        if auto_send is not None:
            _setter("auto_send", auto_send)
        if headers is not None:
            _setter("headers", headers)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @auto_send.setter
    def auto_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_send", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]]]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]]]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        EventOrchestrationServiceCatchAllActionsExtractionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            regex=regex,
            source=source,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             regex: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             template: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if regex is not None:
            _setter("regex", regex)
        if source is not None:
            _setter("source", source)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs:
    def __init__(__self__, *,
                 action_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action_id: Id of the Process Automation action to be triggered.
        """
        EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_id=action_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_id", action_id)

    @property
    @pulumi.getter(name="actionId")
    def action_id(self) -> pulumi.Input[str]:
        """
        Id of the Process Automation action to be triggered.
        """
        return pulumi.get(self, "action_id")

    @action_id.setter
    def action_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_id", value)


@pulumi.input_type
class EventOrchestrationServiceCatchAllActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationServiceCatchAllActionsVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            path=path,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             path: pulumi.Input[str],
             type: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("path", path)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationServiceSetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        EventOrchestrationServiceSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs'],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs'] actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param pulumi.Input[bool] disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        :param pulumi.Input[str] label: A description of this rule's purpose.
        """
        EventOrchestrationServiceSetRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            conditions=conditions,
            disabled=disabled,
            id=id,
            label=label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs'],
             conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             label: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        if conditions is not None:
            _setter("conditions", conditions)
        if disabled is not None:
            _setter("disabled", disabled)
        if id is not None:
            _setter("id", id)
        if label is not None:
            _setter("label", label)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs']:
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationServiceSetRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]]]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsArgs:
    def __init__(__self__, *,
                 annotate: Optional[pulumi.Input[str]] = None,
                 automation_action: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs']] = None,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]]] = None,
                 pagerduty_automation_action: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs']] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 suspend: Optional[pulumi.Input[int]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] annotate: Add this text as a note on the resulting incident.
        :param pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs'] automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs'] pagerduty_automation_action: Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        :param pulumi.Input[str] priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param pulumi.Input[str] route_to: The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[bool] suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param pulumi.Input[int] suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        EventOrchestrationServiceSetRuleActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotate=annotate,
            automation_action=automation_action,
            event_action=event_action,
            extractions=extractions,
            pagerduty_automation_action=pagerduty_automation_action,
            priority=priority,
            route_to=route_to,
            severity=severity,
            suppress=suppress,
            suspend=suspend,
            variables=variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotate: Optional[pulumi.Input[str]] = None,
             automation_action: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs']] = None,
             event_action: Optional[pulumi.Input[str]] = None,
             extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]]] = None,
             pagerduty_automation_action: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs']] = None,
             priority: Optional[pulumi.Input[str]] = None,
             route_to: Optional[pulumi.Input[str]] = None,
             severity: Optional[pulumi.Input[str]] = None,
             suppress: Optional[pulumi.Input[bool]] = None,
             suspend: Optional[pulumi.Input[int]] = None,
             variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if annotate is not None:
            _setter("annotate", annotate)
        if automation_action is not None:
            _setter("automation_action", automation_action)
        if event_action is not None:
            _setter("event_action", event_action)
        if extractions is not None:
            _setter("extractions", extractions)
        if pagerduty_automation_action is not None:
            _setter("pagerduty_automation_action", pagerduty_automation_action)
        if priority is not None:
            _setter("priority", priority)
        if route_to is not None:
            _setter("route_to", route_to)
        if severity is not None:
            _setter("severity", severity)
        if suppress is not None:
            _setter("suppress", suppress)
        if suspend is not None:
            _setter("suspend", suspend)
        if variables is not None:
            _setter("variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[pulumi.Input[str]]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @annotate.setter
    def annotate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "annotate", value)

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs']]:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @automation_action.setter
    def automation_action(self, value: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionArgs']]):
        pulumi.set(self, "automation_action", value)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter(name="pagerdutyAutomationAction")
    def pagerduty_automation_action(self) -> Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs']]:
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        """
        return pulumi.get(self, "pagerduty_automation_action")

    @pagerduty_automation_action.setter
    def pagerduty_automation_action(self, value: Optional[pulumi.Input['EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs']]):
        pulumi.set(self, "pagerduty_automation_action", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def suspend(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @suspend.setter
    def suspend(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "suspend", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsAutomationActionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 url: pulumi.Input[str],
                 auto_send: Optional[pulumi.Input[bool]] = None,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param pulumi.Input[bool] auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        EventOrchestrationServiceSetRuleActionsAutomationActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            url=url,
            auto_send=auto_send,
            headers=headers,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             url: pulumi.Input[str],
             auto_send: Optional[pulumi.Input[bool]] = None,
             headers: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("url", url)
        if auto_send is not None:
            _setter("auto_send", auto_send)
        if headers is not None:
            _setter("headers", headers)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @auto_send.setter
    def auto_send(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_send", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]]]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs']]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]]]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Name to identify the parameter
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        EventOrchestrationServiceSetRuleActionsExtractionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            regex=regex,
            source=source,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             regex: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             template: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if regex is not None:
            _setter("regex", regex)
        if source is not None:
            _setter("source", source)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs:
    def __init__(__self__, *,
                 action_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] action_id: Id of the Process Automation action to be triggered.
        """
        EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action_id=action_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action_id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action_id", action_id)

    @property
    @pulumi.getter(name="actionId")
    def action_id(self) -> pulumi.Input[str]:
        """
        Id of the Process Automation action to be triggered.
        """
        return pulumi.get(self, "action_id")

    @action_id.setter
    def action_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "action_id", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationServiceSetRuleActionsVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            path=path,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             path: pulumi.Input[str],
             type: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("path", path)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationServiceSetRuleConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        EventOrchestrationServiceSetRuleConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class EventOrchestrationUnroutedCatchAllArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs']):
        """
        :param pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs'] actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        EventOrchestrationUnroutedCatchAllArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs']:
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationUnroutedCatchAllActionsArgs']):
        pulumi.set(self, "actions", value)


@pulumi.input_type
class EventOrchestrationUnroutedCatchAllActionsArgs:
    def __init__(__self__, *,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 suppress: Optional[pulumi.Input[bool]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        EventOrchestrationUnroutedCatchAllActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_action=event_action,
            extractions=extractions,
            severity=severity,
            suppress=suppress,
            variables=variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_action: Optional[pulumi.Input[str]] = None,
             extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]]] = None,
             severity: Optional[pulumi.Input[str]] = None,
             suppress: Optional[pulumi.Input[bool]] = None,
             variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if event_action is not None:
            _setter("event_action", event_action)
        if extractions is not None:
            _setter("extractions", extractions)
        if severity is not None:
            _setter("severity", severity)
        if suppress is not None:
            _setter("suppress", suppress)
        if variables is not None:
            _setter("variables", variables)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def suppress(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "suppress")

    @suppress.setter
    def suppress(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "suppress", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedCatchAllActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class EventOrchestrationUnroutedCatchAllActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        EventOrchestrationUnroutedCatchAllActionsExtractionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            regex=regex,
            source=source,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             regex: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             template: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if regex is not None:
            _setter("regex", regex)
        if source is not None:
            _setter("source", source)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class EventOrchestrationUnroutedCatchAllActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationUnroutedCatchAllActionsVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            path=path,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             path: pulumi.Input[str],
             type: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("path", path)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationUnroutedSetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleArgs']]]] = None):
        """
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        EventOrchestrationUnroutedSetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            rules=rules,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             rules: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        if rules is not None:
            _setter("rules", rules)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleArgs']]]]:
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleArgs']]]]):
        pulumi.set(self, "rules", value)


@pulumi.input_type
class EventOrchestrationUnroutedSetRuleArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs'],
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]]] = None,
                 disabled: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 label: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs'] actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param pulumi.Input[bool] disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param pulumi.Input[str] id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        :param pulumi.Input[str] label: A description of this rule's purpose.
        """
        EventOrchestrationUnroutedSetRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            actions=actions,
            conditions=conditions,
            disabled=disabled,
            id=id,
            label=label,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             actions: pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs'],
             conditions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]]] = None,
             disabled: Optional[pulumi.Input[bool]] = None,
             id: Optional[pulumi.Input[str]] = None,
             label: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("actions", actions)
        if conditions is not None:
            _setter("conditions", conditions)
        if disabled is not None:
            _setter("disabled", disabled)
        if id is not None:
            _setter("id", id)
        if label is not None:
            _setter("label", label)

    @property
    @pulumi.getter
    def actions(self) -> pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs']:
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input['EventOrchestrationUnroutedSetRuleActionsArgs']):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]]]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)


@pulumi.input_type
class EventOrchestrationUnroutedSetRuleActionsArgs:
    def __init__(__self__, *,
                 event_action: Optional[pulumi.Input[str]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]]] = None,
                 route_to: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[str]] = None,
                 variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]]] = None):
        """
        :param pulumi.Input[str] event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param pulumi.Input[str] route_to: The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
        :param pulumi.Input[str] severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        EventOrchestrationUnroutedSetRuleActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_action=event_action,
            extractions=extractions,
            route_to=route_to,
            severity=severity,
            variables=variables,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_action: Optional[pulumi.Input[str]] = None,
             extractions: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]]] = None,
             route_to: Optional[pulumi.Input[str]] = None,
             severity: Optional[pulumi.Input[str]] = None,
             variables: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if event_action is not None:
            _setter("event_action", event_action)
        if extractions is not None:
            _setter("extractions", extractions)
        if route_to is not None:
            _setter("route_to", route_to)
        if severity is not None:
            _setter("severity", severity)
        if variables is not None:
            _setter("variables", variables)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[pulumi.Input[str]]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @event_action.setter
    def event_action(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_action", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]]]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @route_to.setter
    def route_to(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "route_to", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[str]]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def variables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]]]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")

    @variables.setter
    def variables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EventOrchestrationUnroutedSetRuleActionsVariableArgs']]]]):
        pulumi.set(self, "variables", value)


@pulumi.input_type
class EventOrchestrationUnroutedSetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 target: pulumi.Input[str],
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param pulumi.Input[str] regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param pulumi.Input[str] template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        EventOrchestrationUnroutedSetRuleActionsExtractionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            target=target,
            regex=regex,
            source=source,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             target: pulumi.Input[str],
             regex: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             template: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("target", target)
        if regex is not None:
            _setter("regex", regex)
        if source is not None:
            _setter("source", source)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[str]:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[str]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class EventOrchestrationUnroutedSetRuleActionsVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 path: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the variable
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        :param pulumi.Input[str] type: Only `regex` is supported
        :param pulumi.Input[str] value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        EventOrchestrationUnroutedSetRuleActionsVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            path=path,
            type=type,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             path: pulumi.Input[str],
             type: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("path", path)
        _setter("type", type)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class EventOrchestrationUnroutedSetRuleConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        EventOrchestrationUnroutedSetRuleConditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            expression=expression,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             expression: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


@pulumi.input_type
class IncidentWorkflowStepArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 name: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 inputs: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]]] = None):
        """
        :param pulumi.Input[str] action: The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        :param pulumi.Input[str] name: The name of the workflow step.
        :param pulumi.Input[str] id: The ID of the incident workflow.
        :param pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]] inputs: The list of inputs for the workflow action.
        """
        IncidentWorkflowStepArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            name=name,
            id=id,
            inputs=inputs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: pulumi.Input[str],
             name: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             inputs: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("name", name)
        if id is not None:
            _setter("id", id)
        if inputs is not None:
            _setter("inputs", inputs)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the workflow step.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the incident workflow.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]]]:
        """
        The list of inputs for the workflow action.
        """
        return pulumi.get(self, "inputs")

    @inputs.setter
    def inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['IncidentWorkflowStepInputArgs']]]]):
        pulumi.set(self, "inputs", value)


@pulumi.input_type
class IncidentWorkflowStepInputArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str],
                 generated: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] name: The name of the input.
        :param pulumi.Input[str] value: The value of the input.
        """
        IncidentWorkflowStepInputArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
            generated=generated,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             value: pulumi.Input[str],
             generated: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)
        if generated is not None:
            _setter("generated", generated)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the input.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the input.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def generated(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "generated")

    @generated.setter
    def generated(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "generated", value)


@pulumi.input_type
class ProviderUseAppOauthScopedTokenArgs:
    def __init__(__self__, *,
                 pd_client_id: pulumi.Input[str],
                 pd_client_secret: pulumi.Input[str],
                 pd_subdomain: pulumi.Input[str]):
        ProviderUseAppOauthScopedTokenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pd_client_id=pd_client_id,
            pd_client_secret=pd_client_secret,
            pd_subdomain=pd_subdomain,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pd_client_id: pulumi.Input[str],
             pd_client_secret: pulumi.Input[str],
             pd_subdomain: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("pd_client_id", pd_client_id)
        _setter("pd_client_secret", pd_client_secret)
        _setter("pd_subdomain", pd_subdomain)

    @property
    @pulumi.getter(name="pdClientId")
    def pd_client_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pd_client_id")

    @pd_client_id.setter
    def pd_client_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "pd_client_id", value)

    @property
    @pulumi.getter(name="pdClientSecret")
    def pd_client_secret(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pd_client_secret")

    @pd_client_secret.setter
    def pd_client_secret(self, value: pulumi.Input[str]):
        pulumi.set(self, "pd_client_secret", value)

    @property
    @pulumi.getter(name="pdSubdomain")
    def pd_subdomain(self) -> pulumi.Input[str]:
        return pulumi.get(self, "pd_subdomain")

    @pd_subdomain.setter
    def pd_subdomain(self, value: pulumi.Input[str]):
        pulumi.set(self, "pd_subdomain", value)


@pulumi.input_type
class ResponsePlayResponderArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 escalation_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 num_loops: Optional[pulumi.Input[int]] = None,
                 on_call_handoff_notifications: Optional[pulumi.Input[str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]]] = None,
                 teams: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Description of escalation policy
        :param pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]] escalation_rules: The escalation rules
        :param pulumi.Input[str] id: ID of the user defined as the responder
        :param pulumi.Input[str] name: Name of the escalation policy
        :param pulumi.Input[int] num_loops: The number of times the escalation policy will repeat after reaching the end of its escalation.
        :param pulumi.Input[str] on_call_handoff_notifications: Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        :param pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]] services: There can be multiple services associated with a policy.
        :param pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]] teams: Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        :param pulumi.Input[str] type: Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
        ResponsePlayResponderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            description=description,
            escalation_rules=escalation_rules,
            id=id,
            name=name,
            num_loops=num_loops,
            on_call_handoff_notifications=on_call_handoff_notifications,
            services=services,
            teams=teams,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             description: Optional[pulumi.Input[str]] = None,
             escalation_rules: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]]] = None,
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             num_loops: Optional[pulumi.Input[int]] = None,
             on_call_handoff_notifications: Optional[pulumi.Input[str]] = None,
             services: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]]] = None,
             teams: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if description is not None:
            _setter("description", description)
        if escalation_rules is not None:
            _setter("escalation_rules", escalation_rules)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if num_loops is not None:
            _setter("num_loops", num_loops)
        if on_call_handoff_notifications is not None:
            _setter("on_call_handoff_notifications", on_call_handoff_notifications)
        if services is not None:
            _setter("services", services)
        if teams is not None:
            _setter("teams", teams)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of escalation policy
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="escalationRules")
    def escalation_rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]]]:
        """
        The escalation rules
        """
        return pulumi.get(self, "escalation_rules")

    @escalation_rules.setter
    def escalation_rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleArgs']]]]):
        pulumi.set(self, "escalation_rules", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the escalation policy
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="numLoops")
    def num_loops(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times the escalation policy will repeat after reaching the end of its escalation.
        """
        return pulumi.get(self, "num_loops")

    @num_loops.setter
    def num_loops(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "num_loops", value)

    @property
    @pulumi.getter(name="onCallHandoffNotifications")
    def on_call_handoff_notifications(self) -> Optional[pulumi.Input[str]]:
        """
        Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        """
        return pulumi.get(self, "on_call_handoff_notifications")

    @on_call_handoff_notifications.setter
    def on_call_handoff_notifications(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "on_call_handoff_notifications", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]]]:
        """
        There can be multiple services associated with a policy.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderServiceArgs']]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def teams(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]]]:
        """
        Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        """
        return pulumi.get(self, "teams")

    @teams.setter
    def teams(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderTeamArgs']]]]):
        pulumi.set(self, "teams", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ResponsePlayResponderEscalationRuleArgs:
    def __init__(__self__, *,
                 targets: pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]],
                 escalation_delay_in_minutes: Optional[pulumi.Input[int]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]] targets: The targets an incident should be assigned to upon reaching this rule.
        :param pulumi.Input[int] escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param pulumi.Input[str] id: ID of the user defined as the responder
        """
        ResponsePlayResponderEscalationRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            targets=targets,
            escalation_delay_in_minutes=escalation_delay_in_minutes,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             targets: pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]],
             escalation_delay_in_minutes: Optional[pulumi.Input[int]] = None,
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("targets", targets)
        if escalation_delay_in_minutes is not None:
            _setter("escalation_delay_in_minutes", escalation_delay_in_minutes)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]]:
        """
        The targets an incident should be assigned to upon reaching this rule.
        """
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input['ResponsePlayResponderEscalationRuleTargetArgs']]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @escalation_delay_in_minutes.setter
    def escalation_delay_in_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "escalation_delay_in_minutes", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ResponsePlayResponderEscalationRuleTargetArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the user defined as the responder
        :param pulumi.Input[str] type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        ResponsePlayResponderEscalationRuleTargetArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ResponsePlayResponderServiceArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the user defined as the responder
        :param pulumi.Input[str] type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        ResponsePlayResponderServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ResponsePlayResponderTeamArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: A string that determines the schema of the object. If not set, the default value is "response_play".
        :param pulumi.Input[str] id: ID of the user defined as the responder
        """
        ResponsePlayResponderTeamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ResponsePlaySubscriberArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: ID of the user defined as the responder
        :param pulumi.Input[str] type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        ResponsePlaySubscriberArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if id is not None:
            _setter("id", id)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RulesetRuleActionsArgs:
    def __init__(__self__, *,
                 annotates: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]] = None,
                 event_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]] = None,
                 priorities: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]] = None,
                 suppresses: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]] = None,
                 suspends: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]] annotates: Note added to the event.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]] priorities: The ID of the priority applied to the event.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]] routes: The ID of the service where the event will be routed.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        RulesetRuleActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotates=annotates,
            event_actions=event_actions,
            extractions=extractions,
            priorities=priorities,
            routes=routes,
            severities=severities,
            suppresses=suppresses,
            suspends=suspends,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotates: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]] = None,
             event_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]] = None,
             extractions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]] = None,
             priorities: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]] = None,
             routes: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]] = None,
             severities: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]] = None,
             suppresses: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]] = None,
             suspends: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if annotates is not None:
            _setter("annotates", annotates)
        if event_actions is not None:
            _setter("event_actions", event_actions)
        if extractions is not None:
            _setter("extractions", extractions)
        if priorities is not None:
            _setter("priorities", priorities)
        if routes is not None:
            _setter("routes", routes)
        if severities is not None:
            _setter("severities", severities)
        if suppresses is not None:
            _setter("suppresses", suppresses)
        if suspends is not None:
            _setter("suspends", suspends)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @annotates.setter
    def annotates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]]):
        pulumi.set(self, "annotates", value)

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @event_actions.setter
    def event_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]]):
        pulumi.set(self, "event_actions", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @priorities.setter
    def priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]]):
        pulumi.set(self, "priorities", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]]:
        """
        The ID of the service where the event will be routed.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]]):
        pulumi.set(self, "severities", value)

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        """
        return pulumi.get(self, "suppresses")

    @suppresses.setter
    def suppresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]]):
        pulumi.set(self, "suppresses", value)

    @property
    @pulumi.getter
    def suspends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]]]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        return pulumi.get(self, "suspends")

    @suspends.setter
    def suspends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuspendArgs']]]]):
        pulumi.set(self, "suspends", value)


@pulumi.input_type
class RulesetRuleActionsAnnotateArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleActionsAnnotateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsEventActionArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleActionsEventActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
               
               *- **OR** -*
        :param pulumi.Input[str] source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param pulumi.Input[str] target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
               
               *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        :param pulumi.Input[str] template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        RulesetRuleActionsExtractionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex=regex,
            source=source,
            target=target,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             target: Optional[pulumi.Input[str]] = None,
             template: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if regex is not None:
            _setter("regex", regex)
        if source is not None:
            _setter("source", source)
        if target is not None:
            _setter("target", target)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        *- **OR** -*
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.

        *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class RulesetRuleActionsPriorityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleActionsPriorityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsRouteArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleActionsRouteArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsSeverityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleActionsSeverityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsSuppressArgs:
    def __init__(__self__, *,
                 threshold_time_amount: Optional[pulumi.Input[int]] = None,
                 threshold_time_unit: Optional[pulumi.Input[str]] = None,
                 threshold_value: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        :param pulumi.Input[str] threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param pulumi.Input[int] threshold_value: The number of alerts that should be suppressed. Must be greater than 0.
        :param pulumi.Input[bool] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleActionsSuppressArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            threshold_time_amount=threshold_time_amount,
            threshold_time_unit=threshold_time_unit,
            threshold_value=threshold_value,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             threshold_time_amount: Optional[pulumi.Input[int]] = None,
             threshold_time_unit: Optional[pulumi.Input[str]] = None,
             threshold_value: Optional[pulumi.Input[int]] = None,
             value: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if threshold_time_amount is not None:
            _setter("threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            _setter("threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            _setter("threshold_value", threshold_value)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[pulumi.Input[int]]:
        """
        The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_time_amount")

    @threshold_time_amount.setter
    def threshold_time_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_time_amount", value)

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @threshold_time_unit.setter
    def threshold_time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_time_unit", value)

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[pulumi.Input[int]]:
        """
        The number of alerts that should be suppressed. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_value")

    @threshold_value.setter
    def threshold_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsSuspendArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleActionsSuspendArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleConditionsArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 subconditions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]] subconditions: List of sub-conditions that define the condition.
        """
        RulesetRuleConditionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            subconditions=subconditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[str]] = None,
             subconditions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if operator is not None:
            _setter("operator", operator)
        if subconditions is not None:
            _setter("subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")

    @subconditions.setter
    def subconditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]]):
        pulumi.set(self, "subconditions", value)


@pulumi.input_type
class RulesetRuleConditionsSubconditionArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        RulesetRuleConditionsSubconditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if operator is not None:
            _setter("operator", operator)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class RulesetRuleConditionsSubconditionParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleConditionsSubconditionParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if path is not None:
            _setter("path", path)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleTimeFrameArgs:
    def __init__(__self__, *,
                 active_betweens: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]] = None,
                 scheduled_weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]] active_betweens: Values for executing the rule during a specific time period.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        RulesetRuleTimeFrameArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active_betweens=active_betweens,
            scheduled_weeklies=scheduled_weeklies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active_betweens: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]] = None,
             scheduled_weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if active_betweens is not None:
            _setter("active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            _setter("scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @active_betweens.setter
    def active_betweens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]]):
        pulumi.set(self, "active_betweens", value)

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")

    @scheduled_weeklies.setter
    def scheduled_weeklies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]]):
        pulumi.set(self, "scheduled_weeklies", value)


@pulumi.input_type
class RulesetRuleTimeFrameActiveBetweenArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] start_time: A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        RulesetRuleTimeFrameActiveBetweenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time=end_time,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time: Optional[pulumi.Input[int]] = None,
             start_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if end_time is not None:
            _setter("end_time", end_time)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class RulesetRuleTimeFrameScheduledWeeklyArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] duration: Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        :param pulumi.Input[int] start_time: A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        :param pulumi.Input[str] timezone: [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        RulesetRuleTimeFrameScheduledWeeklyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
            start_time=start_time,
            timezone=timezone,
            weekdays=weekdays,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: Optional[pulumi.Input[int]] = None,
             start_time: Optional[pulumi.Input[int]] = None,
             timezone: Optional[pulumi.Input[str]] = None,
             weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if duration is not None:
            _setter("duration", duration)
        if start_time is not None:
            _setter("start_time", start_time)
        if timezone is not None:
            _setter("timezone", timezone)
        if weekdays is not None:
            _setter("weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weekdays", value)


@pulumi.input_type
class RulesetRuleVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleVariableParameterArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        RulesetRuleVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleVariableParameterArgs']]]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if parameters is not None:
            _setter("parameters", parameters)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleVariableParameterArgs']]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleVariableParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RulesetRuleVariableParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        RulesetRuleVariableParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if path is not None:
            _setter("path", path)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetTeamArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the ruleset.
        """
        RulesetTeamArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the ruleset.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ScheduleFinalScheduleArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 rendered_coverage_percentage: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the schedule.
        """
        ScheduleFinalScheduleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            rendered_coverage_percentage=rendered_coverage_percentage,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             rendered_coverage_percentage: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if rendered_coverage_percentage is not None:
            _setter("rendered_coverage_percentage", rendered_coverage_percentage)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schedule.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="renderedCoveragePercentage")
    def rendered_coverage_percentage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rendered_coverage_percentage")

    @rendered_coverage_percentage.setter
    def rendered_coverage_percentage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rendered_coverage_percentage", value)


@pulumi.input_type
class ScheduleLayerArgs:
    def __init__(__self__, *,
                 rotation_turn_length_seconds: pulumi.Input[int],
                 rotation_virtual_start: pulumi.Input[str],
                 start: pulumi.Input[str],
                 users: pulumi.Input[Sequence[pulumi.Input[str]]],
                 end: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 rendered_coverage_percentage: Optional[pulumi.Input[str]] = None,
                 restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]] = None):
        """
        :param pulumi.Input[int] rotation_turn_length_seconds: The duration of each on-call shift in `seconds`.
        :param pulumi.Input[str] rotation_virtual_start: The effective start time of the schedule layer. This can be before the start time of the schedule.
        :param pulumi.Input[str] start: The start time of the schedule layer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] users: The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        :param pulumi.Input[str] end: The end time of the schedule layer. If not specified, the layer does not end.
        :param pulumi.Input[str] id: The ID of the schedule.
        :param pulumi.Input[str] name: The name of the schedule layer.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]] restrictions: A schedule layer restriction block. Restriction blocks documented below.
        """
        ScheduleLayerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            rotation_turn_length_seconds=rotation_turn_length_seconds,
            rotation_virtual_start=rotation_virtual_start,
            start=start,
            users=users,
            end=end,
            id=id,
            name=name,
            rendered_coverage_percentage=rendered_coverage_percentage,
            restrictions=restrictions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             rotation_turn_length_seconds: pulumi.Input[int],
             rotation_virtual_start: pulumi.Input[str],
             start: pulumi.Input[str],
             users: pulumi.Input[Sequence[pulumi.Input[str]]],
             end: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             name: Optional[pulumi.Input[str]] = None,
             rendered_coverage_percentage: Optional[pulumi.Input[str]] = None,
             restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("rotation_turn_length_seconds", rotation_turn_length_seconds)
        _setter("rotation_virtual_start", rotation_virtual_start)
        _setter("start", start)
        _setter("users", users)
        if end is not None:
            _setter("end", end)
        if id is not None:
            _setter("id", id)
        if name is not None:
            _setter("name", name)
        if rendered_coverage_percentage is not None:
            _setter("rendered_coverage_percentage", rendered_coverage_percentage)
        if restrictions is not None:
            _setter("restrictions", restrictions)

    @property
    @pulumi.getter(name="rotationTurnLengthSeconds")
    def rotation_turn_length_seconds(self) -> pulumi.Input[int]:
        """
        The duration of each on-call shift in `seconds`.
        """
        return pulumi.get(self, "rotation_turn_length_seconds")

    @rotation_turn_length_seconds.setter
    def rotation_turn_length_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "rotation_turn_length_seconds", value)

    @property
    @pulumi.getter(name="rotationVirtualStart")
    def rotation_virtual_start(self) -> pulumi.Input[str]:
        """
        The effective start time of the schedule layer. This can be before the start time of the schedule.
        """
        return pulumi.get(self, "rotation_virtual_start")

    @rotation_virtual_start.setter
    def rotation_virtual_start(self, value: pulumi.Input[str]):
        pulumi.set(self, "rotation_virtual_start", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The start time of the schedule layer.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter
    def users(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        The end time of the schedule layer. If not specified, the layer does not end.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the schedule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schedule layer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="renderedCoveragePercentage")
    def rendered_coverage_percentage(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "rendered_coverage_percentage")

    @rendered_coverage_percentage.setter
    def rendered_coverage_percentage(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rendered_coverage_percentage", value)

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]]:
        """
        A schedule layer restriction block. Restriction blocks documented below.
        """
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]]):
        pulumi.set(self, "restrictions", value)


@pulumi.input_type
class ScheduleLayerRestrictionArgs:
    def __init__(__self__, *,
                 duration_seconds: pulumi.Input[int],
                 start_time_of_day: pulumi.Input[str],
                 type: pulumi.Input[str],
                 start_day_of_week: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] duration_seconds: The duration of the restriction in `seconds`.
        :param pulumi.Input[str] start_time_of_day: The start time in `HH:mm:ss` format.
        :param pulumi.Input[str] type: Can be `daily_restriction` or `weekly_restriction`.
        :param pulumi.Input[int] start_day_of_week: Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        ScheduleLayerRestrictionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration_seconds=duration_seconds,
            start_time_of_day=start_time_of_day,
            type=type,
            start_day_of_week=start_day_of_week,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration_seconds: pulumi.Input[int],
             start_time_of_day: pulumi.Input[str],
             type: pulumi.Input[str],
             start_day_of_week: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("duration_seconds", duration_seconds)
        _setter("start_time_of_day", start_time_of_day)
        _setter("type", type)
        if start_day_of_week is not None:
            _setter("start_day_of_week", start_day_of_week)

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> pulumi.Input[int]:
        """
        The duration of the restriction in `seconds`.
        """
        return pulumi.get(self, "duration_seconds")

    @duration_seconds.setter
    def duration_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "duration_seconds", value)

    @property
    @pulumi.getter(name="startTimeOfDay")
    def start_time_of_day(self) -> pulumi.Input[str]:
        """
        The start time in `HH:mm:ss` format.
        """
        return pulumi.get(self, "start_time_of_day")

    @start_time_of_day.setter
    def start_time_of_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time_of_day", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `daily_restriction` or `weekly_restriction`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[pulumi.Input[int]]:
        """
        Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        return pulumi.get(self, "start_day_of_week")

    @start_day_of_week.setter
    def start_day_of_week(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_day_of_week", value)


@pulumi.input_type
class ServiceAlertGroupingParametersArgs:
    def __init__(__self__, *,
                 config: Optional[pulumi.Input['ServiceAlertGroupingParametersConfigArgs']] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ServiceAlertGroupingParametersConfigArgs'] config: Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        :param pulumi.Input[str] type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        ServiceAlertGroupingParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            config=config,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             config: Optional[pulumi.Input['ServiceAlertGroupingParametersConfigArgs']] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if config is not None:
            _setter("config", config)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['ServiceAlertGroupingParametersConfigArgs']]:
        """
        Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        """
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['ServiceAlertGroupingParametersConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceAlertGroupingParametersConfigArgs:
    def __init__(__self__, *,
                 aggregate: Optional[pulumi.Input[str]] = None,
                 fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] aggregate: One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] fields: Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        :param pulumi.Input[int] timeout: The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        ServiceAlertGroupingParametersConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aggregate=aggregate,
            fields=fields,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aggregate: Optional[pulumi.Input[str]] = None,
             fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             timeout: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if aggregate is not None:
            _setter("aggregate", aggregate)
        if fields is not None:
            _setter("fields", fields)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def aggregate(self) -> Optional[pulumi.Input[str]]:
        """
        One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @aggregate.setter
    def aggregate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregate", value)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class ServiceAutoPauseNotificationsParametersArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        :param pulumi.Input[int] timeout: Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
               
               
               You may specify one optional `incident_urgency_rule` block configuring what urgencies to use.
               Your PagerDuty account must have the `urgencies` ability to assign an incident urgency rule.
               The block contains the following arguments:
        """
        ServiceAutoPauseNotificationsParametersArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            timeout=timeout,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             timeout: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if timeout is not None:
            _setter("timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.


        You may specify one optional `incident_urgency_rule` block configuring what urgencies to use.
        Your PagerDuty account must have the `urgencies` ability to assign an incident urgency rule.
        The block contains the following arguments:
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class ServiceDependencyDependencyArgs:
    def __init__(__self__, *,
                 dependent_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]],
                 supporting_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]] dependent_services: The service that dependents on the supporting service. Dependency dependent service documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]] supporting_services: The service that supports the dependent service. Dependency supporting service documented below.
        :param pulumi.Input[str] type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        ServiceDependencyDependencyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dependent_services=dependent_services,
            supporting_services=supporting_services,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dependent_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]],
             supporting_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]],
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("dependent_services", dependent_services)
        _setter("supporting_services", supporting_services)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="dependentServices")
    def dependent_services(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]]:
        """
        The service that dependents on the supporting service. Dependency dependent service documented below.
        """
        return pulumi.get(self, "dependent_services")

    @dependent_services.setter
    def dependent_services(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]]):
        pulumi.set(self, "dependent_services", value)

    @property
    @pulumi.getter(name="supportingServices")
    def supporting_services(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]]:
        """
        The service that supports the dependent service. Dependency supporting service documented below.
        """
        return pulumi.get(self, "supporting_services")

    @supporting_services.setter
    def supporting_services(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]]):
        pulumi.set(self, "supporting_services", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceDependencyDependencyDependentServiceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the service dependency.
        :param pulumi.Input[str] type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        ServiceDependencyDependencyDependentServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceDependencyDependencySupportingServiceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the service dependency.
        :param pulumi.Input[str] type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        ServiceDependencyDependencySupportingServiceArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: pulumi.Input[str],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceEventRuleActionsArgs:
    def __init__(__self__, *,
                 annotates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]]] = None,
                 event_actions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]]] = None,
                 priorities: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]]] = None,
                 suppresses: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]]] = None,
                 suspends: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]] annotates: Note added to the event.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]] priorities: The ID of the priority applied to the event.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        ServiceEventRuleActionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotates=annotates,
            event_actions=event_actions,
            extractions=extractions,
            priorities=priorities,
            severities=severities,
            suppresses=suppresses,
            suspends=suspends,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]]] = None,
             event_actions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]]] = None,
             extractions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]]] = None,
             priorities: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]]] = None,
             severities: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]]] = None,
             suppresses: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]]] = None,
             suspends: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if annotates is not None:
            _setter("annotates", annotates)
        if event_actions is not None:
            _setter("event_actions", event_actions)
        if extractions is not None:
            _setter("extractions", extractions)
        if priorities is not None:
            _setter("priorities", priorities)
        if severities is not None:
            _setter("severities", severities)
        if suppresses is not None:
            _setter("suppresses", suppresses)
        if suspends is not None:
            _setter("suspends", suspends)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]]]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @annotates.setter
    def annotates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsAnnotateArgs']]]]):
        pulumi.set(self, "annotates", value)

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]]]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @event_actions.setter
    def event_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsEventActionArgs']]]]):
        pulumi.set(self, "event_actions", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]]]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]]]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @priorities.setter
    def priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsPriorityArgs']]]]):
        pulumi.set(self, "priorities", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]]]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSeverityArgs']]]]):
        pulumi.set(self, "severities", value)

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]]]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        return pulumi.get(self, "suppresses")

    @suppresses.setter
    def suppresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuppressArgs']]]]):
        pulumi.set(self, "suppresses", value)

    @property
    @pulumi.getter
    def suspends(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]]]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        return pulumi.get(self, "suspends")

    @suspends.setter
    def suspends(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleActionsSuspendArgs']]]]):
        pulumi.set(self, "suspends", value)


@pulumi.input_type
class ServiceEventRuleActionsAnnotateArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        ServiceEventRuleActionsAnnotateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceEventRuleActionsEventActionArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        ServiceEventRuleActionsEventActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceEventRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None,
                 template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
               
               *- **OR** -*
        :param pulumi.Input[str] source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param pulumi.Input[str] target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
               
               *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        :param pulumi.Input[str] template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        ServiceEventRuleActionsExtractionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            regex=regex,
            source=source,
            target=target,
            template=template,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             regex: Optional[pulumi.Input[str]] = None,
             source: Optional[pulumi.Input[str]] = None,
             target: Optional[pulumi.Input[str]] = None,
             template: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if regex is not None:
            _setter("regex", regex)
        if source is not None:
            _setter("source", source)
        if target is not None:
            _setter("target", target)
        if template is not None:
            _setter("template", template)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        *- **OR** -*
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.

        *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def template(self) -> Optional[pulumi.Input[str]]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")

    @template.setter
    def template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "template", value)


@pulumi.input_type
class ServiceEventRuleActionsPriorityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        ServiceEventRuleActionsPriorityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceEventRuleActionsSeverityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        ServiceEventRuleActionsSeverityArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceEventRuleActionsSuppressArgs:
    def __init__(__self__, *,
                 threshold_time_amount: Optional[pulumi.Input[int]] = None,
                 threshold_time_unit: Optional[pulumi.Input[str]] = None,
                 threshold_value: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created.
        :param pulumi.Input[str] threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param pulumi.Input[int] threshold_value: The number of alerts that should be suppressed.
        :param pulumi.Input[bool] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        ServiceEventRuleActionsSuppressArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            threshold_time_amount=threshold_time_amount,
            threshold_time_unit=threshold_time_unit,
            threshold_value=threshold_value,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             threshold_time_amount: Optional[pulumi.Input[int]] = None,
             threshold_time_unit: Optional[pulumi.Input[str]] = None,
             threshold_value: Optional[pulumi.Input[int]] = None,
             value: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if threshold_time_amount is not None:
            _setter("threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            _setter("threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            _setter("threshold_value", threshold_value)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[pulumi.Input[int]]:
        """
        The number value of the `threshold_time_unit` before an incident is created.
        """
        return pulumi.get(self, "threshold_time_amount")

    @threshold_time_amount.setter
    def threshold_time_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_time_amount", value)

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @threshold_time_unit.setter
    def threshold_time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_time_unit", value)

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[pulumi.Input[int]]:
        """
        The number of alerts that should be suppressed.
        """
        return pulumi.get(self, "threshold_value")

    @threshold_value.setter
    def threshold_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceEventRuleActionsSuspendArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        ServiceEventRuleActionsSuspendArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             value: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[int]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceEventRuleConditionsArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 subconditions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]] subconditions: List of sub-conditions that define the condition.
        """
        ServiceEventRuleConditionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            subconditions=subconditions,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[str]] = None,
             subconditions: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if operator is not None:
            _setter("operator", operator)
        if subconditions is not None:
            _setter("subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]]]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")

    @subconditions.setter
    def subconditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionArgs']]]]):
        pulumi.set(self, "subconditions", value)


@pulumi.input_type
class ServiceEventRuleConditionsSubconditionArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        ServiceEventRuleConditionsSubconditionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            operator=operator,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             operator: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if operator is not None:
            _setter("operator", operator)
        if parameters is not None:
            _setter("parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]]]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleConditionsSubconditionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class ServiceEventRuleConditionsSubconditionParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        ServiceEventRuleConditionsSubconditionParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if path is not None:
            _setter("path", path)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceEventRuleTimeFrameArgs:
    def __init__(__self__, *,
                 active_betweens: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]]] = None,
                 scheduled_weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]] active_betweens: Values for executing the rule during a specific time period.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        ServiceEventRuleTimeFrameArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            active_betweens=active_betweens,
            scheduled_weeklies=scheduled_weeklies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             active_betweens: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]]] = None,
             scheduled_weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if active_betweens is not None:
            _setter("active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            _setter("scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]]]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @active_betweens.setter
    def active_betweens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameActiveBetweenArgs']]]]):
        pulumi.set(self, "active_betweens", value)

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]]]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")

    @scheduled_weeklies.setter
    def scheduled_weeklies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleTimeFrameScheduledWeeklyArgs']]]]):
        pulumi.set(self, "scheduled_weeklies", value)


@pulumi.input_type
class ServiceEventRuleTimeFrameActiveBetweenArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] end_time: Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        :param pulumi.Input[int] start_time: Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        ServiceEventRuleTimeFrameActiveBetweenArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            end_time=end_time,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             end_time: Optional[pulumi.Input[int]] = None,
             start_time: Optional[pulumi.Input[int]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if end_time is not None:
            _setter("end_time", end_time)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[int]]:
        """
        Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class ServiceEventRuleTimeFrameScheduledWeeklyArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] duration: Length of time the schedule will be active.  Unix timestamp in milliseconds.
        :param pulumi.Input[int] start_time: Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        :param pulumi.Input[str] timezone: Timezone for the given schedule.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        ServiceEventRuleTimeFrameScheduledWeeklyArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            duration=duration,
            start_time=start_time,
            timezone=timezone,
            weekdays=weekdays,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             duration: Optional[pulumi.Input[int]] = None,
             start_time: Optional[pulumi.Input[int]] = None,
             timezone: Optional[pulumi.Input[str]] = None,
             weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if duration is not None:
            _setter("duration", duration)
        if start_time is not None:
            _setter("start_time", start_time)
        if timezone is not None:
            _setter("timezone", timezone)
        if weekdays is not None:
            _setter("weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        Length of time the schedule will be active.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Timezone for the given schedule.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weekdays", value)


@pulumi.input_type
class ServiceEventRuleVariableArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the variable.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]] parameters: The parameters for performing the operation to populate the variable.
        :param pulumi.Input[str] type: Type of operation to populate the variable. Usually `regex`.
        """
        ServiceEventRuleVariableArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            parameters=parameters,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             parameters: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if parameters is not None:
            _setter("parameters", parameters)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]]]:
        """
        The parameters for performing the operation to populate the variable.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEventRuleVariableParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of operation to populate the variable. Usually `regex`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceEventRuleVariableParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        ServiceEventRuleVariableParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: Optional[pulumi.Input[str]] = None,
             value: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if path is not None:
            _setter("path", path)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class ServiceIncidentUrgencyRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 during_support_hours: Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']] = None,
                 outside_support_hours: Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs'] during_support_hours: Incidents' urgency during support hours.
        :param pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs'] outside_support_hours: Incidents' urgency outside support hours.
               
               When using `type = "use_support_hours"` in `incident_urgency_rule` you must specify exactly one (otherwise optional) `support_hours` block.
               Your PagerDuty account must have the `service_support_hours` ability to assign support hours.
               The block contains the following arguments:
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        ServiceIncidentUrgencyRuleArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            during_support_hours=during_support_hours,
            outside_support_hours=outside_support_hours,
            urgency=urgency,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             during_support_hours: Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']] = None,
             outside_support_hours: Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']] = None,
             urgency: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if during_support_hours is not None:
            _setter("during_support_hours", during_support_hours)
        if outside_support_hours is not None:
            _setter("outside_support_hours", outside_support_hours)
        if urgency is not None:
            _setter("urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="duringSupportHours")
    def during_support_hours(self) -> Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']]:
        """
        Incidents' urgency during support hours.
        """
        return pulumi.get(self, "during_support_hours")

    @during_support_hours.setter
    def during_support_hours(self, value: Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']]):
        pulumi.set(self, "during_support_hours", value)

    @property
    @pulumi.getter(name="outsideSupportHours")
    def outside_support_hours(self) -> Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']]:
        """
        Incidents' urgency outside support hours.

        When using `type = "use_support_hours"` in `incident_urgency_rule` you must specify exactly one (otherwise optional) `support_hours` block.
        Your PagerDuty account must have the `service_support_hours` ability to assign support hours.
        The block contains the following arguments:
        """
        return pulumi.get(self, "outside_support_hours")

    @outside_support_hours.setter
    def outside_support_hours(self, value: Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']]):
        pulumi.set(self, "outside_support_hours", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


@pulumi.input_type
class ServiceIncidentUrgencyRuleDuringSupportHoursArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        ServiceIncidentUrgencyRuleDuringSupportHoursArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            urgency=urgency,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             urgency: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if type is not None:
            _setter("type", type)
        if urgency is not None:
            _setter("urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


@pulumi.input_type
class ServiceIncidentUrgencyRuleOutsideSupportHoursArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        ServiceIncidentUrgencyRuleOutsideSupportHoursArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            urgency=urgency,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: Optional[pulumi.Input[str]] = None,
             urgency: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if type is not None:
            _setter("type", type)
        if urgency is not None:
            _setter("urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


@pulumi.input_type
class ServiceIntegrationEmailFilterArgs:
    def __init__(__self__, *,
                 body_mode: Optional[pulumi.Input[str]] = None,
                 body_regex: Optional[pulumi.Input[str]] = None,
                 from_email_mode: Optional[pulumi.Input[str]] = None,
                 from_email_regex: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 subject_mode: Optional[pulumi.Input[str]] = None,
                 subject_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] body_mode: Can be `always` or `match`.
        :param pulumi.Input[str] body_regex: Should be a valid regex or `null`
        :param pulumi.Input[str] from_email_mode: Can be `always` or `match`.
        :param pulumi.Input[str] from_email_regex: Should be a valid regex or `null`
        :param pulumi.Input[str] id: The ID of the service integration.
        :param pulumi.Input[str] subject_mode: Can be `always` or `match`.
        :param pulumi.Input[str] subject_regex: Should be a valid regex or `null`
        """
        ServiceIntegrationEmailFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            body_mode=body_mode,
            body_regex=body_regex,
            from_email_mode=from_email_mode,
            from_email_regex=from_email_regex,
            id=id,
            subject_mode=subject_mode,
            subject_regex=subject_regex,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             body_mode: Optional[pulumi.Input[str]] = None,
             body_regex: Optional[pulumi.Input[str]] = None,
             from_email_mode: Optional[pulumi.Input[str]] = None,
             from_email_regex: Optional[pulumi.Input[str]] = None,
             id: Optional[pulumi.Input[str]] = None,
             subject_mode: Optional[pulumi.Input[str]] = None,
             subject_regex: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if body_mode is not None:
            _setter("body_mode", body_mode)
        if body_regex is not None:
            _setter("body_regex", body_regex)
        if from_email_mode is not None:
            _setter("from_email_mode", from_email_mode)
        if from_email_regex is not None:
            _setter("from_email_regex", from_email_regex)
        if id is not None:
            _setter("id", id)
        if subject_mode is not None:
            _setter("subject_mode", subject_mode)
        if subject_regex is not None:
            _setter("subject_regex", subject_regex)

    @property
    @pulumi.getter(name="bodyMode")
    def body_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "body_mode")

    @body_mode.setter
    def body_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_mode", value)

    @property
    @pulumi.getter(name="bodyRegex")
    def body_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "body_regex")

    @body_regex.setter
    def body_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "body_regex", value)

    @property
    @pulumi.getter(name="fromEmailMode")
    def from_email_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "from_email_mode")

    @from_email_mode.setter
    def from_email_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_email_mode", value)

    @property
    @pulumi.getter(name="fromEmailRegex")
    def from_email_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "from_email_regex")

    @from_email_regex.setter
    def from_email_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "from_email_regex", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the service integration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="subjectMode")
    def subject_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "subject_mode")

    @subject_mode.setter
    def subject_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_mode", value)

    @property
    @pulumi.getter(name="subjectRegex")
    def subject_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "subject_regex")

    @subject_regex.setter
    def subject_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_regex", value)


@pulumi.input_type
class ServiceIntegrationEmailParserArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[str],
                 match_predicate: pulumi.Input['ServiceIntegrationEmailParserMatchPredicateArgs'],
                 id: Optional[pulumi.Input[int]] = None,
                 value_extractors: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserValueExtractorArgs']]]] = None):
        """
        :param pulumi.Input[str] action: Can be `resolve` or `trigger`.
        :param pulumi.Input[int] id: The ID of the service integration.
        """
        ServiceIntegrationEmailParserArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            action=action,
            match_predicate=match_predicate,
            id=id,
            value_extractors=value_extractors,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             action: pulumi.Input[str],
             match_predicate: pulumi.Input['ServiceIntegrationEmailParserMatchPredicateArgs'],
             id: Optional[pulumi.Input[int]] = None,
             value_extractors: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserValueExtractorArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("action", action)
        _setter("match_predicate", match_predicate)
        if id is not None:
            _setter("id", id)
        if value_extractors is not None:
            _setter("value_extractors", value_extractors)

    @property
    @pulumi.getter
    def action(self) -> pulumi.Input[str]:
        """
        Can be `resolve` or `trigger`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[str]):
        pulumi.set(self, "action", value)

    @property
    @pulumi.getter(name="matchPredicate")
    def match_predicate(self) -> pulumi.Input['ServiceIntegrationEmailParserMatchPredicateArgs']:
        return pulumi.get(self, "match_predicate")

    @match_predicate.setter
    def match_predicate(self, value: pulumi.Input['ServiceIntegrationEmailParserMatchPredicateArgs']):
        pulumi.set(self, "match_predicate", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        The ID of the service integration.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="valueExtractors")
    def value_extractors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserValueExtractorArgs']]]]:
        return pulumi.get(self, "value_extractors")

    @value_extractors.setter
    def value_extractors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserValueExtractorArgs']]]]):
        pulumi.set(self, "value_extractors", value)


@pulumi.input_type
class ServiceIntegrationEmailParserMatchPredicateArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 predicates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicateArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Can be `any` or `all`.
        """
        ServiceIntegrationEmailParserMatchPredicateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            predicates=predicates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             predicates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicateArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if predicates is not None:
            _setter("predicates", predicates)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `any` or `all`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def predicates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicateArgs']]]]:
        return pulumi.get(self, "predicates")

    @predicates.setter
    def predicates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicateArgs']]]]):
        pulumi.set(self, "predicates", value)


@pulumi.input_type
class ServiceIntegrationEmailParserMatchPredicatePredicateArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 matcher: Optional[pulumi.Input[str]] = None,
                 part: Optional[pulumi.Input[str]] = None,
                 predicates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        :param pulumi.Input[str] matcher: Predicate value or valid regex.
        :param pulumi.Input[str] part: Can be `subject`, `body` or `from_addresses`.
        """
        ServiceIntegrationEmailParserMatchPredicatePredicateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            matcher=matcher,
            part=part,
            predicates=predicates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             matcher: Optional[pulumi.Input[str]] = None,
             part: Optional[pulumi.Input[str]] = None,
             predicates: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if matcher is not None:
            _setter("matcher", matcher)
        if part is not None:
            _setter("part", part)
        if predicates is not None:
            _setter("predicates", predicates)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def matcher(self) -> Optional[pulumi.Input[str]]:
        """
        Predicate value or valid regex.
        """
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "matcher", value)

    @property
    @pulumi.getter
    def part(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        return pulumi.get(self, "part")

    @part.setter
    def part(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "part", value)

    @property
    @pulumi.getter
    def predicates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs']]]]:
        return pulumi.get(self, "predicates")

    @predicates.setter
    def predicates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs']]]]):
        pulumi.set(self, "predicates", value)


@pulumi.input_type
class ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs:
    def __init__(__self__, *,
                 matcher: pulumi.Input[str],
                 part: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] matcher: Predicate value or valid regex.
        :param pulumi.Input[str] part: Can be `subject`, `body` or `from_addresses`.
        :param pulumi.Input[str] type: Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        ServiceIntegrationEmailParserMatchPredicatePredicatePredicateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            matcher=matcher,
            part=part,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             matcher: pulumi.Input[str],
             part: pulumi.Input[str],
             type: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("matcher", matcher)
        _setter("part", part)
        _setter("type", type)

    @property
    @pulumi.getter
    def matcher(self) -> pulumi.Input[str]:
        """
        Predicate value or valid regex.
        """
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: pulumi.Input[str]):
        pulumi.set(self, "matcher", value)

    @property
    @pulumi.getter
    def part(self) -> pulumi.Input[str]:
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        return pulumi.get(self, "part")

    @part.setter
    def part(self, value: pulumi.Input[str]):
        pulumi.set(self, "part", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceIntegrationEmailParserValueExtractorArgs:
    def __init__(__self__, *,
                 part: pulumi.Input[str],
                 type: pulumi.Input[str],
                 value_name: pulumi.Input[str],
                 ends_before: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None,
                 starts_after: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] part: Can be `subject` or `body`.
        :param pulumi.Input[str] type: Can be `between`, `entire` or `regex`.
        :param pulumi.Input[str] value_name: First value extractor should have name `incident_key` other value extractors should contain custom names.
        :param pulumi.Input[str] regex: If `type` has value `regex` this value should contain valid regex.
               
               **Note:** You can use the `get_vendor` data source to locate the appropriate vendor ID.
        """
        ServiceIntegrationEmailParserValueExtractorArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            part=part,
            type=type,
            value_name=value_name,
            ends_before=ends_before,
            regex=regex,
            starts_after=starts_after,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             part: pulumi.Input[str],
             type: pulumi.Input[str],
             value_name: pulumi.Input[str],
             ends_before: Optional[pulumi.Input[str]] = None,
             regex: Optional[pulumi.Input[str]] = None,
             starts_after: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("part", part)
        _setter("type", type)
        _setter("value_name", value_name)
        if ends_before is not None:
            _setter("ends_before", ends_before)
        if regex is not None:
            _setter("regex", regex)
        if starts_after is not None:
            _setter("starts_after", starts_after)

    @property
    @pulumi.getter
    def part(self) -> pulumi.Input[str]:
        """
        Can be `subject` or `body`.
        """
        return pulumi.get(self, "part")

    @part.setter
    def part(self, value: pulumi.Input[str]):
        pulumi.set(self, "part", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `between`, `entire` or `regex`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="valueName")
    def value_name(self) -> pulumi.Input[str]:
        """
        First value extractor should have name `incident_key` other value extractors should contain custom names.
        """
        return pulumi.get(self, "value_name")

    @value_name.setter
    def value_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "value_name", value)

    @property
    @pulumi.getter(name="endsBefore")
    def ends_before(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ends_before")

    @ends_before.setter
    def ends_before(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ends_before", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        If `type` has value `regex` this value should contain valid regex.

        **Note:** You can use the `get_vendor` data source to locate the appropriate vendor ID.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter(name="startsAfter")
    def starts_after(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "starts_after")

    @starts_after.setter
    def starts_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "starts_after", value)


@pulumi.input_type
class ServiceScheduledActionArgs:
    def __init__(__self__, *,
                 ats: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]] = None,
                 to_urgency: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]] ats: A block representing when the scheduled action will occur.
        :param pulumi.Input[str] to_urgency: The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        :param pulumi.Input[str] type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        ServiceScheduledActionArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ats=ats,
            to_urgency=to_urgency,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ats: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]] = None,
             to_urgency: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ats is not None:
            _setter("ats", ats)
        if to_urgency is not None:
            _setter("to_urgency", to_urgency)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def ats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]]:
        """
        A block representing when the scheduled action will occur.
        """
        return pulumi.get(self, "ats")

    @ats.setter
    def ats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]]):
        pulumi.set(self, "ats", value)

    @property
    @pulumi.getter(name="toUrgency")
    def to_urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        """
        return pulumi.get(self, "to_urgency")

    @to_urgency.setter
    def to_urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to_urgency", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceScheduledActionAtArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
               
               Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `during_support_hours` and to `low`  for `outside_support_hours` in `incident_urgency_rule`.
               
               Below is an example for a `Service` resource with `incident_urgency_rules` with `type = "use_support_hours"`, `support_hours` and a default `scheduled_action` as well.
               
               ```python
               import pulumi
               import pulumi_pagerduty as pagerduty
               
               foo = pagerduty.Service("foo",
                   description="bar bar bar",
                   auto_resolve_timeout="3600",
                   acknowledgement_timeout="3600",
                   escalation_policy=pagerduty_escalation_policy["foo"]["id"],
                   incident_urgency_rule=pagerduty.ServiceIncidentUrgencyRuleArgs(
                       type="use_support_hours",
                       during_support_hours=pagerduty.ServiceIncidentUrgencyRuleDuringSupportHoursArgs(
                           type="constant",
                           urgency="high",
                       ),
                       outside_support_hours=pagerduty.ServiceIncidentUrgencyRuleOutsideSupportHoursArgs(
                           type="constant",
                           urgency="low",
                       ),
                   ),
                   support_hours=pagerduty.ServiceSupportHoursArgs(
                       type="fixed_time_per_day",
                       time_zone="America/Lima",
                       start_time="09:00:00",
                       end_time="17:00:00",
                       days_of_weeks=[
                           1,
                           2,
                           3,
                           4,
                           5,
                       ],
                   ),
                   scheduled_actions=[pagerduty.ServiceScheduledActionArgs(
                       type="urgency_change",
                       to_urgency="high",
                       ats=[pagerduty.ServiceScheduledActionAtArgs(
                           type="named_time",
                           name="support_hours_start",
                       )],
                   )])
               ```
        :param pulumi.Input[str] type: The type of time specification. Currently, this must be set to `named_time`.
        """
        ServiceScheduledActionAtArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if name is not None:
            _setter("name", name)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.

        Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `during_support_hours` and to `low`  for `outside_support_hours` in `incident_urgency_rule`.

        Below is an example for a `Service` resource with `incident_urgency_rules` with `type = "use_support_hours"`, `support_hours` and a default `scheduled_action` as well.

        ```python
        import pulumi
        import pulumi_pagerduty as pagerduty

        foo = pagerduty.Service("foo",
            description="bar bar bar",
            auto_resolve_timeout="3600",
            acknowledgement_timeout="3600",
            escalation_policy=pagerduty_escalation_policy["foo"]["id"],
            incident_urgency_rule=pagerduty.ServiceIncidentUrgencyRuleArgs(
                type="use_support_hours",
                during_support_hours=pagerduty.ServiceIncidentUrgencyRuleDuringSupportHoursArgs(
                    type="constant",
                    urgency="high",
                ),
                outside_support_hours=pagerduty.ServiceIncidentUrgencyRuleOutsideSupportHoursArgs(
                    type="constant",
                    urgency="low",
                ),
            ),
            support_hours=pagerduty.ServiceSupportHoursArgs(
                type="fixed_time_per_day",
                time_zone="America/Lima",
                start_time="09:00:00",
                end_time="17:00:00",
                days_of_weeks=[
                    1,
                    2,
                    3,
                    4,
                    5,
                ],
            ),
            scheduled_actions=[pagerduty.ServiceScheduledActionArgs(
                type="urgency_change",
                to_urgency="high",
                ats=[pagerduty.ServiceScheduledActionAtArgs(
                    type="named_time",
                    name="support_hours_start",
                )],
            )])
        ```
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of time specification. Currently, this must be set to `named_time`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceSupportHoursArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] days_of_weeks: Array of days of week as integers. `1` to `7`, `1` being
               Monday and `7` being Sunday.
        :param pulumi.Input[str] end_time: The support hours' ending time of day.
               
               A `scheduled_actions` block is required when using `type = "use_support_hours"` in `incident_urgency_rule`.
               
               The block contains the following arguments:
        :param pulumi.Input[str] start_time: The support hours' starting time of day.
        :param pulumi.Input[str] time_zone: The time zone for the support hours.
        :param pulumi.Input[str] type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        ServiceSupportHoursArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            days_of_weeks=days_of_weeks,
            end_time=end_time,
            start_time=start_time,
            time_zone=time_zone,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
             end_time: Optional[pulumi.Input[str]] = None,
             start_time: Optional[pulumi.Input[str]] = None,
             time_zone: Optional[pulumi.Input[str]] = None,
             type: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if days_of_weeks is not None:
            _setter("days_of_weeks", days_of_weeks)
        if end_time is not None:
            _setter("end_time", end_time)
        if start_time is not None:
            _setter("start_time", start_time)
        if time_zone is not None:
            _setter("time_zone", time_zone)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Array of days of week as integers. `1` to `7`, `1` being
        Monday and `7` being Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        The support hours' ending time of day.

        A `scheduled_actions` block is required when using `type = "use_support_hours"` in `incident_urgency_rule`.

        The block contains the following arguments:
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The support hours' starting time of day.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone for the support hours.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SlackConnectionConfigArgs:
    def __init__(__self__, *,
                 events: pulumi.Input[Sequence[pulumi.Input[str]]],
                 priorities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] events: A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
               - `incident.acknowledged`
               - `incident.escalated`
               - `incident.resolved`
               - `incident.reassigned`
               - `incident.annotated`
               - `incident.unacknowledged`
               - `incident.delegated`
               - `incident.priority_updated`
               - `incident.responder.added`
               - `incident.responder.replied`
               - `incident.status_update_published`
               - `incident.reopened`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] priorities: Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through get_priority data source.
               - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behaviour is to set `priorities` to `No Priority` value.
               - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
        :param pulumi.Input[str] urgency: Allows you to filter events by urgency. Either `high` or `low`.
        """
        SlackConnectionConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            events=events,
            priorities=priorities,
            urgency=urgency,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             events: pulumi.Input[Sequence[pulumi.Input[str]]],
             priorities: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
             urgency: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("events", events)
        if priorities is not None:
            _setter("priorities", priorities)
        if urgency is not None:
            _setter("urgency", urgency)

    @property
    @pulumi.getter
    def events(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
        - `incident.acknowledged`
        - `incident.escalated`
        - `incident.resolved`
        - `incident.reassigned`
        - `incident.annotated`
        - `incident.unacknowledged`
        - `incident.delegated`
        - `incident.priority_updated`
        - `incident.responder.added`
        - `incident.responder.replied`
        - `incident.status_update_published`
        - `incident.reopened`
        """
        return pulumi.get(self, "events")

    @events.setter
    def events(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "events", value)

    @property
    @pulumi.getter
    def priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through get_priority data source.
        - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behaviour is to set `priorities` to `No Priority` value.
        - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
        """
        return pulumi.get(self, "priorities")

    @priorities.setter
    def priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "priorities", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        Allows you to filter events by urgency. Either `high` or `low`.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


@pulumi.input_type
class WebhookSubscriptionDeliveryMethodArgs:
    def __init__(__self__, *,
                 custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]]] = None,
                 temporarily_disabled: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]] custom_headers: The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        :param pulumi.Input[bool] temporarily_disabled: Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        :param pulumi.Input[str] type: Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        :param pulumi.Input[str] url: The destination URL for webhook delivery.
        """
        WebhookSubscriptionDeliveryMethodArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            custom_headers=custom_headers,
            temporarily_disabled=temporarily_disabled,
            type=type,
            url=url,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             custom_headers: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]]] = None,
             temporarily_disabled: Optional[pulumi.Input[bool]] = None,
             type: Optional[pulumi.Input[str]] = None,
             url: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if custom_headers is not None:
            _setter("custom_headers", custom_headers)
        if temporarily_disabled is not None:
            _setter("temporarily_disabled", temporarily_disabled)
        if type is not None:
            _setter("type", type)
        if url is not None:
            _setter("url", url)

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]]]:
        """
        The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        """
        return pulumi.get(self, "custom_headers")

    @custom_headers.setter
    def custom_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['WebhookSubscriptionDeliveryMethodCustomHeaderArgs']]]]):
        pulumi.set(self, "custom_headers", value)

    @property
    @pulumi.getter(name="temporarilyDisabled")
    def temporarily_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        """
        return pulumi.get(self, "temporarily_disabled")

    @temporarily_disabled.setter
    def temporarily_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "temporarily_disabled", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The destination URL for webhook delivery.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


@pulumi.input_type
class WebhookSubscriptionDeliveryMethodCustomHeaderArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        WebhookSubscriptionDeliveryMethodCustomHeaderArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            name=name,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             name: pulumi.Input[str],
             value: pulumi.Input[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("name", name)
        _setter("value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class WebhookSubscriptionFilterArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        :param pulumi.Input[str] id: The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        WebhookSubscriptionFilterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            type=type,
            id=id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             type: pulumi.Input[str],
             id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("type", type)
        if id is not None:
            _setter("id", id)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class GetEventOrchestrationIntegrationDetailArgs:
    def __init__(__self__, *,
                 id: str,
                 label: str,
                 parameters: Sequence['GetEventOrchestrationIntegrationDetailParameterArgs']):
        """
        :param str id: ID of the integration
        """
        GetEventOrchestrationIntegrationDetailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            id=id,
            label=label,
            parameters=parameters,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             id: str,
             label: str,
             parameters: Sequence['GetEventOrchestrationIntegrationDetailParameterArgs'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("id", id)
        _setter("label", label)
        _setter("parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: str):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['GetEventOrchestrationIntegrationDetailParameterArgs']:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Sequence['GetEventOrchestrationIntegrationDetailParameterArgs']):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class GetEventOrchestrationIntegrationDetailParameterArgs:
    def __init__(__self__, *,
                 routing_key: str,
                 type: str):
        """
        :param str routing_key: Routing key that routes to this Orchestration.
        :param str type: Type of the routing key. `global` is the default type.
        """
        GetEventOrchestrationIntegrationDetailParameterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            routing_key=routing_key,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             routing_key: str,
             type: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("routing_key", routing_key)
        _setter("type", type)

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @routing_key.setter
    def routing_key(self, value: str):
        pulumi.set(self, "routing_key", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)


@pulumi.input_type
class GetLicensesLicenseArgs:
    def __init__(__self__, *,
                 allocations_available: int,
                 current_value: int,
                 description: str,
                 html_url: str,
                 id: str,
                 name: str,
                 role_group: str,
                 self: str,
                 summary: str,
                 type: str,
                 valid_roles: Sequence[str]):
        """
        :param int allocations_available: Available allocations to assign to users
        :param int current_value: The number of allocations already assigned to users
        :param str description: Description of the license
        :param str id: Allows to override the default behavior for setting the `id` attribute that is required for data sources.
        :param str name: Name of the license
        :param str role_group: The role group for the license that determines the available `valid_roles`
        :param str summary: Summary of the license
        :param Sequence[str] valid_roles: List of allowed roles that may be assigned to a user with this license
        """
        GetLicensesLicenseArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allocations_available=allocations_available,
            current_value=current_value,
            description=description,
            html_url=html_url,
            id=id,
            name=name,
            role_group=role_group,
            self=self,
            summary=summary,
            type=type,
            valid_roles=valid_roles,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allocations_available: int,
             current_value: int,
             description: str,
             html_url: str,
             id: str,
             name: str,
             role_group: str,
             self: str,
             summary: str,
             type: str,
             valid_roles: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("allocations_available", allocations_available)
        _setter("current_value", current_value)
        _setter("description", description)
        _setter("html_url", html_url)
        _setter("id", id)
        _setter("name", name)
        _setter("role_group", role_group)
        _setter("self", self)
        _setter("summary", summary)
        _setter("type", type)
        _setter("valid_roles", valid_roles)

    @property
    @pulumi.getter(name="allocationsAvailable")
    def allocations_available(self) -> int:
        """
        Available allocations to assign to users
        """
        return pulumi.get(self, "allocations_available")

    @allocations_available.setter
    def allocations_available(self, value: int):
        pulumi.set(self, "allocations_available", value)

    @property
    @pulumi.getter(name="currentValue")
    def current_value(self) -> int:
        """
        The number of allocations already assigned to users
        """
        return pulumi.get(self, "current_value")

    @current_value.setter
    def current_value(self, value: int):
        pulumi.set(self, "current_value", value)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Description of the license
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: str):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="htmlUrl")
    def html_url(self) -> str:
        return pulumi.get(self, "html_url")

    @html_url.setter
    def html_url(self, value: str):
        pulumi.set(self, "html_url", value)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        Allows to override the default behavior for setting the `id` attribute that is required for data sources.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the license
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="roleGroup")
    def role_group(self) -> str:
        """
        The role group for the license that determines the available `valid_roles`
        """
        return pulumi.get(self, "role_group")

    @role_group.setter
    def role_group(self, value: str):
        pulumi.set(self, "role_group", value)

    @property
    @pulumi.getter
    def self(self) -> str:
        return pulumi.get(self, "self")

    @self.setter
    def self(self, value: str):
        pulumi.set(self, "self", value)

    @property
    @pulumi.getter
    def summary(self) -> str:
        """
        Summary of the license
        """
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: str):
        pulumi.set(self, "summary", value)

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: str):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="validRoles")
    def valid_roles(self) -> Sequence[str]:
        """
        List of allowed roles that may be assigned to a user with this license
        """
        return pulumi.get(self, "valid_roles")

    @valid_roles.setter
    def valid_roles(self, value: Sequence[str]):
        pulumi.set(self, "valid_roles", value)


