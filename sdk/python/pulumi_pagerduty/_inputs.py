# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from . import _utilities, _tables

__all__ = [
    'EscalationPolicyRuleArgs',
    'EscalationPolicyRuleTargetArgs',
    'RulesetRuleActionsArgs',
    'RulesetRuleActionsAnnotateArgs',
    'RulesetRuleActionsEventActionArgs',
    'RulesetRuleActionsExtractionArgs',
    'RulesetRuleActionsPriorityArgs',
    'RulesetRuleActionsRouteArgs',
    'RulesetRuleActionsSeverityArgs',
    'RulesetRuleActionsSuppressArgs',
    'RulesetRuleConditionsArgs',
    'RulesetRuleConditionsSubconditionArgs',
    'RulesetRuleConditionsSubconditionParameterArgs',
    'RulesetRuleTimeFrameArgs',
    'RulesetRuleTimeFrameActiveBetweenArgs',
    'RulesetRuleTimeFrameScheduledWeeklyArgs',
    'RulesetTeamArgs',
    'ScheduleLayerArgs',
    'ScheduleLayerRestrictionArgs',
    'ServiceDependencyDependencyArgs',
    'ServiceDependencyDependencyDependentServiceArgs',
    'ServiceDependencyDependencySupportingServiceArgs',
    'ServiceIncidentUrgencyRuleArgs',
    'ServiceIncidentUrgencyRuleDuringSupportHoursArgs',
    'ServiceIncidentUrgencyRuleOutsideSupportHoursArgs',
    'ServiceScheduledActionArgs',
    'ServiceScheduledActionAtArgs',
    'ServiceSupportHoursArgs',
    'UserNotificationRuleContactMethodArgs',
]

@pulumi.input_type
class EscalationPolicyRuleArgs:
    def __init__(__self__, *,
                 escalation_delay_in_minutes: pulumi.Input[int],
                 targets: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param pulumi.Input[str] id: A target ID
        """
        pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        pulumi.set(__self__, "targets", targets)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> pulumi.Input[int]:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @escalation_delay_in_minutes.setter
    def escalation_delay_in_minutes(self, value: pulumi.Input[int]):
        pulumi.set(self, "escalation_delay_in_minutes", value)

    @property
    @pulumi.getter
    def targets(self) -> pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]]:
        return pulumi.get(self, "targets")

    @targets.setter
    def targets(self, value: pulumi.Input[Sequence[pulumi.Input['EscalationPolicyRuleTargetArgs']]]):
        pulumi.set(self, "targets", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class EscalationPolicyRuleTargetArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: A target ID
        :param pulumi.Input[str] type: Can be `user`, `schedule`, `user_reference` or `schedule_reference`. Defaults to `user_reference`
        """
        pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Can be `user`, `schedule`, `user_reference` or `schedule_reference`. Defaults to `user_reference`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class RulesetRuleActionsArgs:
    def __init__(__self__, *,
                 annotates: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]] = None,
                 event_actions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]] = None,
                 extractions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]] = None,
                 priorities: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]] = None,
                 severities: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]] = None,
                 suppresses: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]] annotates: Note added to the event.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]] extractions: Allows you to copy important data from one event field to another. Extraction rules must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax). Extraction objects consist of the following fields:
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]] priorities: The ID of the priority applied to the event.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]] routes: The ID of the service where the event will be routed.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @annotates.setter
    def annotates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsAnnotateArgs']]]]):
        pulumi.set(self, "annotates", value)

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]]:
        return pulumi.get(self, "event_actions")

    @event_actions.setter
    def event_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsEventActionArgs']]]]):
        pulumi.set(self, "event_actions", value)

    @property
    @pulumi.getter
    def extractions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]]:
        """
        Allows you to copy important data from one event field to another. Extraction rules must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax). Extraction objects consist of the following fields:
        """
        return pulumi.get(self, "extractions")

    @extractions.setter
    def extractions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsExtractionArgs']]]]):
        pulumi.set(self, "extractions", value)

    @property
    @pulumi.getter
    def priorities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @priorities.setter
    def priorities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsPriorityArgs']]]]):
        pulumi.set(self, "priorities", value)

    @property
    @pulumi.getter
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]]:
        """
        The ID of the service where the event will be routed.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter
    def severities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @severities.setter
    def severities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSeverityArgs']]]]):
        pulumi.set(self, "severities", value)

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        return pulumi.get(self, "suppresses")

    @suppresses.setter
    def suppresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleActionsSuppressArgs']]]]):
        pulumi.set(self, "suppresses", value)


@pulumi.input_type
class RulesetRuleActionsAnnotateArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsEventActionArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsExtractionArgs:
    def __init__(__self__, *,
                 regex: Optional[pulumi.Input[str]] = None,
                 source: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] regex: The conditions that need to be met for the extraction to happen.
               * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        :param pulumi.Input[str] source: Field where the data is being copied from.
        :param pulumi.Input[str] target: Field where the data is being copied to.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The conditions that need to be met for the extraction to happen.
        * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter
    def source(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied from.
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Field where the data is being copied to.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class RulesetRuleActionsPriorityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsRouteArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsSeverityArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleActionsSuppressArgs:
    def __init__(__self__, *,
                 threshold_time_amount: Optional[pulumi.Input[int]] = None,
                 threshold_time_unit: Optional[pulumi.Input[str]] = None,
                 threshold_value: Optional[pulumi.Input[int]] = None,
                 value: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created.
        :param pulumi.Input[str] threshold_time_unit: The `minutes`,`hours`, or `days` that the `threshold_time_amount` should be measured.
        :param pulumi.Input[int] threshold_value: The number of alerts that should be suppressed.
        :param pulumi.Input[bool] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[pulumi.Input[int]]:
        """
        The number value of the `threshold_time_unit` before an incident is created.
        """
        return pulumi.get(self, "threshold_time_amount")

    @threshold_time_amount.setter
    def threshold_time_amount(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_time_amount", value)

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[pulumi.Input[str]]:
        """
        The `minutes`,`hours`, or `days` that the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @threshold_time_unit.setter
    def threshold_time_unit(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_time_unit", value)

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[pulumi.Input[int]]:
        """
        The number of alerts that should be suppressed.
        """
        return pulumi.get(self, "threshold_value")

    @threshold_value.setter
    def threshold_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "threshold_value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleConditionsArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 subconditions: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]] subconditions: List of sub-conditions that define the the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]]:
        """
        List of sub-conditions that define the the condition.
        """
        return pulumi.get(self, "subconditions")

    @subconditions.setter
    def subconditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionArgs']]]]):
        pulumi.set(self, "subconditions", value)


@pulumi.input_type
class RulesetRuleConditionsSubconditionArgs:
    def __init__(__self__, *,
                 operator: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]] = None):
        """
        :param pulumi.Input[str] operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[pulumi.Input[str]]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleConditionsSubconditionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


@pulumi.input_type
class RulesetRuleConditionsSubconditionParameterArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class RulesetRuleTimeFrameArgs:
    def __init__(__self__, *,
                 active_betweens: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]] = None,
                 scheduled_weeklies: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]] active_betweens: Values for executing the rule during a specific time period.
        :param pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @active_betweens.setter
    def active_betweens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameActiveBetweenArgs']]]]):
        pulumi.set(self, "active_betweens", value)

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")

    @scheduled_weeklies.setter
    def scheduled_weeklies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['RulesetRuleTimeFrameScheduledWeeklyArgs']]]]):
        pulumi.set(self, "scheduled_weeklies", value)


@pulumi.input_type
class RulesetRuleTimeFrameActiveBetweenArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] end_time: Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        :param pulumi.Input[int] start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[int]]:
        """
        Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class RulesetRuleTimeFrameScheduledWeeklyArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[int]] = None,
                 start_time: Optional[pulumi.Input[int]] = None,
                 timezone: Optional[pulumi.Input[str]] = None,
                 weekdays: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] duration: Length of time the schedule will be active.  Unix timestamp in milliseconds.
        :param pulumi.Input[int] start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        :param pulumi.Input[str] timezone: Timezone for the given schedule.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[int]]:
        """
        Length of time the schedule will be active.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[int]]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> Optional[pulumi.Input[str]]:
        """
        Timezone for the given schedule.
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")

    @weekdays.setter
    def weekdays(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "weekdays", value)


@pulumi.input_type
class RulesetTeamArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the ruleset.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the ruleset.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)


@pulumi.input_type
class ScheduleLayerArgs:
    def __init__(__self__, *,
                 rotation_turn_length_seconds: pulumi.Input[int],
                 rotation_virtual_start: pulumi.Input[str],
                 start: pulumi.Input[str],
                 users: pulumi.Input[Sequence[pulumi.Input[str]]],
                 end: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 restrictions: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]] = None):
        """
        :param pulumi.Input[int] rotation_turn_length_seconds: The duration of each on-call shift in `seconds`.
        :param pulumi.Input[str] rotation_virtual_start: The effective start time of the schedule layer. This can be before the start time of the schedule.
        :param pulumi.Input[str] start: The start time of the schedule layer. This value will not be read back from the PagerDuty API because the API will always return a new `start` time, which represents the last updated time of the schedule layer.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] users: The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        :param pulumi.Input[str] end: The end time of the schedule layer. If not specified, the layer does not end.
        :param pulumi.Input[str] id: The ID of the schedule
        :param pulumi.Input[str] name: The name of the schedule layer.
        :param pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]] restrictions: A schedule layer restriction block. Restriction blocks documented below.
        """
        pulumi.set(__self__, "rotation_turn_length_seconds", rotation_turn_length_seconds)
        pulumi.set(__self__, "rotation_virtual_start", rotation_virtual_start)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "users", users)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter(name="rotationTurnLengthSeconds")
    def rotation_turn_length_seconds(self) -> pulumi.Input[int]:
        """
        The duration of each on-call shift in `seconds`.
        """
        return pulumi.get(self, "rotation_turn_length_seconds")

    @rotation_turn_length_seconds.setter
    def rotation_turn_length_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "rotation_turn_length_seconds", value)

    @property
    @pulumi.getter(name="rotationVirtualStart")
    def rotation_virtual_start(self) -> pulumi.Input[str]:
        """
        The effective start time of the schedule layer. This can be before the start time of the schedule.
        """
        return pulumi.get(self, "rotation_virtual_start")

    @rotation_virtual_start.setter
    def rotation_virtual_start(self, value: pulumi.Input[str]):
        pulumi.set(self, "rotation_virtual_start", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[str]:
        """
        The start time of the schedule layer. This value will not be read back from the PagerDuty API because the API will always return a new `start` time, which represents the last updated time of the schedule layer.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[str]):
        pulumi.set(self, "start", value)

    @property
    @pulumi.getter
    def users(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        """
        return pulumi.get(self, "users")

    @users.setter
    def users(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "users", value)

    @property
    @pulumi.getter
    def end(self) -> Optional[pulumi.Input[str]]:
        """
        The end time of the schedule layer. If not specified, the layer does not end.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the schedule
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the schedule layer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]]:
        """
        A schedule layer restriction block. Restriction blocks documented below.
        """
        return pulumi.get(self, "restrictions")

    @restrictions.setter
    def restrictions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ScheduleLayerRestrictionArgs']]]]):
        pulumi.set(self, "restrictions", value)


@pulumi.input_type
class ScheduleLayerRestrictionArgs:
    def __init__(__self__, *,
                 duration_seconds: pulumi.Input[int],
                 start_time_of_day: pulumi.Input[str],
                 type: pulumi.Input[str],
                 start_day_of_week: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] duration_seconds: The duration of the restriction in `seconds`.
        :param pulumi.Input[str] start_time_of_day: The start time in `HH:mm:ss` format.
        :param pulumi.Input[str] type: Can be `daily_restriction` or `weekly_restriction`
        :param pulumi.Input[int] start_day_of_week: Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        pulumi.set(__self__, "duration_seconds", duration_seconds)
        pulumi.set(__self__, "start_time_of_day", start_time_of_day)
        pulumi.set(__self__, "type", type)
        if start_day_of_week is not None:
            pulumi.set(__self__, "start_day_of_week", start_day_of_week)

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> pulumi.Input[int]:
        """
        The duration of the restriction in `seconds`.
        """
        return pulumi.get(self, "duration_seconds")

    @duration_seconds.setter
    def duration_seconds(self, value: pulumi.Input[int]):
        pulumi.set(self, "duration_seconds", value)

    @property
    @pulumi.getter(name="startTimeOfDay")
    def start_time_of_day(self) -> pulumi.Input[str]:
        """
        The start time in `HH:mm:ss` format.
        """
        return pulumi.get(self, "start_time_of_day")

    @start_time_of_day.setter
    def start_time_of_day(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time_of_day", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Can be `daily_restriction` or `weekly_restriction`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[pulumi.Input[int]]:
        """
        Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        return pulumi.get(self, "start_day_of_week")

    @start_day_of_week.setter
    def start_day_of_week(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_day_of_week", value)


@pulumi.input_type
class ServiceDependencyDependencyArgs:
    def __init__(__self__, *,
                 dependent_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]],
                 supporting_services: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]],
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]] dependent_services: The service that id dependent on the supporting service.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]] supporting_services: The service that supports  the  dependent service.
        """
        pulumi.set(__self__, "dependent_services", dependent_services)
        pulumi.set(__self__, "supporting_services", supporting_services)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dependentServices")
    def dependent_services(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]]:
        """
        The service that id dependent on the supporting service.
        """
        return pulumi.get(self, "dependent_services")

    @dependent_services.setter
    def dependent_services(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencyDependentServiceArgs']]]):
        pulumi.set(self, "dependent_services", value)

    @property
    @pulumi.getter(name="supportingServices")
    def supporting_services(self) -> pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]]:
        """
        The service that supports  the  dependent service.
        """
        return pulumi.get(self, "supporting_services")

    @supporting_services.setter
    def supporting_services(self, value: pulumi.Input[Sequence[pulumi.Input['ServiceDependencyDependencySupportingServiceArgs']]]):
        pulumi.set(self, "supporting_services", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceDependencyDependencyDependentServiceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the service dependency.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceDependencyDependencySupportingServiceArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The ID of the service dependency.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceIncidentUrgencyRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 during_support_hours: Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']] = None,
                 outside_support_hours: Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        :param pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs'] during_support_hours: Incidents' urgency during support hours.
        :param pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs'] outside_support_hours: Incidents' urgency outside of support hours.
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        pulumi.set(__self__, "type", type)
        if during_support_hours is not None:
            pulumi.set(__self__, "during_support_hours", during_support_hours)
        if outside_support_hours is not None:
            pulumi.set(__self__, "outside_support_hours", outside_support_hours)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="duringSupportHours")
    def during_support_hours(self) -> Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']]:
        """
        Incidents' urgency during support hours.
        """
        return pulumi.get(self, "during_support_hours")

    @during_support_hours.setter
    def during_support_hours(self, value: Optional[pulumi.Input['ServiceIncidentUrgencyRuleDuringSupportHoursArgs']]):
        pulumi.set(self, "during_support_hours", value)

    @property
    @pulumi.getter(name="outsideSupportHours")
    def outside_support_hours(self) -> Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']]:
        """
        Incidents' urgency outside of support hours.
        """
        return pulumi.get(self, "outside_support_hours")

    @outside_support_hours.setter
    def outside_support_hours(self, value: Optional[pulumi.Input['ServiceIncidentUrgencyRuleOutsideSupportHoursArgs']]):
        pulumi.set(self, "outside_support_hours", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


@pulumi.input_type
class ServiceIncidentUrgencyRuleDuringSupportHoursArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


@pulumi.input_type
class ServiceIncidentUrgencyRuleOutsideSupportHoursArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None,
                 urgency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        :param pulumi.Input[str] urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    @urgency.setter
    def urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "urgency", value)


@pulumi.input_type
class ServiceScheduledActionArgs:
    def __init__(__self__, *,
                 ats: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]] = None,
                 to_urgency: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]] ats: A block representing when the scheduled action will occur.
        :param pulumi.Input[str] to_urgency: The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        :param pulumi.Input[str] type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if to_urgency is not None:
            pulumi.set(__self__, "to_urgency", to_urgency)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ats(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]]:
        """
        A block representing when the scheduled action will occur.
        """
        return pulumi.get(self, "ats")

    @ats.setter
    def ats(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceScheduledActionAtArgs']]]]):
        pulumi.set(self, "ats", value)

    @property
    @pulumi.getter(name="toUrgency")
    def to_urgency(self) -> Optional[pulumi.Input[str]]:
        """
        The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        """
        return pulumi.get(self, "to_urgency")

    @to_urgency.setter
    def to_urgency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "to_urgency", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceScheduledActionAtArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
        :param pulumi.Input[str] type: The type of time specification. Currently, this must be set to `named_time`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of time specification. Currently, this must be set to `named_time`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class ServiceSupportHoursArgs:
    def __init__(__self__, *,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] days_of_weeks: Array of days of week as integers. `1` to `7`, `1` being
               Monday and `7` being Sunday.
        :param pulumi.Input[str] end_time: The support hours' ending time of day.
        :param pulumi.Input[str] start_time: The support hours' starting time of day.
        :param pulumi.Input[str] time_zone: The time zone for the support hours.
        :param pulumi.Input[str] type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        Array of days of week as integers. `1` to `7`, `1` being
        Monday and `7` being Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        The support hours' ending time of day.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The support hours' starting time of day.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        The time zone for the support hours.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class UserNotificationRuleContactMethodArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] id: The id of the referenced contact method.
        :param pulumi.Input[str] type: The type of contact method. Can be `email_contact_method`, `phone_contact_method`, `push_notification_contact_method` or `sms_contact_method`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        """
        The id of the referenced contact method.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of contact method. Can be `email_contact_method`, `phone_contact_method`, `push_notification_contact_method` or `sms_contact_method`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


