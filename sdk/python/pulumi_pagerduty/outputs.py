# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AlertGroupingSettingConfig',
    'AutomationActionsActionActionDataReference',
    'EscalationPolicyRule',
    'EscalationPolicyRuleEscalationRuleAssignmentStrategy',
    'EscalationPolicyRuleTarget',
    'EventOrchestrationGlobalCacheVariableCondition',
    'EventOrchestrationGlobalCacheVariableConfiguration',
    'EventOrchestrationGlobalCatchAll',
    'EventOrchestrationGlobalCatchAllActions',
    'EventOrchestrationGlobalCatchAllActionsAutomationAction',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionHeader',
    'EventOrchestrationGlobalCatchAllActionsAutomationActionParameter',
    'EventOrchestrationGlobalCatchAllActionsExtraction',
    'EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate',
    'EventOrchestrationGlobalCatchAllActionsVariable',
    'EventOrchestrationGlobalSet',
    'EventOrchestrationGlobalSetRule',
    'EventOrchestrationGlobalSetRuleActions',
    'EventOrchestrationGlobalSetRuleActionsAutomationAction',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionHeader',
    'EventOrchestrationGlobalSetRuleActionsAutomationActionParameter',
    'EventOrchestrationGlobalSetRuleActionsExtraction',
    'EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate',
    'EventOrchestrationGlobalSetRuleActionsVariable',
    'EventOrchestrationGlobalSetRuleCondition',
    'EventOrchestrationIntegration',
    'EventOrchestrationIntegrationParameter',
    'EventOrchestrationRouterCatchAll',
    'EventOrchestrationRouterCatchAllActions',
    'EventOrchestrationRouterSet',
    'EventOrchestrationRouterSetRule',
    'EventOrchestrationRouterSetRuleActions',
    'EventOrchestrationRouterSetRuleActionsDynamicRouteTo',
    'EventOrchestrationRouterSetRuleCondition',
    'EventOrchestrationServiceCacheVariableCondition',
    'EventOrchestrationServiceCacheVariableConfiguration',
    'EventOrchestrationServiceCatchAll',
    'EventOrchestrationServiceCatchAllActions',
    'EventOrchestrationServiceCatchAllActionsAutomationAction',
    'EventOrchestrationServiceCatchAllActionsAutomationActionHeader',
    'EventOrchestrationServiceCatchAllActionsAutomationActionParameter',
    'EventOrchestrationServiceCatchAllActionsExtraction',
    'EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate',
    'EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction',
    'EventOrchestrationServiceCatchAllActionsVariable',
    'EventOrchestrationServiceSet',
    'EventOrchestrationServiceSetRule',
    'EventOrchestrationServiceSetRuleActions',
    'EventOrchestrationServiceSetRuleActionsAutomationAction',
    'EventOrchestrationServiceSetRuleActionsAutomationActionHeader',
    'EventOrchestrationServiceSetRuleActionsAutomationActionParameter',
    'EventOrchestrationServiceSetRuleActionsExtraction',
    'EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate',
    'EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction',
    'EventOrchestrationServiceSetRuleActionsVariable',
    'EventOrchestrationServiceSetRuleCondition',
    'EventOrchestrationUnroutedCatchAll',
    'EventOrchestrationUnroutedCatchAllActions',
    'EventOrchestrationUnroutedCatchAllActionsExtraction',
    'EventOrchestrationUnroutedCatchAllActionsVariable',
    'EventOrchestrationUnroutedSet',
    'EventOrchestrationUnroutedSetRule',
    'EventOrchestrationUnroutedSetRuleActions',
    'EventOrchestrationUnroutedSetRuleActionsExtraction',
    'EventOrchestrationUnroutedSetRuleActionsVariable',
    'EventOrchestrationUnroutedSetRuleCondition',
    'IncidentWorkflowStep',
    'IncidentWorkflowStepInlineStepsInput',
    'IncidentWorkflowStepInlineStepsInputStep',
    'IncidentWorkflowStepInlineStepsInputStepInput',
    'IncidentWorkflowStepInput',
    'IncidentWorkflowTriggerPermissions',
    'JiraCloudAccountMappingRuleConfig',
    'JiraCloudAccountMappingRuleConfigJira',
    'JiraCloudAccountMappingRuleConfigJiraCustomField',
    'JiraCloudAccountMappingRuleConfigJiraIssueType',
    'JiraCloudAccountMappingRuleConfigJiraPriority',
    'JiraCloudAccountMappingRuleConfigJiraProject',
    'JiraCloudAccountMappingRuleConfigJiraStatusMapping',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledged',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingResolved',
    'JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggered',
    'ResponsePlayResponder',
    'ResponsePlayResponderEscalationRule',
    'ResponsePlayResponderEscalationRuleTarget',
    'ResponsePlayResponderService',
    'ResponsePlayResponderTeam',
    'ResponsePlaySubscriber',
    'RulesetRuleActions',
    'RulesetRuleActionsAnnotate',
    'RulesetRuleActionsEventAction',
    'RulesetRuleActionsExtraction',
    'RulesetRuleActionsPriority',
    'RulesetRuleActionsRoute',
    'RulesetRuleActionsSeverity',
    'RulesetRuleActionsSuppress',
    'RulesetRuleActionsSuspend',
    'RulesetRuleConditions',
    'RulesetRuleConditionsSubcondition',
    'RulesetRuleConditionsSubconditionParameter',
    'RulesetRuleTimeFrame',
    'RulesetRuleTimeFrameActiveBetween',
    'RulesetRuleTimeFrameScheduledWeekly',
    'RulesetRuleVariable',
    'RulesetRuleVariableParameter',
    'RulesetTeam',
    'ScheduleFinalSchedule',
    'ScheduleLayer',
    'ScheduleLayerRestriction',
    'ServiceAlertGroupingParameters',
    'ServiceAlertGroupingParametersConfig',
    'ServiceAutoPauseNotificationsParameters',
    'ServiceCustomFieldFieldOption',
    'ServiceCustomFieldValueCustomField',
    'ServiceDependencyDependency',
    'ServiceDependencyDependencyDependentService',
    'ServiceDependencyDependencySupportingService',
    'ServiceEventRuleActions',
    'ServiceEventRuleActionsAnnotate',
    'ServiceEventRuleActionsEventAction',
    'ServiceEventRuleActionsExtraction',
    'ServiceEventRuleActionsPriority',
    'ServiceEventRuleActionsSeverity',
    'ServiceEventRuleActionsSuppress',
    'ServiceEventRuleActionsSuspend',
    'ServiceEventRuleConditions',
    'ServiceEventRuleConditionsSubcondition',
    'ServiceEventRuleConditionsSubconditionParameter',
    'ServiceEventRuleTimeFrame',
    'ServiceEventRuleTimeFrameActiveBetween',
    'ServiceEventRuleTimeFrameScheduledWeekly',
    'ServiceEventRuleVariable',
    'ServiceEventRuleVariableParameter',
    'ServiceIncidentUrgencyRule',
    'ServiceIncidentUrgencyRuleDuringSupportHours',
    'ServiceIncidentUrgencyRuleOutsideSupportHours',
    'ServiceIntegrationEmailFilter',
    'ServiceIntegrationEmailParser',
    'ServiceIntegrationEmailParserMatchPredicate',
    'ServiceIntegrationEmailParserMatchPredicatePredicate',
    'ServiceIntegrationEmailParserMatchPredicatePredicatePredicate',
    'ServiceIntegrationEmailParserValueExtractor',
    'ServiceScheduledAction',
    'ServiceScheduledActionAt',
    'ServiceSupportHours',
    'SlackConnectionConfig',
    'UserHandoffNotificationRuleContactMethod',
    'UserNotificationRuleContactMethod',
    'WebhookSubscriptionDeliveryMethod',
    'WebhookSubscriptionDeliveryMethodCustomHeader',
    'WebhookSubscriptionFilter',
    'GetAlertGroupingSettingConfigResult',
    'GetAutomationActionsActionActionDataReferenceResult',
    'GetEventOrchestrationGlobalCacheVariableConditionResult',
    'GetEventOrchestrationGlobalCacheVariableConfigurationResult',
    'GetEventOrchestrationIntegrationDetailResult',
    'GetEventOrchestrationIntegrationDetailParameterResult',
    'GetEventOrchestrationIntegrationParameterResult',
    'GetEventOrchestrationServiceCacheVariableConditionResult',
    'GetEventOrchestrationServiceCacheVariableConfigurationResult',
    'GetEventOrchestrationsEventOrchestrationResult',
    'GetEventOrchestrationsEventOrchestrationIntegrationResult',
    'GetEventOrchestrationsEventOrchestrationIntegrationParameterResult',
    'GetIncidentTypeCustomFieldFieldOptionResult',
    'GetIncidentTypeCustomFieldFieldOptionDataResult',
    'GetLicensesLicenseResult',
    'GetServiceCustomFieldFieldOptionResult',
    'GetServiceCustomFieldValueCustomFieldResult',
    'GetServiceTeamResult',
    'GetStandardsResourceScoresScoreResult',
    'GetStandardsResourceScoresStandardResult',
    'GetStandardsResourcesScoresResourceResult',
    'GetStandardsResourcesScoresResourceScoreResult',
    'GetStandardsResourcesScoresResourceStandardResult',
    'GetStandardsStandardResult',
    'GetStandardsStandardExclusionResult',
    'GetStandardsStandardInclusionResult',
    'GetTeamMembersMemberResult',
    'GetTeamsTeamResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class AlertGroupingSettingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AlertGroupingSettingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AlertGroupingSettingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AlertGroupingSettingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate: Optional[_builtins.str] = None,
                 fields: Optional[Sequence[_builtins.str]] = None,
                 time_window: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.str aggregate: One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        :param Sequence[_builtins.str] fields: Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        :param _builtins.int time_window: The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        :param _builtins.int timeout: The duration in seconds within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        """
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def aggregate(self) -> Optional[_builtins.str]:
        """
        One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        """
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[_builtins.int]:
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        """
        return pulumi.get(self, "time_window")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        The duration in seconds within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class AutomationActionsActionActionDataReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "invocationCommand":
            suggest = "invocation_command"
        elif key == "processAutomationJobArguments":
            suggest = "process_automation_job_arguments"
        elif key == "processAutomationJobId":
            suggest = "process_automation_job_id"
        elif key == "processAutomationNodeFilter":
            suggest = "process_automation_node_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationActionsActionActionDataReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationActionsActionActionDataReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationActionsActionActionDataReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 invocation_command: Optional[_builtins.str] = None,
                 process_automation_job_arguments: Optional[_builtins.str] = None,
                 process_automation_job_id: Optional[_builtins.str] = None,
                 process_automation_node_filter: Optional[_builtins.str] = None,
                 script: Optional[_builtins.str] = None):
        """
        :param _builtins.str invocation_command: The command to execute the script with.
        :param _builtins.str process_automation_job_arguments: The arguments to pass to the Process Automation job execution.
        :param _builtins.str process_automation_job_id: The ID of the Process Automation job to execute.
        :param _builtins.str process_automation_node_filter: The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        :param _builtins.str script: Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        if invocation_command is not None:
            pulumi.set(__self__, "invocation_command", invocation_command)
        if process_automation_job_arguments is not None:
            pulumi.set(__self__, "process_automation_job_arguments", process_automation_job_arguments)
        if process_automation_job_id is not None:
            pulumi.set(__self__, "process_automation_job_id", process_automation_job_id)
        if process_automation_node_filter is not None:
            pulumi.set(__self__, "process_automation_node_filter", process_automation_node_filter)
        if script is not None:
            pulumi.set(__self__, "script", script)

    @_builtins.property
    @pulumi.getter(name="invocationCommand")
    def invocation_command(self) -> Optional[_builtins.str]:
        """
        The command to execute the script with.
        """
        return pulumi.get(self, "invocation_command")

    @_builtins.property
    @pulumi.getter(name="processAutomationJobArguments")
    def process_automation_job_arguments(self) -> Optional[_builtins.str]:
        """
        The arguments to pass to the Process Automation job execution.
        """
        return pulumi.get(self, "process_automation_job_arguments")

    @_builtins.property
    @pulumi.getter(name="processAutomationJobId")
    def process_automation_job_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Process Automation job to execute.
        """
        return pulumi.get(self, "process_automation_job_id")

    @_builtins.property
    @pulumi.getter(name="processAutomationNodeFilter")
    def process_automation_node_filter(self) -> Optional[_builtins.str]:
        """
        The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        """
        return pulumi.get(self, "process_automation_node_filter")

    @_builtins.property
    @pulumi.getter
    def script(self) -> Optional[_builtins.str]:
        """
        Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        return pulumi.get(self, "script")


@pulumi.output_type
class EscalationPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationDelayInMinutes":
            suggest = "escalation_delay_in_minutes"
        elif key == "escalationRuleAssignmentStrategy":
            suggest = "escalation_rule_assignment_strategy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_delay_in_minutes: _builtins.int,
                 targets: Sequence['outputs.EscalationPolicyRuleTarget'],
                 escalation_rule_assignment_strategy: Optional['outputs.EscalationPolicyRuleEscalationRuleAssignmentStrategy'] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.int escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param 'EscalationPolicyRuleEscalationRuleAssignmentStrategyArgs' escalation_rule_assignment_strategy: The strategy used to assign the escalation rule to an incident. Documented below.
        :param _builtins.str id: The ID of the escalation policy.
        """
        pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        pulumi.set(__self__, "targets", targets)
        if escalation_rule_assignment_strategy is not None:
            pulumi.set(__self__, "escalation_rule_assignment_strategy", escalation_rule_assignment_strategy)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> _builtins.int:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.EscalationPolicyRuleTarget']:
        return pulumi.get(self, "targets")

    @_builtins.property
    @pulumi.getter(name="escalationRuleAssignmentStrategy")
    def escalation_rule_assignment_strategy(self) -> Optional['outputs.EscalationPolicyRuleEscalationRuleAssignmentStrategy']:
        """
        The strategy used to assign the escalation rule to an incident. Documented below.
        """
        return pulumi.get(self, "escalation_rule_assignment_strategy")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the escalation policy.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class EscalationPolicyRuleEscalationRuleAssignmentStrategy(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: Can be `round_robin` or `assign_to_everyone`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Can be `round_robin` or `assign_to_everyone`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EscalationPolicyRuleTarget(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: A target ID
        :param _builtins.str type: Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EventOrchestrationGlobalCacheVariableCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class EventOrchestrationGlobalCacheVariableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ttlSeconds":
            suggest = "ttl_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationGlobalCacheVariableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationGlobalCacheVariableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationGlobalCacheVariableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 data_type: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 ttl_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value`, `trigger_event_count` or `external_data`.
        :param _builtins.str data_type: The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `external_data`
        :param _builtins.str regex: A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        :param _builtins.int ttl_seconds: The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count` or `external_data`
        """
        pulumi.set(__self__, "type", type)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if ttl_seconds is not None:
            pulumi.set(__self__, "ttl_seconds", ttl_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value`, `trigger_event_count` or `external_data`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `external_data`
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count` or `external_data`
        """
        return pulumi.get(self, "ttl_seconds")


@pulumi.output_type
class EventOrchestrationGlobalCatchAll(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationGlobalCatchAllActions'):
        """
        :param 'EventOrchestrationGlobalCatchAllActionsArgs' actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        pulumi.set(__self__, "actions", actions)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationGlobalCatchAllActions':
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class EventOrchestrationGlobalCatchAllActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationAction":
            suggest = "automation_action"
        elif key == "dropEvent":
            suggest = "drop_event"
        elif key == "escalationPolicy":
            suggest = "escalation_policy"
        elif key == "eventAction":
            suggest = "event_action"
        elif key == "incidentCustomFieldUpdates":
            suggest = "incident_custom_field_updates"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationGlobalCatchAllActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationGlobalCatchAllActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationGlobalCatchAllActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotate: Optional[_builtins.str] = None,
                 automation_action: Optional['outputs.EventOrchestrationGlobalCatchAllActionsAutomationAction'] = None,
                 drop_event: Optional[_builtins.bool] = None,
                 escalation_policy: Optional[_builtins.str] = None,
                 event_action: Optional[_builtins.str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsExtraction']] = None,
                 incident_custom_field_updates: Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate']] = None,
                 priority: Optional[_builtins.str] = None,
                 route_to: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None,
                 suppress: Optional[_builtins.bool] = None,
                 suspend: Optional[_builtins.int] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsVariable']] = None):
        """
        :param _builtins.str annotate: Add this text as a note on the resulting incident.
        :param 'EventOrchestrationGlobalCatchAllActionsAutomationActionArgs' automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
        :param _builtins.bool drop_event: When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        :param _builtins.str escalation_policy: The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        :param _builtins.str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationGlobalCatchAllActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param Sequence['EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdateArgs'] incident_custom_field_updates: Assign a custom field to the resulting incident.
        :param _builtins.str priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param _builtins.str route_to: The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        :param _builtins.str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param _builtins.bool suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param _builtins.int suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param Sequence['EventOrchestrationGlobalCatchAllActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if drop_event is not None:
            pulumi.set(__self__, "drop_event", drop_event)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if incident_custom_field_updates is not None:
            pulumi.set(__self__, "incident_custom_field_updates", incident_custom_field_updates)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def annotate(self) -> Optional[_builtins.str]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @_builtins.property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional['outputs.EventOrchestrationGlobalCatchAllActionsAutomationAction']:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
        """
        return pulumi.get(self, "automation_action")

    @_builtins.property
    @pulumi.getter(name="dropEvent")
    def drop_event(self) -> Optional[_builtins.bool]:
        """
        When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        """
        return pulumi.get(self, "drop_event")

    @_builtins.property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[_builtins.str]:
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        return pulumi.get(self, "escalation_policy")

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[_builtins.str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @_builtins.property
    @pulumi.getter(name="incidentCustomFieldUpdates")
    def incident_custom_field_updates(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate']]:
        """
        Assign a custom field to the resulting incident.
        """
        return pulumi.get(self, "incident_custom_field_updates")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.str]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[_builtins.str]:
        """
        The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[_builtins.bool]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @_builtins.property
    @pulumi.getter
    def suspend(self) -> Optional[_builtins.int]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationGlobalCatchAllActionsAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSend":
            suggest = "auto_send"
        elif key == "triggerTypes":
            suggest = "trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationGlobalCatchAllActionsAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationGlobalCatchAllActionsAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationGlobalCatchAllActionsAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 url: _builtins.str,
                 auto_send: Optional[_builtins.bool] = None,
                 headers: Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsAutomationActionHeader']] = None,
                 parameters: Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsAutomationActionParameter']] = None,
                 trigger_types: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of this Webhook.
        :param _builtins.str url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param _builtins.bool auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param Sequence['EventOrchestrationGlobalCatchAllActionsAutomationActionHeaderArgs'] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param Sequence['EventOrchestrationGlobalCatchAllActionsAutomationActionParameterArgs'] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        :param _builtins.str trigger_types: The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`. NOTE: `auto_send` must be `true` for trigger types of `["alert_suspended"]` and `["alert_suppressed"]`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if trigger_types is not None:
            pulumi.set(__self__, "trigger_types", trigger_types)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[_builtins.bool]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsAutomationActionHeader']]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalCatchAllActionsAutomationActionParameter']]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="triggerTypes")
    def trigger_types(self) -> Optional[_builtins.str]:
        """
        The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`. NOTE: `auto_send` must be `true` for trigger types of `["alert_suspended"]` and `["alert_suppressed"]`
        """
        return pulumi.get(self, "trigger_types")


@pulumi.output_type
class EventOrchestrationGlobalCatchAllActionsAutomationActionHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Name to identify the header
        :param _builtins.str value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationGlobalCatchAllActionsAutomationActionParameter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Name to identify the parameter
        :param _builtins.str value: Value of this parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of this parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationGlobalCatchAllActionsExtraction(dict):
    def __init__(__self__, *,
                 target: _builtins.str,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param _builtins.str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param _builtins.str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationGlobalCatchAllActionsIncidentCustomFieldUpdate(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The custom field id
        :param _builtins.str value: The value to assign to this custom field
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The custom field id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to assign to this custom field
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationGlobalCatchAllActionsVariable(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the variable
        :param _builtins.str path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param _builtins.str type: Only `regex` is supported
        :param _builtins.str value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationGlobalSet(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 rules: Optional[Sequence['outputs.EventOrchestrationGlobalSetRule']] = None):
        """
        :param _builtins.str id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalSetRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class EventOrchestrationGlobalSetRule(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationGlobalSetRuleActions',
                 conditions: Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleCondition']] = None,
                 disabled: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None):
        """
        :param 'EventOrchestrationGlobalSetRuleActionsArgs' actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param Sequence['EventOrchestrationGlobalSetRuleConditionArgs'] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param _builtins.bool disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param _builtins.str id: The ID of the rule within the set.
        :param _builtins.str label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationGlobalSetRuleActions':
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleCondition']]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the rule within the set.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class EventOrchestrationGlobalSetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationAction":
            suggest = "automation_action"
        elif key == "dropEvent":
            suggest = "drop_event"
        elif key == "escalationPolicy":
            suggest = "escalation_policy"
        elif key == "eventAction":
            suggest = "event_action"
        elif key == "incidentCustomFieldUpdates":
            suggest = "incident_custom_field_updates"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationGlobalSetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationGlobalSetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationGlobalSetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotate: Optional[_builtins.str] = None,
                 automation_action: Optional['outputs.EventOrchestrationGlobalSetRuleActionsAutomationAction'] = None,
                 drop_event: Optional[_builtins.bool] = None,
                 escalation_policy: Optional[_builtins.str] = None,
                 event_action: Optional[_builtins.str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsExtraction']] = None,
                 incident_custom_field_updates: Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate']] = None,
                 priority: Optional[_builtins.str] = None,
                 route_to: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None,
                 suppress: Optional[_builtins.bool] = None,
                 suspend: Optional[_builtins.int] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsVariable']] = None):
        """
        :param _builtins.str annotate: Add this text as a note on the resulting incident.
        :param 'EventOrchestrationGlobalSetRuleActionsAutomationActionArgs' automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
        :param _builtins.bool drop_event: When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        :param _builtins.str escalation_policy: The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        :param _builtins.str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationGlobalSetRuleActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param Sequence['EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdateArgs'] incident_custom_field_updates: Assign a custom field to the resulting incident.
        :param _builtins.str priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param _builtins.str route_to: The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        :param _builtins.str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param _builtins.bool suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param _builtins.int suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param Sequence['EventOrchestrationGlobalSetRuleActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if drop_event is not None:
            pulumi.set(__self__, "drop_event", drop_event)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if incident_custom_field_updates is not None:
            pulumi.set(__self__, "incident_custom_field_updates", incident_custom_field_updates)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def annotate(self) -> Optional[_builtins.str]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @_builtins.property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional['outputs.EventOrchestrationGlobalSetRuleActionsAutomationAction']:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
        """
        return pulumi.get(self, "automation_action")

    @_builtins.property
    @pulumi.getter(name="dropEvent")
    def drop_event(self) -> Optional[_builtins.bool]:
        """
        When true, this event will be dropped. Dropped events will not trigger or resolve an alert or an incident. Dropped events will not be evaluated against router rules.
        """
        return pulumi.get(self, "drop_event")

    @_builtins.property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[_builtins.str]:
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        return pulumi.get(self, "escalation_policy")

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[_builtins.str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @_builtins.property
    @pulumi.getter(name="incidentCustomFieldUpdates")
    def incident_custom_field_updates(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate']]:
        """
        Assign a custom field to the resulting incident.
        """
        return pulumi.get(self, "incident_custom_field_updates")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.str]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[_builtins.str]:
        """
        The ID of a Set from this Global Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[_builtins.bool]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @_builtins.property
    @pulumi.getter
    def suspend(self) -> Optional[_builtins.int]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationGlobalSetRuleActionsAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSend":
            suggest = "auto_send"
        elif key == "triggerTypes":
            suggest = "trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationGlobalSetRuleActionsAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationGlobalSetRuleActionsAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationGlobalSetRuleActionsAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 url: _builtins.str,
                 auto_send: Optional[_builtins.bool] = None,
                 headers: Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsAutomationActionHeader']] = None,
                 parameters: Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsAutomationActionParameter']] = None,
                 trigger_types: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of this Webhook.
        :param _builtins.str url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param _builtins.bool auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param Sequence['EventOrchestrationGlobalSetRuleActionsAutomationActionHeaderArgs'] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param Sequence['EventOrchestrationGlobalSetRuleActionsAutomationActionParameterArgs'] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        :param _builtins.str trigger_types: The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`. NOTE: `auto_send` must be `true` for trigger types of `["alert_suspended"]` and `["alert_suppressed"]`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if trigger_types is not None:
            pulumi.set(__self__, "trigger_types", trigger_types)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[_builtins.bool]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsAutomationActionHeader']]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.EventOrchestrationGlobalSetRuleActionsAutomationActionParameter']]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="triggerTypes")
    def trigger_types(self) -> Optional[_builtins.str]:
        """
        The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`. NOTE: `auto_send` must be `true` for trigger types of `["alert_suspended"]` and `["alert_suppressed"]`
        """
        return pulumi.get(self, "trigger_types")


@pulumi.output_type
class EventOrchestrationGlobalSetRuleActionsAutomationActionHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Name to identify the header
        :param _builtins.str value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationGlobalSetRuleActionsAutomationActionParameter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Name to identify the parameter
        :param _builtins.str value: Value of this parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of this parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationGlobalSetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 target: _builtins.str,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param _builtins.str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param _builtins.str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationGlobalSetRuleActionsIncidentCustomFieldUpdate(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The custom field id
        :param _builtins.str value: The value to assign to this custom field
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The custom field id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to assign to this custom field
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationGlobalSetRuleActionsVariable(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the variable
        :param _builtins.str path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param _builtins.str type: Only `regex` is supported
        :param _builtins.str value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationGlobalSetRuleCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class EventOrchestrationIntegration(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence['outputs.EventOrchestrationIntegrationParameter']] = None):
        """
        :param _builtins.str id: ID of the integration
        :param Sequence['EventOrchestrationIntegrationParameterArgs'] parameters: A single-item list containing a parameter object describing the integration
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.EventOrchestrationIntegrationParameter']]:
        """
        A single-item list containing a parameter object describing the integration
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class EventOrchestrationIntegrationParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingKey":
            suggest = "routing_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationIntegrationParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationIntegrationParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationIntegrationParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 routing_key: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str routing_key: Routing key that routes to this Orchestration.
        :param _builtins.str type: Type of the routing key. `global` is the default type.
        """
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[_builtins.str]:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EventOrchestrationRouterCatchAll(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationRouterCatchAllActions'):
        """
        :param 'EventOrchestrationRouterCatchAllActionsArgs' actions: These are the actions that will be taken to change the resulting alert and incident.
        """
        pulumi.set(__self__, "actions", actions)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationRouterCatchAllActions':
        """
        These are the actions that will be taken to change the resulting alert and incident.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class EventOrchestrationRouterCatchAllActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationRouterCatchAllActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationRouterCatchAllActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationRouterCatchAllActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route_to: _builtins.str):
        """
        :param _builtins.str route_to: Defines where an alert will be sent if doesn't match any rules. Can either be the ID of a Service _or_ the string `"unrouted"` to send events to the Unrouted Orchestration.
        """
        pulumi.set(__self__, "route_to", route_to)

    @_builtins.property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> _builtins.str:
        """
        Defines where an alert will be sent if doesn't match any rules. Can either be the ID of a Service _or_ the string `"unrouted"` to send events to the Unrouted Orchestration.
        """
        return pulumi.get(self, "route_to")


@pulumi.output_type
class EventOrchestrationRouterSet(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 rules: Optional[Sequence['outputs.EventOrchestrationRouterSetRule']] = None):
        """
        :param _builtins.str id: ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EventOrchestrationRouterSetRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class EventOrchestrationRouterSetRule(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationRouterSetRuleActions',
                 conditions: Optional[Sequence['outputs.EventOrchestrationRouterSetRuleCondition']] = None,
                 disabled: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None):
        """
        :param 'EventOrchestrationRouterSetRuleActionsArgs' actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param Sequence['EventOrchestrationRouterSetRuleConditionArgs'] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        :param _builtins.bool disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param _builtins.str id: The ID of the rule within the `start` set.
        :param _builtins.str label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationRouterSetRuleActions':
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.EventOrchestrationRouterSetRuleCondition']]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the rule within the `start` set.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class EventOrchestrationRouterSetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dynamicRouteTos":
            suggest = "dynamic_route_tos"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationRouterSetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationRouterSetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationRouterSetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dynamic_route_tos: Optional[Sequence['outputs.EventOrchestrationRouterSetRuleActionsDynamicRouteTo']] = None,
                 route_to: Optional[_builtins.str] = None):
        """
        :param Sequence['EventOrchestrationRouterSetRuleActionsDynamicRouteToArgs'] dynamic_route_tos: supports the following:
        """
        if dynamic_route_tos is not None:
            pulumi.set(__self__, "dynamic_route_tos", dynamic_route_tos)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)

    @_builtins.property
    @pulumi.getter(name="dynamicRouteTos")
    def dynamic_route_tos(self) -> Optional[Sequence['outputs.EventOrchestrationRouterSetRuleActionsDynamicRouteTo']]:
        """
        supports the following:
        """
        return pulumi.get(self, "dynamic_route_tos")

    @_builtins.property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "route_to")


@pulumi.output_type
class EventOrchestrationRouterSetRuleActionsDynamicRouteTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lookupBy":
            suggest = "lookup_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationRouterSetRuleActionsDynamicRouteTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationRouterSetRuleActionsDynamicRouteTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationRouterSetRuleActionsDynamicRouteTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lookup_by: _builtins.str,
                 regex: _builtins.str,
                 source: _builtins.str):
        """
        :param _builtins.str lookup_by: Indicates whether the extracted value from the source is a service's name or ID. Allowed values are: `service_name`, `service_id`
               
               If an event has a value at the specified `source`, and if the `regex` successfully matches the value, and if the matching portion is valid Service ID or Name, then the event will be routed to that service. Otherwise the event will be checked against any subsequent router rules.
        :param _builtins.str regex: The regular expression, used to extract a value from the source field. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        :param _builtins.str source: The path to a field in an event.
        """
        pulumi.set(__self__, "lookup_by", lookup_by)
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "source", source)

    @_builtins.property
    @pulumi.getter(name="lookupBy")
    def lookup_by(self) -> _builtins.str:
        """
        Indicates whether the extracted value from the source is a service's name or ID. Allowed values are: `service_name`, `service_id`

        If an event has a value at the specified `source`, and if the `regex` successfully matches the value, and if the matching portion is valid Service ID or Name, then the event will be routed to that service. Otherwise the event will be checked against any subsequent router rules.
        """
        return pulumi.get(self, "lookup_by")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        The regular expression, used to extract a value from the source field. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The path to a field in an event.
        """
        return pulumi.get(self, "source")


@pulumi.output_type
class EventOrchestrationRouterSetRuleCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class EventOrchestrationServiceCacheVariableCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class EventOrchestrationServiceCacheVariableConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ttlSeconds":
            suggest = "ttl_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceCacheVariableConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceCacheVariableConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceCacheVariableConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 data_type: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 ttl_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.str type: The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value`, `trigger_event_count` or `external_data`.
        :param _builtins.str data_type: The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `external_data`
        :param _builtins.str regex: A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        :param _builtins.int ttl_seconds: The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count` or `external_data`
        """
        pulumi.set(__self__, "type", type)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if ttl_seconds is not None:
            pulumi.set(__self__, "ttl_seconds", ttl_seconds)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value`, `trigger_event_count` or `external_data`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `external_data`
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count` or `external_data`
        """
        return pulumi.get(self, "ttl_seconds")


@pulumi.output_type
class EventOrchestrationServiceCatchAll(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationServiceCatchAllActions'):
        """
        :param 'EventOrchestrationServiceCatchAllActionsArgs' actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        pulumi.set(__self__, "actions", actions)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationServiceCatchAllActions':
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationAction":
            suggest = "automation_action"
        elif key == "escalationPolicy":
            suggest = "escalation_policy"
        elif key == "eventAction":
            suggest = "event_action"
        elif key == "incidentCustomFieldUpdates":
            suggest = "incident_custom_field_updates"
        elif key == "pagerdutyAutomationAction":
            suggest = "pagerduty_automation_action"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceCatchAllActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceCatchAllActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceCatchAllActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotate: Optional[_builtins.str] = None,
                 automation_action: Optional['outputs.EventOrchestrationServiceCatchAllActionsAutomationAction'] = None,
                 escalation_policy: Optional[_builtins.str] = None,
                 event_action: Optional[_builtins.str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsExtraction']] = None,
                 incident_custom_field_updates: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate']] = None,
                 pagerduty_automation_action: Optional['outputs.EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction'] = None,
                 priority: Optional[_builtins.str] = None,
                 route_to: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None,
                 suppress: Optional[_builtins.bool] = None,
                 suspend: Optional[_builtins.int] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsVariable']] = None):
        """
        :param _builtins.str annotate: Add this text as a note on the resulting incident.
        :param 'EventOrchestrationServiceCatchAllActionsAutomationActionArgs' automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
        :param _builtins.str escalation_policy: The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        :param _builtins.str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationServiceCatchAllActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param Sequence['EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdateArgs'] incident_custom_field_updates: Assign a custom field to the resulting incident.
        :param 'EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs' pagerduty_automation_action: Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) to be run for certain alert states.
        :param _builtins.str priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param _builtins.str route_to: The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        :param _builtins.str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param _builtins.bool suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param _builtins.int suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param Sequence['EventOrchestrationServiceCatchAllActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if incident_custom_field_updates is not None:
            pulumi.set(__self__, "incident_custom_field_updates", incident_custom_field_updates)
        if pagerduty_automation_action is not None:
            pulumi.set(__self__, "pagerduty_automation_action", pagerduty_automation_action)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def annotate(self) -> Optional[_builtins.str]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @_builtins.property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional['outputs.EventOrchestrationServiceCatchAllActionsAutomationAction']:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
        """
        return pulumi.get(self, "automation_action")

    @_builtins.property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[_builtins.str]:
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        return pulumi.get(self, "escalation_policy")

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[_builtins.str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @_builtins.property
    @pulumi.getter(name="incidentCustomFieldUpdates")
    def incident_custom_field_updates(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate']]:
        """
        Assign a custom field to the resulting incident.
        """
        return pulumi.get(self, "incident_custom_field_updates")

    @_builtins.property
    @pulumi.getter(name="pagerdutyAutomationAction")
    def pagerduty_automation_action(self) -> Optional['outputs.EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction']:
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) to be run for certain alert states.
        """
        return pulumi.get(self, "pagerduty_automation_action")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.str]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="routeTo")
    @_utilities.deprecated("""The 'route_to' attribute is no longer supported for catch-all rules.""")
    def route_to(self) -> Optional[_builtins.str]:
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[_builtins.bool]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @_builtins.property
    @pulumi.getter
    def suspend(self) -> Optional[_builtins.int]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSend":
            suggest = "auto_send"
        elif key == "triggerTypes":
            suggest = "trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceCatchAllActionsAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceCatchAllActionsAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceCatchAllActionsAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 url: _builtins.str,
                 auto_send: Optional[_builtins.bool] = None,
                 headers: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsAutomationActionHeader']] = None,
                 parameters: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsAutomationActionParameter']] = None,
                 trigger_types: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of this Webhook.
        :param _builtins.str url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param _builtins.bool auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param Sequence['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs'] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param Sequence['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs'] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        :param _builtins.str trigger_types: The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`. NOTE: `auto_send` must be `true` for trigger types of `["alert_suspended"]` and `["alert_suppressed"]`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if trigger_types is not None:
            pulumi.set(__self__, "trigger_types", trigger_types)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[_builtins.bool]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsAutomationActionHeader']]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsAutomationActionParameter']]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="triggerTypes")
    def trigger_types(self) -> Optional[_builtins.str]:
        """
        The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`. NOTE: `auto_send` must be `true` for trigger types of `["alert_suspended"]` and `["alert_suppressed"]`
        """
        return pulumi.get(self, "trigger_types")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsAutomationActionHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Name to identify the header
        :param _builtins.str value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsAutomationActionParameter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Name to identify the parameter
        :param _builtins.str value: Value of this parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of this parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsExtraction(dict):
    def __init__(__self__, *,
                 target: _builtins.str,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param _builtins.str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param _builtins.str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsIncidentCustomFieldUpdate(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The custom field id
        :param _builtins.str value: The value to assign to this custom field
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The custom field id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to assign to this custom field
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionId":
            suggest = "action_id"
        elif key == "triggerTypes":
            suggest = "trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_id: _builtins.str,
                 trigger_types: Optional[_builtins.str] = None):
        """
        :param _builtins.str action_id: Id of the Process Automation action to be triggered.
        :param _builtins.str trigger_types: The Automation Action will be triggered whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`
        """
        pulumi.set(__self__, "action_id", action_id)
        if trigger_types is not None:
            pulumi.set(__self__, "trigger_types", trigger_types)

    @_builtins.property
    @pulumi.getter(name="actionId")
    def action_id(self) -> _builtins.str:
        """
        Id of the Process Automation action to be triggered.
        """
        return pulumi.get(self, "action_id")

    @_builtins.property
    @pulumi.getter(name="triggerTypes")
    def trigger_types(self) -> Optional[_builtins.str]:
        """
        The Automation Action will be triggered whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`
        """
        return pulumi.get(self, "trigger_types")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsVariable(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the variable
        :param _builtins.str path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param _builtins.str type: Only `regex` is supported
        :param _builtins.str value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSet(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 rules: Optional[Sequence['outputs.EventOrchestrationServiceSetRule']] = None):
        """
        :param _builtins.str id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class EventOrchestrationServiceSetRule(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationServiceSetRuleActions',
                 conditions: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleCondition']] = None,
                 disabled: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None):
        """
        :param 'EventOrchestrationServiceSetRuleActionsArgs' actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param Sequence['EventOrchestrationServiceSetRuleConditionArgs'] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param _builtins.bool disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param _builtins.str id: The ID of the rule within the set.
        :param _builtins.str label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationServiceSetRuleActions':
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleCondition']]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the rule within the set.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationAction":
            suggest = "automation_action"
        elif key == "escalationPolicy":
            suggest = "escalation_policy"
        elif key == "eventAction":
            suggest = "event_action"
        elif key == "incidentCustomFieldUpdates":
            suggest = "incident_custom_field_updates"
        elif key == "pagerdutyAutomationAction":
            suggest = "pagerduty_automation_action"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceSetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceSetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceSetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotate: Optional[_builtins.str] = None,
                 automation_action: Optional['outputs.EventOrchestrationServiceSetRuleActionsAutomationAction'] = None,
                 escalation_policy: Optional[_builtins.str] = None,
                 event_action: Optional[_builtins.str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsExtraction']] = None,
                 incident_custom_field_updates: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate']] = None,
                 pagerduty_automation_action: Optional['outputs.EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction'] = None,
                 priority: Optional[_builtins.str] = None,
                 route_to: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None,
                 suppress: Optional[_builtins.bool] = None,
                 suspend: Optional[_builtins.int] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsVariable']] = None):
        """
        :param _builtins.str annotate: Add this text as a note on the resulting incident.
        :param 'EventOrchestrationServiceSetRuleActionsAutomationActionArgs' automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
        :param _builtins.str escalation_policy: The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        :param _builtins.str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationServiceSetRuleActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param Sequence['EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdateArgs'] incident_custom_field_updates: Assign a custom field to the resulting incident.
        :param 'EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs' pagerduty_automation_action: Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) to be run for certain alert states.
        :param _builtins.str priority: The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        :param _builtins.str route_to: The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        :param _builtins.str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param _builtins.bool suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param _builtins.int suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        :param Sequence['EventOrchestrationServiceSetRuleActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if escalation_policy is not None:
            pulumi.set(__self__, "escalation_policy", escalation_policy)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if incident_custom_field_updates is not None:
            pulumi.set(__self__, "incident_custom_field_updates", incident_custom_field_updates)
        if pagerduty_automation_action is not None:
            pulumi.set(__self__, "pagerduty_automation_action", pagerduty_automation_action)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter
    def annotate(self) -> Optional[_builtins.str]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @_builtins.property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional['outputs.EventOrchestrationServiceSetRuleActionsAutomationAction']:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) to be run for certain alert states.
        """
        return pulumi.get(self, "automation_action")

    @_builtins.property
    @pulumi.getter(name="escalationPolicy")
    def escalation_policy(self) -> Optional[_builtins.str]:
        """
        The ID of the Escalation Policy you want to assign incidents to. Event rules with this action will override the Escalation Policy already set on a Service's settings, with what is configured by this action.
        """
        return pulumi.get(self, "escalation_policy")

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[_builtins.str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @_builtins.property
    @pulumi.getter(name="incidentCustomFieldUpdates")
    def incident_custom_field_updates(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate']]:
        """
        Assign a custom field to the resulting incident.
        """
        return pulumi.get(self, "incident_custom_field_updates")

    @_builtins.property
    @pulumi.getter(name="pagerdutyAutomationAction")
    def pagerduty_automation_action(self) -> Optional['outputs.EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction']:
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) to be run for certain alert states.
        """
        return pulumi.get(self, "pagerduty_automation_action")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.str]:
        """
        The ID of the priority you want to set on resulting incident. Consider using the `get_priority` data source.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[_builtins.str]:
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[_builtins.bool]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @_builtins.property
    @pulumi.getter
    def suspend(self) -> Optional[_builtins.int]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this alert.
        """
        return pulumi.get(self, "suspend")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSend":
            suggest = "auto_send"
        elif key == "triggerTypes":
            suggest = "trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceSetRuleActionsAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceSetRuleActionsAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceSetRuleActionsAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 url: _builtins.str,
                 auto_send: Optional[_builtins.bool] = None,
                 headers: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsAutomationActionHeader']] = None,
                 parameters: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsAutomationActionParameter']] = None,
                 trigger_types: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Name of this Webhook.
        :param _builtins.str url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param _builtins.bool auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param Sequence['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs'] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param Sequence['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs'] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        :param _builtins.str trigger_types: The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`. NOTE: `auto_send` must be `true` for trigger types of `["alert_suspended"]` and `["alert_suppressed"]`
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if trigger_types is not None:
            pulumi.set(__self__, "trigger_types", trigger_types)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[_builtins.bool]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident or alert is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsAutomationActionHeader']]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsAutomationActionParameter']]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter(name="triggerTypes")
    def trigger_types(self) -> Optional[_builtins.str]:
        """
        The Webhook will be associated (or automatically triggered, if `auto_send` is `true`) with the incident or alert, whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`. NOTE: `auto_send` must be `true` for trigger types of `["alert_suspended"]` and `["alert_suppressed"]`
        """
        return pulumi.get(self, "trigger_types")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsAutomationActionHeader(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Name to identify the header
        :param _builtins.str value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsAutomationActionParameter(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str key: Name to identify the parameter
        :param _builtins.str value: Value of this parameter
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Name to identify the parameter
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Value of this parameter
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 target: _builtins.str,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param _builtins.str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param _builtins.str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsIncidentCustomFieldUpdate(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The custom field id
        :param _builtins.str value: The value to assign to this custom field
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The custom field id
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to assign to this custom field
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionId":
            suggest = "action_id"
        elif key == "triggerTypes":
            suggest = "trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_id: _builtins.str,
                 trigger_types: Optional[_builtins.str] = None):
        """
        :param _builtins.str action_id: Id of the Process Automation action to be triggered.
        :param _builtins.str trigger_types: The Automation Action will be triggered whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`
        """
        pulumi.set(__self__, "action_id", action_id)
        if trigger_types is not None:
            pulumi.set(__self__, "trigger_types", trigger_types)

    @_builtins.property
    @pulumi.getter(name="actionId")
    def action_id(self) -> _builtins.str:
        """
        Id of the Process Automation action to be triggered.
        """
        return pulumi.get(self, "action_id")

    @_builtins.property
    @pulumi.getter(name="triggerTypes")
    def trigger_types(self) -> Optional[_builtins.str]:
        """
        The Automation Action will be triggered whenever an alert reaches the specified state. Allowed values are: `["alert_triggered"]`, `["alert_suspended"]`, `["alert_suppressed"]`
        """
        return pulumi.get(self, "trigger_types")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsVariable(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the variable
        :param _builtins.str path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param _builtins.str type: Only `regex` is supported
        :param _builtins.str value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSetRuleCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class EventOrchestrationUnroutedCatchAll(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationUnroutedCatchAllActions'):
        """
        :param 'EventOrchestrationUnroutedCatchAllActionsArgs' actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        pulumi.set(__self__, "actions", actions)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationUnroutedCatchAllActions':
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class EventOrchestrationUnroutedCatchAllActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventAction":
            suggest = "event_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationUnroutedCatchAllActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationUnroutedCatchAllActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationUnroutedCatchAllActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_action: Optional[_builtins.str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationUnroutedCatchAllActionsExtraction']] = None,
                 severity: Optional[_builtins.str] = None,
                 suppress: Optional[_builtins.bool] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationUnroutedCatchAllActionsVariable']] = None):
        """
        :param _builtins.str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationUnroutedCatchAllActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param _builtins.str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param Sequence['EventOrchestrationUnroutedCatchAllActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[_builtins.str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedCatchAllActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def suppress(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "suppress")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedCatchAllActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationUnroutedCatchAllActionsExtraction(dict):
    def __init__(__self__, *,
                 target: _builtins.str,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param _builtins.str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param _builtins.str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationUnroutedCatchAllActionsVariable(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the variable
        :param _builtins.str path: Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        :param _builtins.str type: Only `regex` is supported
        :param _builtins.str value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationUnroutedSet(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 rules: Optional[Sequence['outputs.EventOrchestrationUnroutedSetRule']] = None):
        """
        :param _builtins.str id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedSetRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class EventOrchestrationUnroutedSetRule(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationUnroutedSetRuleActions',
                 conditions: Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleCondition']] = None,
                 disabled: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 label: Optional[_builtins.str] = None):
        """
        :param 'EventOrchestrationUnroutedSetRuleActionsArgs' actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param Sequence['EventOrchestrationUnroutedSetRuleConditionArgs'] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param _builtins.bool disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param _builtins.str id: The ID of the rule within the set.
        :param _builtins.str label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationUnroutedSetRuleActions':
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleCondition']]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the rule within the set.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> Optional[_builtins.str]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class EventOrchestrationUnroutedSetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventAction":
            suggest = "event_action"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationUnroutedSetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationUnroutedSetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationUnroutedSetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_action: Optional[_builtins.str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleActionsExtraction']] = None,
                 route_to: Optional[_builtins.str] = None,
                 severity: Optional[_builtins.str] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleActionsVariable']] = None):
        """
        :param _builtins.str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationUnroutedSetRuleActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param _builtins.str route_to: The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
        :param _builtins.str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param Sequence['EventOrchestrationUnroutedSetRuleActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @_builtins.property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[_builtins.str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @_builtins.property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @_builtins.property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[_builtins.str]:
        """
        The ID of a Set from this Unrouted Orchestration whose rules you also want to use with events that match this rule.
        """
        return pulumi.get(self, "route_to")

    @_builtins.property
    @pulumi.getter
    def severity(self) -> Optional[_builtins.str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @_builtins.property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationUnroutedSetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 target: _builtins.str,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param _builtins.str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param _builtins.str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def target(self) -> _builtins.str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationUnroutedSetRuleActionsVariable(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 path: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str name: The name of the variable
        :param _builtins.str path: Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        :param _builtins.str type: Only `regex` is supported
        :param _builtins.str value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationUnroutedSetRuleCondition(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class IncidentWorkflowStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inlineStepsInputs":
            suggest = "inline_steps_inputs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentWorkflowStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentWorkflowStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentWorkflowStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 id: Optional[_builtins.str] = None,
                 inline_steps_inputs: Optional[Sequence['outputs.IncidentWorkflowStepInlineStepsInput']] = None,
                 inputs: Optional[Sequence['outputs.IncidentWorkflowStepInput']] = None):
        """
        :param _builtins.str action: The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        :param _builtins.str name: The name of the workflow step.
        :param _builtins.str id: The ID of the incident workflow.
        :param Sequence['IncidentWorkflowStepInlineStepsInputArgs'] inline_steps_inputs: The list of inputs that contain a series of inline steps for the workflow action.
        :param Sequence['IncidentWorkflowStepInputArgs'] inputs: The list of standard inputs for the workflow action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if inline_steps_inputs is not None:
            pulumi.set(__self__, "inline_steps_inputs", inline_steps_inputs)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the workflow step.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the incident workflow.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="inlineStepsInputs")
    def inline_steps_inputs(self) -> Optional[Sequence['outputs.IncidentWorkflowStepInlineStepsInput']]:
        """
        The list of inputs that contain a series of inline steps for the workflow action.
        """
        return pulumi.get(self, "inline_steps_inputs")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.IncidentWorkflowStepInput']]:
        """
        The list of standard inputs for the workflow action.
        """
        return pulumi.get(self, "inputs")


@pulumi.output_type
class IncidentWorkflowStepInlineStepsInput(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 steps: Optional[Sequence['outputs.IncidentWorkflowStepInlineStepsInputStep']] = None):
        """
        :param _builtins.str name: The name of the input.
        :param Sequence['IncidentWorkflowStepInlineStepsInputStepArgs'] steps: The inline steps of the input. An inline step adheres to the step schema described above.
        """
        pulumi.set(__self__, "name", name)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the input.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[Sequence['outputs.IncidentWorkflowStepInlineStepsInputStep']]:
        """
        The inline steps of the input. An inline step adheres to the step schema described above.
        """
        return pulumi.get(self, "steps")


@pulumi.output_type
class IncidentWorkflowStepInlineStepsInputStep(dict):
    def __init__(__self__, *,
                 action: _builtins.str,
                 name: _builtins.str,
                 inputs: Optional[Sequence['outputs.IncidentWorkflowStepInlineStepsInputStepInput']] = None):
        """
        :param _builtins.str action: The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        :param _builtins.str name: The name of the workflow step.
        :param Sequence['IncidentWorkflowStepInlineStepsInputStepInputArgs'] inputs: The list of standard inputs for the workflow action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the workflow step.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.IncidentWorkflowStepInlineStepsInputStepInput']]:
        """
        The list of standard inputs for the workflow action.
        """
        return pulumi.get(self, "inputs")


@pulumi.output_type
class IncidentWorkflowStepInlineStepsInputStepInput(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 generated: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the input.
        :param _builtins.str value: The value of the input.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if generated is not None:
            pulumi.set(__self__, "generated", generated)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the input.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the input.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def generated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "generated")


@pulumi.output_type
class IncidentWorkflowStepInput(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str,
                 generated: Optional[_builtins.bool] = None):
        """
        :param _builtins.str name: The name of the input.
        :param _builtins.str value: The value of the input.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if generated is not None:
            pulumi.set(__self__, "generated", generated)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the input.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the input.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def generated(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "generated")


@pulumi.output_type
class IncidentWorkflowTriggerPermissions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "teamId":
            suggest = "team_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IncidentWorkflowTriggerPermissions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IncidentWorkflowTriggerPermissions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IncidentWorkflowTriggerPermissions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 restricted: Optional[_builtins.bool] = None,
                 team_id: Optional[_builtins.str] = None):
        """
        :param _builtins.bool restricted: If `true`, indicates that the Trigger can only be started by authorized Users. If `false` (default), any user can start this Trigger. Applicable only to `manual`-type triggers.
        :param _builtins.str team_id: The ID of the Team whose members can manually start this Trigger. Required and allowed only if `restricted` is `true`.
        """
        if restricted is not None:
            pulumi.set(__self__, "restricted", restricted)
        if team_id is not None:
            pulumi.set(__self__, "team_id", team_id)

    @_builtins.property
    @pulumi.getter
    def restricted(self) -> Optional[_builtins.bool]:
        """
        If `true`, indicates that the Trigger can only be started by authorized Users. If `false` (default), any user can start this Trigger. Applicable only to `manual`-type triggers.
        """
        return pulumi.get(self, "restricted")

    @_builtins.property
    @pulumi.getter(name="teamId")
    def team_id(self) -> Optional[_builtins.str]:
        """
        The ID of the Team whose members can manually start this Trigger. Required and allowed only if `restricted` is `true`.
        """
        return pulumi.get(self, "team_id")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfig(dict):
    def __init__(__self__, *,
                 service: _builtins.str,
                 jira: Optional['outputs.JiraCloudAccountMappingRuleConfigJira'] = None):
        """
        :param _builtins.str service: [Updating can cause a resource replacement] The ID of the linked PagerDuty service.
        :param 'JiraCloudAccountMappingRuleConfigJiraArgs' jira: Synchronization settings.
        """
        pulumi.set(__self__, "service", service)
        if jira is not None:
            pulumi.set(__self__, "jira", jira)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        [Updating can cause a resource replacement] The ID of the linked PagerDuty service.
        """
        return pulumi.get(self, "service")

    @_builtins.property
    @pulumi.getter
    def jira(self) -> Optional['outputs.JiraCloudAccountMappingRuleConfigJira']:
        """
        Synchronization settings.
        """
        return pulumi.get(self, "jira")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJira(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autocreateJql":
            suggest = "autocreate_jql"
        elif key == "createIssueOnIncidentTrigger":
            suggest = "create_issue_on_incident_trigger"
        elif key == "customFields":
            suggest = "custom_fields"
        elif key == "issueType":
            suggest = "issue_type"
        elif key == "statusMapping":
            suggest = "status_mapping"
        elif key == "syncNotesUser":
            suggest = "sync_notes_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JiraCloudAccountMappingRuleConfigJira. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JiraCloudAccountMappingRuleConfigJira.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JiraCloudAccountMappingRuleConfigJira.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autocreate_jql: Optional[_builtins.str] = None,
                 create_issue_on_incident_trigger: Optional[_builtins.bool] = None,
                 custom_fields: Optional[Sequence['outputs.JiraCloudAccountMappingRuleConfigJiraCustomField']] = None,
                 issue_type: Optional['outputs.JiraCloudAccountMappingRuleConfigJiraIssueType'] = None,
                 priorities: Optional[Sequence['outputs.JiraCloudAccountMappingRuleConfigJiraPriority']] = None,
                 project: Optional['outputs.JiraCloudAccountMappingRuleConfigJiraProject'] = None,
                 status_mapping: Optional['outputs.JiraCloudAccountMappingRuleConfigJiraStatusMapping'] = None,
                 sync_notes_user: Optional[_builtins.str] = None):
        """
        :param _builtins.str autocreate_jql: JQL query to automatically create PagerDuty incidents when matching Jira issues are created. Leave empty to disable this feature.
        :param _builtins.bool create_issue_on_incident_trigger: When enabled, automatically creates a Jira issue whenever a PagerDuty incident is triggered.
        :param Sequence['JiraCloudAccountMappingRuleConfigJiraCustomFieldArgs'] custom_fields: Defines how Jira fields are populated when a Jira Issue is created from a PagerDuty Incident.
        :param 'JiraCloudAccountMappingRuleConfigJiraIssueTypeArgs' issue_type: Specifies the Jira issue type to be created or synchronized with PagerDuty incidents.
        :param Sequence['JiraCloudAccountMappingRuleConfigJiraPriorityArgs'] priorities: Maps PagerDuty incident priorities to Jira issue priorities for synchronization.
        :param 'JiraCloudAccountMappingRuleConfigJiraProjectArgs' project: [Updating can cause a resource replacement] Defines the Jira project where issues will be created or synchronized.
        :param 'JiraCloudAccountMappingRuleConfigJiraStatusMappingArgs' status_mapping: Maps PagerDuty incident statuses to corresponding Jira issue statuses for synchronization.
        :param _builtins.str sync_notes_user: ID of the PagerDuty user for syncing notes and comments between Jira issues and PagerDuty incidents. If not provided, note synchronization is disabled.
        """
        if autocreate_jql is not None:
            pulumi.set(__self__, "autocreate_jql", autocreate_jql)
        if create_issue_on_incident_trigger is not None:
            pulumi.set(__self__, "create_issue_on_incident_trigger", create_issue_on_incident_trigger)
        if custom_fields is not None:
            pulumi.set(__self__, "custom_fields", custom_fields)
        if issue_type is not None:
            pulumi.set(__self__, "issue_type", issue_type)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if project is not None:
            pulumi.set(__self__, "project", project)
        if status_mapping is not None:
            pulumi.set(__self__, "status_mapping", status_mapping)
        if sync_notes_user is not None:
            pulumi.set(__self__, "sync_notes_user", sync_notes_user)

    @_builtins.property
    @pulumi.getter(name="autocreateJql")
    def autocreate_jql(self) -> Optional[_builtins.str]:
        """
        JQL query to automatically create PagerDuty incidents when matching Jira issues are created. Leave empty to disable this feature.
        """
        return pulumi.get(self, "autocreate_jql")

    @_builtins.property
    @pulumi.getter(name="createIssueOnIncidentTrigger")
    def create_issue_on_incident_trigger(self) -> Optional[_builtins.bool]:
        """
        When enabled, automatically creates a Jira issue whenever a PagerDuty incident is triggered.
        """
        return pulumi.get(self, "create_issue_on_incident_trigger")

    @_builtins.property
    @pulumi.getter(name="customFields")
    def custom_fields(self) -> Optional[Sequence['outputs.JiraCloudAccountMappingRuleConfigJiraCustomField']]:
        """
        Defines how Jira fields are populated when a Jira Issue is created from a PagerDuty Incident.
        """
        return pulumi.get(self, "custom_fields")

    @_builtins.property
    @pulumi.getter(name="issueType")
    def issue_type(self) -> Optional['outputs.JiraCloudAccountMappingRuleConfigJiraIssueType']:
        """
        Specifies the Jira issue type to be created or synchronized with PagerDuty incidents.
        """
        return pulumi.get(self, "issue_type")

    @_builtins.property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence['outputs.JiraCloudAccountMappingRuleConfigJiraPriority']]:
        """
        Maps PagerDuty incident priorities to Jira issue priorities for synchronization.
        """
        return pulumi.get(self, "priorities")

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional['outputs.JiraCloudAccountMappingRuleConfigJiraProject']:
        """
        [Updating can cause a resource replacement] Defines the Jira project where issues will be created or synchronized.
        """
        return pulumi.get(self, "project")

    @_builtins.property
    @pulumi.getter(name="statusMapping")
    def status_mapping(self) -> Optional['outputs.JiraCloudAccountMappingRuleConfigJiraStatusMapping']:
        """
        Maps PagerDuty incident statuses to corresponding Jira issue statuses for synchronization.
        """
        return pulumi.get(self, "status_mapping")

    @_builtins.property
    @pulumi.getter(name="syncNotesUser")
    def sync_notes_user(self) -> Optional[_builtins.str]:
        """
        ID of the PagerDuty user for syncing notes and comments between Jira issues and PagerDuty incidents. If not provided, note synchronization is disabled.
        """
        return pulumi.get(self, "sync_notes_user")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJiraCustomField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetIssueField":
            suggest = "target_issue_field"
        elif key == "targetIssueFieldName":
            suggest = "target_issue_field_name"
        elif key == "sourceIncidentField":
            suggest = "source_incident_field"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JiraCloudAccountMappingRuleConfigJiraCustomField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JiraCloudAccountMappingRuleConfigJiraCustomField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JiraCloudAccountMappingRuleConfigJiraCustomField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_issue_field: _builtins.str,
                 target_issue_field_name: _builtins.str,
                 type: _builtins.str,
                 source_incident_field: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str target_issue_field: The unique identifier key of the Jira field that will be set.
        :param _builtins.str target_issue_field_name: The human-readable name of the Jira field.
        :param _builtins.str type: The type of the value that will be set; one of `attribute`, `const` or `jira_value`.
        :param _builtins.str source_incident_field: The PagerDuty incident field from which the value will be extracted (only applicable if `type` is `attribute`); one of `incident_number`, `incident_title`, `incident_description`, `incident_status`, `incident_created_at`, `incident_service`, `incident_escalation_policy`, `incident_impacted_services`, `incident_html_url`, `incident_assignees`, `incident_acknowledgers`, `incident_last_status_change_at`, `incident_last_status_change_by`, `incident_urgency` or `incident_priority`.
        :param _builtins.str value: The value to be set for the Jira field (only applicable if `type` is `const` or `jira_value`). It must be set as a JSON string.
        """
        pulumi.set(__self__, "target_issue_field", target_issue_field)
        pulumi.set(__self__, "target_issue_field_name", target_issue_field_name)
        pulumi.set(__self__, "type", type)
        if source_incident_field is not None:
            pulumi.set(__self__, "source_incident_field", source_incident_field)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="targetIssueField")
    def target_issue_field(self) -> _builtins.str:
        """
        The unique identifier key of the Jira field that will be set.
        """
        return pulumi.get(self, "target_issue_field")

    @_builtins.property
    @pulumi.getter(name="targetIssueFieldName")
    def target_issue_field_name(self) -> _builtins.str:
        """
        The human-readable name of the Jira field.
        """
        return pulumi.get(self, "target_issue_field_name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the value that will be set; one of `attribute`, `const` or `jira_value`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="sourceIncidentField")
    def source_incident_field(self) -> Optional[_builtins.str]:
        """
        The PagerDuty incident field from which the value will be extracted (only applicable if `type` is `attribute`); one of `incident_number`, `incident_title`, `incident_description`, `incident_status`, `incident_created_at`, `incident_service`, `incident_escalation_policy`, `incident_impacted_services`, `incident_html_url`, `incident_assignees`, `incident_acknowledgers`, `incident_last_status_change_at`, `incident_last_status_change_by`, `incident_urgency` or `incident_priority`.
        """
        return pulumi.get(self, "source_incident_field")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value to be set for the Jira field (only applicable if `type` is `const` or `jira_value`). It must be set as a JSON string.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJiraIssueType(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique identifier for the Jira issue type.
        :param _builtins.str name: The name of the Jira issue type.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier for the Jira issue type.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Jira issue type.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJiraPriority(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "jiraId":
            suggest = "jira_id"
        elif key == "pagerdutyId":
            suggest = "pagerduty_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in JiraCloudAccountMappingRuleConfigJiraPriority. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        JiraCloudAccountMappingRuleConfigJiraPriority.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        JiraCloudAccountMappingRuleConfigJiraPriority.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 jira_id: _builtins.str,
                 pagerduty_id: _builtins.str):
        """
        :param _builtins.str jira_id: The ID of the Jira priority.
        :param _builtins.str pagerduty_id: The ID of the PagerDuty priority.
        """
        pulumi.set(__self__, "jira_id", jira_id)
        pulumi.set(__self__, "pagerduty_id", pagerduty_id)

    @_builtins.property
    @pulumi.getter(name="jiraId")
    def jira_id(self) -> _builtins.str:
        """
        The ID of the Jira priority.
        """
        return pulumi.get(self, "jira_id")

    @_builtins.property
    @pulumi.getter(name="pagerdutyId")
    def pagerduty_id(self) -> _builtins.str:
        """
        The ID of the PagerDuty priority.
        """
        return pulumi.get(self, "pagerduty_id")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJiraProject(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 key: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique identifier for the Jira project.
        :param _builtins.str key: The short key name of the Jira project.
        :param _builtins.str name: The name of the Jira project.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier for the Jira project.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        The short key name of the Jira project.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Jira project.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJiraStatusMapping(dict):
    def __init__(__self__, *,
                 acknowledged: Optional['outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledged'] = None,
                 resolved: Optional['outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingResolved'] = None,
                 triggered: Optional['outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggered'] = None):
        """
        :param 'JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledgedArgs' acknowledged: Jira status that maps to the PagerDuty `acknowledged` status.
        :param 'JiraCloudAccountMappingRuleConfigJiraStatusMappingResolvedArgs' resolved: Jira status that maps to the PagerDuty `resolved` status.
        :param 'JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggeredArgs' triggered: Jira status that maps to the PagerDuty `triggered` status.
        """
        if acknowledged is not None:
            pulumi.set(__self__, "acknowledged", acknowledged)
        if resolved is not None:
            pulumi.set(__self__, "resolved", resolved)
        if triggered is not None:
            pulumi.set(__self__, "triggered", triggered)

    @_builtins.property
    @pulumi.getter
    def acknowledged(self) -> Optional['outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledged']:
        """
        Jira status that maps to the PagerDuty `acknowledged` status.
        """
        return pulumi.get(self, "acknowledged")

    @_builtins.property
    @pulumi.getter
    def resolved(self) -> Optional['outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingResolved']:
        """
        Jira status that maps to the PagerDuty `resolved` status.
        """
        return pulumi.get(self, "resolved")

    @_builtins.property
    @pulumi.getter
    def triggered(self) -> Optional['outputs.JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggered']:
        """
        Jira status that maps to the PagerDuty `triggered` status.
        """
        return pulumi.get(self, "triggered")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJiraStatusMappingAcknowledged(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier for the Jira status.
        :param _builtins.str name: Name of the Jira status.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the Jira status.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Jira status.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJiraStatusMappingResolved(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: Unique identifier for the Jira status.
        :param _builtins.str name: Name of the Jira status.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the Jira status.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Jira status.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class JiraCloudAccountMappingRuleConfigJiraStatusMappingTriggered(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: Unique identifier for the Jira status.
        :param _builtins.str name: Name of the Jira status.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Unique identifier for the Jira status.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Jira status.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ResponsePlayResponder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationRules":
            suggest = "escalation_rules"
        elif key == "numLoops":
            suggest = "num_loops"
        elif key == "onCallHandoffNotifications":
            suggest = "on_call_handoff_notifications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponsePlayResponder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponsePlayResponder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponsePlayResponder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 escalation_rules: Optional[Sequence['outputs.ResponsePlayResponderEscalationRule']] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 num_loops: Optional[_builtins.int] = None,
                 on_call_handoff_notifications: Optional[_builtins.str] = None,
                 services: Optional[Sequence['outputs.ResponsePlayResponderService']] = None,
                 teams: Optional[Sequence['outputs.ResponsePlayResponderTeam']] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of escalation policy
        :param Sequence['ResponsePlayResponderEscalationRuleArgs'] escalation_rules: The escalation rules
        :param _builtins.str id: ID of the user defined as the responder
        :param _builtins.str name: Name of the escalation policy
        :param _builtins.int num_loops: The number of times the escalation policy will repeat after reaching the end of its escalation.
        :param _builtins.str on_call_handoff_notifications: Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        :param Sequence['ResponsePlayResponderServiceArgs'] services: There can be multiple services associated with a policy.
        :param Sequence['ResponsePlayResponderTeamArgs'] teams: Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        :param _builtins.str type: Should be set as `escalation_policy` for escalation policy responders.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if escalation_rules is not None:
            pulumi.set(__self__, "escalation_rules", escalation_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_loops is not None:
            pulumi.set(__self__, "num_loops", num_loops)
        if on_call_handoff_notifications is not None:
            pulumi.set(__self__, "on_call_handoff_notifications", on_call_handoff_notifications)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of escalation policy
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="escalationRules")
    def escalation_rules(self) -> Optional[Sequence['outputs.ResponsePlayResponderEscalationRule']]:
        """
        The escalation rules
        """
        return pulumi.get(self, "escalation_rules")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the escalation policy
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="numLoops")
    def num_loops(self) -> Optional[_builtins.int]:
        """
        The number of times the escalation policy will repeat after reaching the end of its escalation.
        """
        return pulumi.get(self, "num_loops")

    @_builtins.property
    @pulumi.getter(name="onCallHandoffNotifications")
    def on_call_handoff_notifications(self) -> Optional[_builtins.str]:
        """
        Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        """
        return pulumi.get(self, "on_call_handoff_notifications")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.ResponsePlayResponderService']]:
        """
        There can be multiple services associated with a policy.
        """
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter
    def teams(self) -> Optional[Sequence['outputs.ResponsePlayResponderTeam']]:
        """
        Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        """
        return pulumi.get(self, "teams")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Should be set as `escalation_policy` for escalation policy responders.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderEscalationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationDelayInMinutes":
            suggest = "escalation_delay_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponsePlayResponderEscalationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponsePlayResponderEscalationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponsePlayResponderEscalationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 targets: Sequence['outputs.ResponsePlayResponderEscalationRuleTarget'],
                 escalation_delay_in_minutes: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param Sequence['ResponsePlayResponderEscalationRuleTargetArgs'] targets: The targets an incident should be assigned to upon reaching this rule.
        :param _builtins.int escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param _builtins.str id: The ID of the response play.
        """
        pulumi.set(__self__, "targets", targets)
        if escalation_delay_in_minutes is not None:
            pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.ResponsePlayResponderEscalationRuleTarget']:
        """
        The targets an incident should be assigned to upon reaching this rule.
        """
        return pulumi.get(self, "targets")

    @_builtins.property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> Optional[_builtins.int]:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ResponsePlayResponderEscalationRuleTarget(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The ID of the response play.
        :param _builtins.str type: Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderService(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The ID of the response play.
        :param _builtins.str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderTeam(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        :param _builtins.str id: The ID of the response play.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ResponsePlaySubscriber(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The ID of the response play.
        :param _builtins.str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the response play.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RulesetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventActions":
            suggest = "event_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotates: Optional[Sequence['outputs.RulesetRuleActionsAnnotate']] = None,
                 event_actions: Optional[Sequence['outputs.RulesetRuleActionsEventAction']] = None,
                 extractions: Optional[Sequence['outputs.RulesetRuleActionsExtraction']] = None,
                 priorities: Optional[Sequence['outputs.RulesetRuleActionsPriority']] = None,
                 routes: Optional[Sequence['outputs.RulesetRuleActionsRoute']] = None,
                 severities: Optional[Sequence['outputs.RulesetRuleActionsSeverity']] = None,
                 suppresses: Optional[Sequence['outputs.RulesetRuleActionsSuppress']] = None,
                 suspends: Optional[Sequence['outputs.RulesetRuleActionsSuspend']] = None):
        """
        :param Sequence['RulesetRuleActionsAnnotateArgs'] annotates: Note added to the event.
        :param Sequence['RulesetRuleActionsEventActionArgs'] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param Sequence['RulesetRuleActionsExtractionArgs'] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param Sequence['RulesetRuleActionsPriorityArgs'] priorities: The ID of the priority applied to the event.
        :param Sequence['RulesetRuleActionsRouteArgs'] routes: The ID of the service where the event will be routed.
        :param Sequence['RulesetRuleActionsSeverityArgs'] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        :param Sequence['RulesetRuleActionsSuppressArgs'] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        :param Sequence['RulesetRuleActionsSuspendArgs'] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)
        if suspends is not None:
            pulumi.set(__self__, "suspends", suspends)

    @_builtins.property
    @pulumi.getter
    def annotates(self) -> Optional[Sequence['outputs.RulesetRuleActionsAnnotate']]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @_builtins.property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[Sequence['outputs.RulesetRuleActionsEventAction']]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @_builtins.property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.RulesetRuleActionsExtraction']]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @_builtins.property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence['outputs.RulesetRuleActionsPriority']]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @_builtins.property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.RulesetRuleActionsRoute']]:
        """
        The ID of the service where the event will be routed.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[Sequence['outputs.RulesetRuleActionsSeverity']]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @_builtins.property
    @pulumi.getter
    def suppresses(self) -> Optional[Sequence['outputs.RulesetRuleActionsSuppress']]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        """
        return pulumi.get(self, "suppresses")

    @_builtins.property
    @pulumi.getter
    def suspends(self) -> Optional[Sequence['outputs.RulesetRuleActionsSuspend']]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        return pulumi.get(self, "suspends")


@pulumi.output_type
class RulesetRuleActionsAnnotate(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsEventAction(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
               
               *- **OR** -*
        :param _builtins.str source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param _builtins.str target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
               
               *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        :param _builtins.str template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        *- **OR** -*
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.

        *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class RulesetRuleActionsPriority(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsRoute(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSeverity(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSuppress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdTimeAmount":
            suggest = "threshold_time_amount"
        elif key == "thresholdTimeUnit":
            suggest = "threshold_time_unit"
        elif key == "thresholdValue":
            suggest = "threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionsSuppress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionsSuppress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionsSuppress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_time_amount: Optional[_builtins.int] = None,
                 threshold_time_unit: Optional[_builtins.str] = None,
                 threshold_value: Optional[_builtins.int] = None,
                 value: Optional[_builtins.bool] = None):
        """
        :param _builtins.int threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        :param _builtins.str threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param _builtins.int threshold_value: The number of alerts that should be suppressed. Must be greater than 0.
        :param _builtins.bool value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[_builtins.int]:
        """
        The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_time_amount")

    @_builtins.property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[_builtins.str]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @_builtins.property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[_builtins.int]:
        """
        The number of alerts that should be suppressed. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSuspend(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        """
        :param _builtins.int value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleConditions(dict):
    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 subconditions: Optional[Sequence['outputs.RulesetRuleConditionsSubcondition']] = None):
        """
        :param _builtins.str operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param Sequence['RulesetRuleConditionsSubconditionArgs'] subconditions: List of sub-conditions that define the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def subconditions(self) -> Optional[Sequence['outputs.RulesetRuleConditionsSubcondition']]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")


@pulumi.output_type
class RulesetRuleConditionsSubcondition(dict):
    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence['outputs.RulesetRuleConditionsSubconditionParameter']] = None):
        """
        :param _builtins.str operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param Sequence['RulesetRuleConditionsSubconditionParameterArgs'] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.RulesetRuleConditionsSubconditionParameter']]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class RulesetRuleConditionsSubconditionParameter(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleTimeFrame(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeBetweens":
            suggest = "active_betweens"
        elif key == "scheduledWeeklies":
            suggest = "scheduled_weeklies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrame. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrame.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrame.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_betweens: Optional[Sequence['outputs.RulesetRuleTimeFrameActiveBetween']] = None,
                 scheduled_weeklies: Optional[Sequence['outputs.RulesetRuleTimeFrameScheduledWeekly']] = None):
        """
        :param Sequence['RulesetRuleTimeFrameActiveBetweenArgs'] active_betweens: Values for executing the rule during a specific time period.
        :param Sequence['RulesetRuleTimeFrameScheduledWeeklyArgs'] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @_builtins.property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[Sequence['outputs.RulesetRuleTimeFrameActiveBetween']]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @_builtins.property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[Sequence['outputs.RulesetRuleTimeFrameScheduledWeekly']]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")


@pulumi.output_type
class RulesetRuleTimeFrameActiveBetween(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrameActiveBetween. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrameActiveBetween.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrameActiveBetween.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[_builtins.int] = None,
                 start_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int start_time: A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.int]:
        """
        A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class RulesetRuleTimeFrameScheduledWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrameScheduledWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[_builtins.int] = None,
                 start_time: Optional[_builtins.int] = None,
                 timezone: Optional[_builtins.str] = None,
                 weekdays: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int duration: Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        :param _builtins.int start_time: A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        :param _builtins.str timezone: [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        :param Sequence[_builtins.int] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.int]:
        """
        A Unix timestamp in milliseconds which is combined with the `timezone` to determine the time this rule will start on each specified `weekday`. Note that the _date_ of the timestamp you specify does **not** matter, except that it lets you determine whether daylight saving time is in effect so that you use the correct UTC offset for the timezone you specify. In practice, you may want to use the `time_static` resource to generate this value, as demonstrated in the `resource.pagerduty_ruleset_rule.foo` code example at the top of this page. To generate this timestamp manually, if you want your rule to apply starting at 9:30am in the `America/New_York` timezone, use your programing language of choice to determine a Unix timestamp that represents 9:30am in that timezone, like [1554989400000](https://www.epochconverter.com/timezones?q=1554989400000&tz=America%2FNew_York).
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[_builtins.int]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class RulesetRuleVariable(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence['outputs.RulesetRuleVariableParameter']] = None,
                 type: Optional[_builtins.str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.RulesetRuleVariableParameter']]:
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class RulesetRuleVariableParameter(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetTeam(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the ruleset.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the ruleset.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ScheduleFinalSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renderedCoveragePercentage":
            suggest = "rendered_coverage_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleFinalSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleFinalSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleFinalSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 rendered_coverage_percentage: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the schedule.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rendered_coverage_percentage is not None:
            pulumi.set(__self__, "rendered_coverage_percentage", rendered_coverage_percentage)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the schedule.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="renderedCoveragePercentage")
    def rendered_coverage_percentage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rendered_coverage_percentage")


@pulumi.output_type
class ScheduleLayer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotationTurnLengthSeconds":
            suggest = "rotation_turn_length_seconds"
        elif key == "rotationVirtualStart":
            suggest = "rotation_virtual_start"
        elif key == "renderedCoveragePercentage":
            suggest = "rendered_coverage_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleLayer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleLayer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleLayer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rotation_turn_length_seconds: _builtins.int,
                 rotation_virtual_start: _builtins.str,
                 start: _builtins.str,
                 users: Sequence[_builtins.str],
                 end: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 rendered_coverage_percentage: Optional[_builtins.str] = None,
                 restrictions: Optional[Sequence['outputs.ScheduleLayerRestriction']] = None):
        """
        :param _builtins.int rotation_turn_length_seconds: The duration of each on-call shift in `seconds`.
        :param _builtins.str rotation_virtual_start: The effective start time of the schedule layer. This can be before the start time of the schedule.
        :param _builtins.str start: The start time of the schedule layer.
        :param Sequence[_builtins.str] users: The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        :param _builtins.str end: The end time of the schedule layer. If not specified, the layer does not end.
        :param _builtins.str id: The ID of the schedule.
        :param _builtins.str name: The name of the schedule layer.
        :param Sequence['ScheduleLayerRestrictionArgs'] restrictions: A schedule layer restriction block. Restriction blocks documented below.
        """
        pulumi.set(__self__, "rotation_turn_length_seconds", rotation_turn_length_seconds)
        pulumi.set(__self__, "rotation_virtual_start", rotation_virtual_start)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "users", users)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rendered_coverage_percentage is not None:
            pulumi.set(__self__, "rendered_coverage_percentage", rendered_coverage_percentage)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @_builtins.property
    @pulumi.getter(name="rotationTurnLengthSeconds")
    def rotation_turn_length_seconds(self) -> _builtins.int:
        """
        The duration of each on-call shift in `seconds`.
        """
        return pulumi.get(self, "rotation_turn_length_seconds")

    @_builtins.property
    @pulumi.getter(name="rotationVirtualStart")
    def rotation_virtual_start(self) -> _builtins.str:
        """
        The effective start time of the schedule layer. This can be before the start time of the schedule.
        """
        return pulumi.get(self, "rotation_virtual_start")

    @_builtins.property
    @pulumi.getter
    def start(self) -> _builtins.str:
        """
        The start time of the schedule layer.
        """
        return pulumi.get(self, "start")

    @_builtins.property
    @pulumi.getter
    def users(self) -> Sequence[_builtins.str]:
        """
        The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        """
        return pulumi.get(self, "users")

    @_builtins.property
    @pulumi.getter
    def end(self) -> Optional[_builtins.str]:
        """
        The end time of the schedule layer. If not specified, the layer does not end.
        """
        return pulumi.get(self, "end")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the schedule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the schedule layer.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="renderedCoveragePercentage")
    def rendered_coverage_percentage(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "rendered_coverage_percentage")

    @_builtins.property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.ScheduleLayerRestriction']]:
        """
        A schedule layer restriction block. Restriction blocks documented below.
        """
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class ScheduleLayerRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationSeconds":
            suggest = "duration_seconds"
        elif key == "startTimeOfDay":
            suggest = "start_time_of_day"
        elif key == "startDayOfWeek":
            suggest = "start_day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleLayerRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleLayerRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleLayerRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_seconds: _builtins.int,
                 start_time_of_day: _builtins.str,
                 type: _builtins.str,
                 start_day_of_week: Optional[_builtins.int] = None):
        """
        :param _builtins.int duration_seconds: The duration of the restriction in `seconds`.
        :param _builtins.str start_time_of_day: The start time in `HH:mm:ss` format.
        :param _builtins.str type: Can be `daily_restriction` or `weekly_restriction`.
        :param _builtins.int start_day_of_week: Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        pulumi.set(__self__, "duration_seconds", duration_seconds)
        pulumi.set(__self__, "start_time_of_day", start_time_of_day)
        pulumi.set(__self__, "type", type)
        if start_day_of_week is not None:
            pulumi.set(__self__, "start_day_of_week", start_day_of_week)

    @_builtins.property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> _builtins.int:
        """
        The duration of the restriction in `seconds`.
        """
        return pulumi.get(self, "duration_seconds")

    @_builtins.property
    @pulumi.getter(name="startTimeOfDay")
    def start_time_of_day(self) -> _builtins.str:
        """
        The start time in `HH:mm:ss` format.
        """
        return pulumi.get(self, "start_time_of_day")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Can be `daily_restriction` or `weekly_restriction`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[_builtins.int]:
        """
        Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        return pulumi.get(self, "start_day_of_week")


@pulumi.output_type
class ServiceAlertGroupingParameters(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.ServiceAlertGroupingParametersConfig'] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param 'ServiceAlertGroupingParametersConfigArgs' config: Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        :param _builtins.str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def config(self) -> Optional['outputs.ServiceAlertGroupingParametersConfig']:
        """
        Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        """
        return pulumi.get(self, "config")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceAlertGroupingParametersConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeWindow":
            suggest = "time_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceAlertGroupingParametersConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceAlertGroupingParametersConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceAlertGroupingParametersConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aggregate: Optional[_builtins.str] = None,
                 fields: Optional[Sequence[_builtins.str]] = None,
                 time_window: Optional[_builtins.int] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.str aggregate: One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        :param Sequence[_builtins.str] fields: Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        :param _builtins.int time_window: The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent` or `content_based`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours.
        :param _builtins.int timeout: The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if time_window is not None:
            pulumi.set(__self__, "time_window", time_window)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def aggregate(self) -> Optional[_builtins.str]:
        """
        One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        """
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> Optional[_builtins.int]:
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent` or `content_based`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours.
        """
        return pulumi.get(self, "time_window")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ServiceAutoPauseNotificationsParameters(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 timeout: Optional[_builtins.int] = None):
        """
        :param _builtins.bool enabled: Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        :param _builtins.int timeout: Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> Optional[_builtins.int]:
        """
        Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ServiceCustomFieldFieldOption(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceCustomFieldFieldOption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceCustomFieldFieldOption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceCustomFieldFieldOption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: _builtins.str,
                 value: _builtins.str,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str data_type: Must be `string`.
        :param _builtins.str value: The value of the option.
        :param _builtins.str id: The ID of the service custom field.
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "value", value)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> _builtins.str:
        """
        Must be `string`.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the option.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the service custom field.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ServiceCustomFieldValueCustomField(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str id: The ID of the custom field. Either `id` or `name` must be provided.
        :param _builtins.str name: The name of the custom field. Either `id` or `name` must be provided.
        :param _builtins.str value: The value to set for the custom field. Must be provided as a JSON-encoded string matching the field's data type. Use the `jsonencode()` function to ensure proper formatting.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the custom field. Either `id` or `name` must be provided.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the custom field. Either `id` or `name` must be provided.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value to set for the custom field. Must be provided as a JSON-encoded string matching the field's data type. Use the `jsonencode()` function to ensure proper formatting.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceDependencyDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependentServices":
            suggest = "dependent_services"
        elif key == "supportingServices":
            suggest = "supporting_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceDependencyDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceDependencyDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceDependencyDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependent_services: Sequence['outputs.ServiceDependencyDependencyDependentService'],
                 supporting_services: Sequence['outputs.ServiceDependencyDependencySupportingService'],
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence['ServiceDependencyDependencyDependentServiceArgs'] dependent_services: The service that dependents on the supporting service. Dependency dependent service documented below. One and only one `dependent_service` dependency block must be defined.
        :param Sequence['ServiceDependencyDependencySupportingServiceArgs'] supporting_services: The service that supports the dependent service. Dependency supporting service documented below. One and only one `supporting_service` dependency block must be defined.
        :param _builtins.str type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "dependent_services", dependent_services)
        pulumi.set(__self__, "supporting_services", supporting_services)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="dependentServices")
    def dependent_services(self) -> Sequence['outputs.ServiceDependencyDependencyDependentService']:
        """
        The service that dependents on the supporting service. Dependency dependent service documented below. One and only one `dependent_service` dependency block must be defined.
        """
        return pulumi.get(self, "dependent_services")

    @_builtins.property
    @pulumi.getter(name="supportingServices")
    def supporting_services(self) -> Sequence['outputs.ServiceDependencyDependencySupportingService']:
        """
        The service that supports the dependent service. Dependency supporting service documented below. One and only one `supporting_service` dependency block must be defined.
        """
        return pulumi.get(self, "supporting_services")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceDependencyDependencyDependentService(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The ID of the service dependency.
        :param _builtins.str type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceDependencyDependencySupportingService(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The ID of the service dependency.
        :param _builtins.str type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceEventRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventActions":
            suggest = "event_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotates: Optional[Sequence['outputs.ServiceEventRuleActionsAnnotate']] = None,
                 event_actions: Optional[Sequence['outputs.ServiceEventRuleActionsEventAction']] = None,
                 extractions: Optional[Sequence['outputs.ServiceEventRuleActionsExtraction']] = None,
                 priorities: Optional[Sequence['outputs.ServiceEventRuleActionsPriority']] = None,
                 severities: Optional[Sequence['outputs.ServiceEventRuleActionsSeverity']] = None,
                 suppresses: Optional[Sequence['outputs.ServiceEventRuleActionsSuppress']] = None,
                 suspends: Optional[Sequence['outputs.ServiceEventRuleActionsSuspend']] = None):
        """
        :param Sequence['ServiceEventRuleActionsAnnotateArgs'] annotates: Note added to the event.
        :param Sequence['ServiceEventRuleActionsEventActionArgs'] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param Sequence['ServiceEventRuleActionsExtractionArgs'] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param Sequence['ServiceEventRuleActionsPriorityArgs'] priorities: The ID of the priority applied to the event.
        :param Sequence['ServiceEventRuleActionsSeverityArgs'] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        :param Sequence['ServiceEventRuleActionsSuppressArgs'] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        :param Sequence['ServiceEventRuleActionsSuspendArgs'] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)
        if suspends is not None:
            pulumi.set(__self__, "suspends", suspends)

    @_builtins.property
    @pulumi.getter
    def annotates(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsAnnotate']]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @_builtins.property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsEventAction']]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @_builtins.property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsExtraction']]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @_builtins.property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsPriority']]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @_builtins.property
    @pulumi.getter
    def severities(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSeverity']]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @_builtins.property
    @pulumi.getter
    def suppresses(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSuppress']]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        return pulumi.get(self, "suppresses")

    @_builtins.property
    @pulumi.getter
    def suspends(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSuspend']]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        return pulumi.get(self, "suspends")


@pulumi.output_type
class ServiceEventRuleActionsAnnotate(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsEventAction(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 regex: Optional[_builtins.str] = None,
                 source: Optional[_builtins.str] = None,
                 target: Optional[_builtins.str] = None,
                 template: Optional[_builtins.str] = None):
        """
        :param _builtins.str regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
               
               *- **OR** -*
        :param _builtins.str source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param _builtins.str target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
               
               *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        :param _builtins.str template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).

        *- **OR** -*
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> Optional[_builtins.str]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter
    def target(self) -> Optional[_builtins.str]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.

        *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        return pulumi.get(self, "target")

    @_builtins.property
    @pulumi.getter
    def template(self) -> Optional[_builtins.str]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class ServiceEventRuleActionsPriority(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSeverity(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.str] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSuppress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdTimeAmount":
            suggest = "threshold_time_amount"
        elif key == "thresholdTimeUnit":
            suggest = "threshold_time_unit"
        elif key == "thresholdValue":
            suggest = "threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleActionsSuppress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleActionsSuppress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleActionsSuppress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_time_amount: Optional[_builtins.int] = None,
                 threshold_time_unit: Optional[_builtins.str] = None,
                 threshold_value: Optional[_builtins.int] = None,
                 value: Optional[_builtins.bool] = None):
        """
        :param _builtins.int threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created.
        :param _builtins.str threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param _builtins.int threshold_value: The number of alerts that should be suppressed.
        :param _builtins.bool value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[_builtins.int]:
        """
        The number value of the `threshold_time_unit` before an incident is created.
        """
        return pulumi.get(self, "threshold_time_amount")

    @_builtins.property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[_builtins.str]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @_builtins.property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[_builtins.int]:
        """
        The number of alerts that should be suppressed.
        """
        return pulumi.get(self, "threshold_value")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.bool]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSuspend(dict):
    def __init__(__self__, *,
                 value: Optional[_builtins.int] = None):
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleConditions(dict):
    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 subconditions: Optional[Sequence['outputs.ServiceEventRuleConditionsSubcondition']] = None):
        """
        :param _builtins.str operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param Sequence['ServiceEventRuleConditionsSubconditionArgs'] subconditions: List of sub-conditions that define the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def subconditions(self) -> Optional[Sequence['outputs.ServiceEventRuleConditionsSubcondition']]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")


@pulumi.output_type
class ServiceEventRuleConditionsSubcondition(dict):
    def __init__(__self__, *,
                 operator: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence['outputs.ServiceEventRuleConditionsSubconditionParameter']] = None):
        """
        :param _builtins.str operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param Sequence['ServiceEventRuleConditionsSubconditionParameterArgs'] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> Optional[_builtins.str]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.ServiceEventRuleConditionsSubconditionParameter']]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class ServiceEventRuleConditionsSubconditionParameter(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleTimeFrame(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeBetweens":
            suggest = "active_betweens"
        elif key == "scheduledWeeklies":
            suggest = "scheduled_weeklies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrame. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrame.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrame.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_betweens: Optional[Sequence['outputs.ServiceEventRuleTimeFrameActiveBetween']] = None,
                 scheduled_weeklies: Optional[Sequence['outputs.ServiceEventRuleTimeFrameScheduledWeekly']] = None):
        """
        :param Sequence['ServiceEventRuleTimeFrameActiveBetweenArgs'] active_betweens: Values for executing the rule during a specific time period.
        :param Sequence['ServiceEventRuleTimeFrameScheduledWeeklyArgs'] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @_builtins.property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[Sequence['outputs.ServiceEventRuleTimeFrameActiveBetween']]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @_builtins.property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[Sequence['outputs.ServiceEventRuleTimeFrameScheduledWeekly']]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")


@pulumi.output_type
class ServiceEventRuleTimeFrameActiveBetween(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrameActiveBetween. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrameActiveBetween.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrameActiveBetween.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[_builtins.int] = None,
                 start_time: Optional[_builtins.int] = None):
        """
        :param _builtins.int end_time: Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        :param _builtins.int start_time: Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.int]:
        """
        Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.int]:
        """
        Beginning of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ServiceEventRuleTimeFrameScheduledWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrameScheduledWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[_builtins.int] = None,
                 start_time: Optional[_builtins.int] = None,
                 timezone: Optional[_builtins.str] = None,
                 weekdays: Optional[Sequence[_builtins.int]] = None):
        """
        :param _builtins.int duration: Length of time the schedule will be active.  Unix timestamp in milliseconds.
        :param _builtins.int start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        :param _builtins.str timezone: Timezone for the given schedule.
        :param Sequence[_builtins.int] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        Length of time the schedule will be active.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.int]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter
    def timezone(self) -> Optional[_builtins.str]:
        """
        Timezone for the given schedule.
        """
        return pulumi.get(self, "timezone")

    @_builtins.property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[_builtins.int]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class ServiceEventRuleVariable(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence['outputs.ServiceEventRuleVariableParameter']] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the variable.
        :param Sequence['ServiceEventRuleVariableParameterArgs'] parameters: The parameters for performing the operation to populate the variable.
        :param _builtins.str type: Type of operation to populate the variable. Usually `regex`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.ServiceEventRuleVariableParameter']]:
        """
        The parameters for performing the operation to populate the variable.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of operation to populate the variable. Usually `regex`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceEventRuleVariableParameter(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceIncidentUrgencyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "duringSupportHours":
            suggest = "during_support_hours"
        elif key == "outsideSupportHours":
            suggest = "outside_support_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIncidentUrgencyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIncidentUrgencyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIncidentUrgencyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 during_support_hours: Optional['outputs.ServiceIncidentUrgencyRuleDuringSupportHours'] = None,
                 outside_support_hours: Optional['outputs.ServiceIncidentUrgencyRuleOutsideSupportHours'] = None,
                 urgency: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of incident urgency: `constant` or `use_support_hours` (when depending on specific support hours; see `support_hours`).
        :param 'ServiceIncidentUrgencyRuleDuringSupportHoursArgs' during_support_hours: Incidents' urgency during support hours.
        :param 'ServiceIncidentUrgencyRuleOutsideSupportHoursArgs' outside_support_hours: Incidents' urgency outside support hours.
        :param _builtins.str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        pulumi.set(__self__, "type", type)
        if during_support_hours is not None:
            pulumi.set(__self__, "during_support_hours", during_support_hours)
        if outside_support_hours is not None:
            pulumi.set(__self__, "outside_support_hours", outside_support_hours)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of incident urgency: `constant` or `use_support_hours` (when depending on specific support hours; see `support_hours`).
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="duringSupportHours")
    def during_support_hours(self) -> Optional['outputs.ServiceIncidentUrgencyRuleDuringSupportHours']:
        """
        Incidents' urgency during support hours.
        """
        return pulumi.get(self, "during_support_hours")

    @_builtins.property
    @pulumi.getter(name="outsideSupportHours")
    def outside_support_hours(self) -> Optional['outputs.ServiceIncidentUrgencyRuleOutsideSupportHours']:
        """
        Incidents' urgency outside support hours.
        """
        return pulumi.get(self, "outside_support_hours")

    @_builtins.property
    @pulumi.getter
    def urgency(self) -> Optional[_builtins.str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceIncidentUrgencyRuleDuringSupportHours(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 urgency: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        :param _builtins.str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def urgency(self) -> Optional[_builtins.str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceIncidentUrgencyRuleOutsideSupportHours(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None,
                 urgency: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        :param _builtins.str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of object. The value returned will be `service`. Can be used for passing to a service dependency.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def urgency(self) -> Optional[_builtins.str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceIntegrationEmailFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyMode":
            suggest = "body_mode"
        elif key == "bodyRegex":
            suggest = "body_regex"
        elif key == "fromEmailMode":
            suggest = "from_email_mode"
        elif key == "fromEmailRegex":
            suggest = "from_email_regex"
        elif key == "subjectMode":
            suggest = "subject_mode"
        elif key == "subjectRegex":
            suggest = "subject_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEmailFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEmailFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEmailFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_mode: Optional[_builtins.str] = None,
                 body_regex: Optional[_builtins.str] = None,
                 from_email_mode: Optional[_builtins.str] = None,
                 from_email_regex: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 subject_mode: Optional[_builtins.str] = None,
                 subject_regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str body_mode: Can be `always`, `match` or `no-match`.
        :param _builtins.str body_regex: Should be a valid regex or `null`
        :param _builtins.str from_email_mode: Can be `always`, `match` or `no-match`.
        :param _builtins.str from_email_regex: Should be a valid regex or `null`
        :param _builtins.str id: The ID of the service integration.
        :param _builtins.str subject_mode: Can be `always`, `match` or `no-match`.
        :param _builtins.str subject_regex: Should be a valid regex or `null`
        """
        if body_mode is not None:
            pulumi.set(__self__, "body_mode", body_mode)
        if body_regex is not None:
            pulumi.set(__self__, "body_regex", body_regex)
        if from_email_mode is not None:
            pulumi.set(__self__, "from_email_mode", from_email_mode)
        if from_email_regex is not None:
            pulumi.set(__self__, "from_email_regex", from_email_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subject_mode is not None:
            pulumi.set(__self__, "subject_mode", subject_mode)
        if subject_regex is not None:
            pulumi.set(__self__, "subject_regex", subject_regex)

    @_builtins.property
    @pulumi.getter(name="bodyMode")
    def body_mode(self) -> Optional[_builtins.str]:
        """
        Can be `always`, `match` or `no-match`.
        """
        return pulumi.get(self, "body_mode")

    @_builtins.property
    @pulumi.getter(name="bodyRegex")
    def body_regex(self) -> Optional[_builtins.str]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "body_regex")

    @_builtins.property
    @pulumi.getter(name="fromEmailMode")
    def from_email_mode(self) -> Optional[_builtins.str]:
        """
        Can be `always`, `match` or `no-match`.
        """
        return pulumi.get(self, "from_email_mode")

    @_builtins.property
    @pulumi.getter(name="fromEmailRegex")
    def from_email_regex(self) -> Optional[_builtins.str]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "from_email_regex")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the service integration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="subjectMode")
    def subject_mode(self) -> Optional[_builtins.str]:
        """
        Can be `always`, `match` or `no-match`.
        """
        return pulumi.get(self, "subject_mode")

    @_builtins.property
    @pulumi.getter(name="subjectRegex")
    def subject_regex(self) -> Optional[_builtins.str]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "subject_regex")


@pulumi.output_type
class ServiceIntegrationEmailParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPredicate":
            suggest = "match_predicate"
        elif key == "valueExtractors":
            suggest = "value_extractors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEmailParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEmailParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEmailParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: _builtins.str,
                 match_predicate: 'outputs.ServiceIntegrationEmailParserMatchPredicate',
                 id: Optional[_builtins.int] = None,
                 value_extractors: Optional[Sequence['outputs.ServiceIntegrationEmailParserValueExtractor']] = None):
        """
        :param _builtins.str action: Can be `resolve` or `trigger`.
        :param _builtins.int id: The ID of the service integration.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match_predicate", match_predicate)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if value_extractors is not None:
            pulumi.set(__self__, "value_extractors", value_extractors)

    @_builtins.property
    @pulumi.getter
    def action(self) -> _builtins.str:
        """
        Can be `resolve` or `trigger`.
        """
        return pulumi.get(self, "action")

    @_builtins.property
    @pulumi.getter(name="matchPredicate")
    def match_predicate(self) -> 'outputs.ServiceIntegrationEmailParserMatchPredicate':
        return pulumi.get(self, "match_predicate")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.int]:
        """
        The ID of the service integration.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="valueExtractors")
    def value_extractors(self) -> Optional[Sequence['outputs.ServiceIntegrationEmailParserValueExtractor']]:
        return pulumi.get(self, "value_extractors")


@pulumi.output_type
class ServiceIntegrationEmailParserMatchPredicate(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 predicates: Optional[Sequence['outputs.ServiceIntegrationEmailParserMatchPredicatePredicate']] = None):
        """
        :param _builtins.str type: Can be `any` or `all`.
        """
        pulumi.set(__self__, "type", type)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Can be `any` or `all`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def predicates(self) -> Optional[Sequence['outputs.ServiceIntegrationEmailParserMatchPredicatePredicate']]:
        return pulumi.get(self, "predicates")


@pulumi.output_type
class ServiceIntegrationEmailParserMatchPredicatePredicate(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 matcher: Optional[_builtins.str] = None,
                 part: Optional[_builtins.str] = None,
                 predicates: Optional[Sequence['outputs.ServiceIntegrationEmailParserMatchPredicatePredicatePredicate']] = None):
        """
        :param _builtins.str type: Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        :param _builtins.str matcher: Predicate value or valid regex.
        :param _builtins.str part: Can be `subject`, `body` or `from_addresses`.
        """
        pulumi.set(__self__, "type", type)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)
        if part is not None:
            pulumi.set(__self__, "part", part)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def matcher(self) -> Optional[_builtins.str]:
        """
        Predicate value or valid regex.
        """
        return pulumi.get(self, "matcher")

    @_builtins.property
    @pulumi.getter
    def part(self) -> Optional[_builtins.str]:
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        return pulumi.get(self, "part")

    @_builtins.property
    @pulumi.getter
    def predicates(self) -> Optional[Sequence['outputs.ServiceIntegrationEmailParserMatchPredicatePredicatePredicate']]:
        return pulumi.get(self, "predicates")


@pulumi.output_type
class ServiceIntegrationEmailParserMatchPredicatePredicatePredicate(dict):
    def __init__(__self__, *,
                 matcher: _builtins.str,
                 part: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str matcher: Predicate value or valid regex.
        :param _builtins.str part: Can be `subject`, `body` or `from_addresses`.
        :param _builtins.str type: Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        pulumi.set(__self__, "matcher", matcher)
        pulumi.set(__self__, "part", part)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def matcher(self) -> _builtins.str:
        """
        Predicate value or valid regex.
        """
        return pulumi.get(self, "matcher")

    @_builtins.property
    @pulumi.getter
    def part(self) -> _builtins.str:
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        return pulumi.get(self, "part")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceIntegrationEmailParserValueExtractor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueName":
            suggest = "value_name"
        elif key == "endsBefore":
            suggest = "ends_before"
        elif key == "startsAfter":
            suggest = "starts_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEmailParserValueExtractor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEmailParserValueExtractor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEmailParserValueExtractor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 part: _builtins.str,
                 type: _builtins.str,
                 value_name: _builtins.str,
                 ends_before: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None,
                 starts_after: Optional[_builtins.str] = None):
        """
        :param _builtins.str part: Can be `subject` or `body`.
        :param _builtins.str type: Can be `between`, `entire` or `regex`.
        :param _builtins.str value_name: First value extractor should have name `incident_key` other value extractors should contain custom names.
        :param _builtins.str regex: If `type` has value `regex` this value should contain valid regex.
               
               **Note:** You can use the `get_vendor` data source to locate the appropriate vendor ID.
        """
        pulumi.set(__self__, "part", part)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value_name", value_name)
        if ends_before is not None:
            pulumi.set(__self__, "ends_before", ends_before)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if starts_after is not None:
            pulumi.set(__self__, "starts_after", starts_after)

    @_builtins.property
    @pulumi.getter
    def part(self) -> _builtins.str:
        """
        Can be `subject` or `body`.
        """
        return pulumi.get(self, "part")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Can be `between`, `entire` or `regex`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="valueName")
    def value_name(self) -> _builtins.str:
        """
        First value extractor should have name `incident_key` other value extractors should contain custom names.
        """
        return pulumi.get(self, "value_name")

    @_builtins.property
    @pulumi.getter(name="endsBefore")
    def ends_before(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "ends_before")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        If `type` has value `regex` this value should contain valid regex.

        **Note:** You can use the `get_vendor` data source to locate the appropriate vendor ID.
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter(name="startsAfter")
    def starts_after(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "starts_after")


@pulumi.output_type
class ServiceScheduledAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toUrgency":
            suggest = "to_urgency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceScheduledAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceScheduledAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceScheduledAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[Sequence['outputs.ServiceScheduledActionAt']] = None,
                 to_urgency: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence['ServiceScheduledActionAtArgs'] ats: A block representing when the scheduled action will occur.
        :param _builtins.str to_urgency: The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        :param _builtins.str type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if to_urgency is not None:
            pulumi.set(__self__, "to_urgency", to_urgency)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def ats(self) -> Optional[Sequence['outputs.ServiceScheduledActionAt']]:
        """
        A block representing when the scheduled action will occur.
        """
        return pulumi.get(self, "ats")

    @_builtins.property
    @pulumi.getter(name="toUrgency")
    def to_urgency(self) -> Optional[_builtins.str]:
        """
        The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        """
        return pulumi.get(self, "to_urgency")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceScheduledActionAt(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
               
               Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `during_support_hours` and to `low`  for `outside_support_hours` in `incident_urgency_rule`.
               
               Below is an example for a `Service` resource with `incident_urgency_rules` with `type = "use_support_hours"`, `support_hours` and a default `scheduled_action` as well.
               
               ```python
               import pulumi
               import pulumi_pagerduty as pagerduty
               
               foo = pagerduty.Service("foo",
                   name="bar",
                   description="bar bar bar",
                   auto_resolve_timeout="3600",
                   acknowledgement_timeout="3600",
                   escalation_policy=foo_pagerduty_escalation_policy["id"],
                   incident_urgency_rule={
                       "type": "use_support_hours",
                       "during_support_hours": {
                           "type": "constant",
                           "urgency": "high",
                       },
                       "outside_support_hours": {
                           "type": "constant",
                           "urgency": "low",
                       },
                   },
                   support_hours={
                       "type": "fixed_time_per_day",
                       "time_zone": "America/Lima",
                       "start_time": "09:00:00",
                       "end_time": "17:00:00",
                       "days_of_weeks": [
                           1,
                           2,
                           3,
                           4,
                           5,
                       ],
                   },
                   scheduled_actions=[{
                       "type": "urgency_change",
                       "to_urgency": "high",
                       "ats": [{
                           "type": "named_time",
                           "name": "support_hours_start",
                       }],
                   }])
               ```
        :param _builtins.str type: The type of time specification. Currently, this must be set to `named_time`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.

        Note that it is currently only possible to define the scheduled action when urgency is set to `high` for `during_support_hours` and to `low`  for `outside_support_hours` in `incident_urgency_rule`.

        Below is an example for a `Service` resource with `incident_urgency_rules` with `type = "use_support_hours"`, `support_hours` and a default `scheduled_action` as well.

        ```python
        import pulumi
        import pulumi_pagerduty as pagerduty

        foo = pagerduty.Service("foo",
            name="bar",
            description="bar bar bar",
            auto_resolve_timeout="3600",
            acknowledgement_timeout="3600",
            escalation_policy=foo_pagerduty_escalation_policy["id"],
            incident_urgency_rule={
                "type": "use_support_hours",
                "during_support_hours": {
                    "type": "constant",
                    "urgency": "high",
                },
                "outside_support_hours": {
                    "type": "constant",
                    "urgency": "low",
                },
            },
            support_hours={
                "type": "fixed_time_per_day",
                "time_zone": "America/Lima",
                "start_time": "09:00:00",
                "end_time": "17:00:00",
                "days_of_weeks": [
                    1,
                    2,
                    3,
                    4,
                    5,
                ],
            },
            scheduled_actions=[{
                "type": "urgency_change",
                "to_urgency": "high",
                "ats": [{
                    "type": "named_time",
                    "name": "support_hours_start",
                }],
            }])
        ```
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of time specification. Currently, this must be set to `named_time`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceSupportHours(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceSupportHours. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceSupportHours.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceSupportHours.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence[_builtins.int]] = None,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None,
                 time_zone: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.int] days_of_weeks: Array of days of week as integers. `1` to `7`, `1` being
               Monday and `7` being Sunday.
        :param _builtins.str end_time: The support hours' ending time of day.
        :param _builtins.str start_time: The support hours' starting time of day.
        :param _builtins.str time_zone: The time zone for the support hours.
        :param _builtins.str type: The type of support hours. Can be `fixed_time_per_day`.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[_builtins.int]]:
        """
        Array of days of week as integers. `1` to `7`, `1` being
        Monday and `7` being Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        The support hours' ending time of day.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The support hours' starting time of day.
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone for the support hours.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of support hours. Can be `fixed_time_per_day`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SlackConnectionConfig(dict):
    def __init__(__self__, *,
                 events: Sequence[_builtins.str],
                 priorities: Optional[Sequence[_builtins.str]] = None,
                 urgency: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] events: A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
               - `incident.acknowledged`
               - `incident.escalated`
               - `incident.resolved`
               - `incident.reassigned`
               - `incident.annotated`
               - `incident.unacknowledged`
               - `incident.delegated`
               - `incident.priority_updated`
               - `incident.responder.added`
               - `incident.responder.replied`
               - `incident.status_update_published`
               - `incident.reopened`
        :param Sequence[_builtins.str] priorities: Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through get_priority data source.
               - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behavior is to set `priorities` to `No Priority` value.
               - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
        :param _builtins.str urgency: Allows you to filter events by urgency. Either `high`, `low` or `null` for Any urgency. Default is `null`.
        """
        pulumi.set(__self__, "events", events)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @_builtins.property
    @pulumi.getter
    def events(self) -> Sequence[_builtins.str]:
        """
        A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
        - `incident.acknowledged`
        - `incident.escalated`
        - `incident.resolved`
        - `incident.reassigned`
        - `incident.annotated`
        - `incident.unacknowledged`
        - `incident.delegated`
        - `incident.priority_updated`
        - `incident.responder.added`
        - `incident.responder.replied`
        - `incident.status_update_published`
        - `incident.reopened`
        """
        return pulumi.get(self, "events")

    @_builtins.property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence[_builtins.str]]:
        """
        Allows you to filter events by priority. Needs to be an array of PagerDuty priority IDs. Available through get_priority data source.
        - When omitted or set to an empty array (`[]`) in the configuration for a Slack Connection, its default behavior is to set `priorities` to `No Priority` value.
        - When set to `["*"]` its corresponding value for `priorities` in Slack Connection's configuration will be `Any Priority`.
        """
        return pulumi.get(self, "priorities")

    @_builtins.property
    @pulumi.getter
    def urgency(self) -> Optional[_builtins.str]:
        """
        Allows you to filter events by urgency. Either `high`, `low` or `null` for Any urgency. Default is `null`.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class UserHandoffNotificationRuleContactMethod(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The ID of the contact method.
        :param _builtins.str type: The type of the contact method. May be (`email_contact_method`, `email_contact_method_reference`, `phone_contact_method`, `phone_contact_method_reference`, `push_notification_contact_method`, `push_notification_contact_method_reference`, `sms_contact_method`, `sms_contact_method_reference`).
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the contact method.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the contact method. May be (`email_contact_method`, `email_contact_method_reference`, `phone_contact_method`, `phone_contact_method_reference`, `push_notification_contact_method`, `push_notification_contact_method_reference`, `sms_contact_method`, `sms_contact_method_reference`).
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class UserNotificationRuleContactMethod(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The id of the referenced contact method.
        :param _builtins.str type: The type of contact method. Can be `email_contact_method`, `phone_contact_method`, `push_notification_contact_method` or `sms_contact_method`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The id of the referenced contact method.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of contact method. Can be `email_contact_method`, `phone_contact_method`, `push_notification_contact_method` or `sms_contact_method`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WebhookSubscriptionDeliveryMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHeaders":
            suggest = "custom_headers"
        elif key == "temporarilyDisabled":
            suggest = "temporarily_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookSubscriptionDeliveryMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookSubscriptionDeliveryMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookSubscriptionDeliveryMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_headers: Optional[Sequence['outputs.WebhookSubscriptionDeliveryMethodCustomHeader']] = None,
                 temporarily_disabled: Optional[_builtins.bool] = None,
                 type: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param Sequence['WebhookSubscriptionDeliveryMethodCustomHeaderArgs'] custom_headers: The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        :param _builtins.bool temporarily_disabled: Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        :param _builtins.str type: Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        :param _builtins.str url: The destination URL for webhook delivery.
        """
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if temporarily_disabled is not None:
            pulumi.set(__self__, "temporarily_disabled", temporarily_disabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[Sequence['outputs.WebhookSubscriptionDeliveryMethodCustomHeader']]:
        """
        The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        """
        return pulumi.get(self, "custom_headers")

    @_builtins.property
    @pulumi.getter(name="temporarilyDisabled")
    def temporarily_disabled(self) -> Optional[_builtins.bool]:
        """
        Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        """
        return pulumi.get(self, "temporarily_disabled")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        The destination URL for webhook delivery.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WebhookSubscriptionDeliveryMethodCustomHeader(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebhookSubscriptionFilter(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        :param _builtins.str id: The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAlertGroupingSettingConfigResult(dict):
    def __init__(__self__, *,
                 time_window: _builtins.int,
                 timeout: _builtins.int,
                 aggregate: Optional[_builtins.str] = None,
                 fields: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.int time_window: The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        :param _builtins.int timeout: The duration in minutes within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        :param _builtins.str aggregate: One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        :param Sequence[_builtins.str] fields: Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        """
        pulumi.set(__self__, "time_window", time_window)
        pulumi.set(__self__, "timeout", timeout)
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter(name="timeWindow")
    def time_window(self) -> _builtins.int:
        """
        The maximum amount of time allowed between Alerts. This setting applies only when `type` is set to `intelligent`, `content_based`, `content_based_intelligent`. Value must be between `300` and `3600` or exactly `86400` (86400 is supported only for `content_based` alert grouping). Any Alerts arriving greater than `time_window` seconds apart will not be grouped together. This is a rolling time window and is counted from the most recently grouped alert. The window is extended every time a new alert is added to the group, up to 24 hours. To use the recommended time window leave this value unset or set it to `null`.
        """
        return pulumi.get(self, "time_window")

    @_builtins.property
    @pulumi.getter
    def timeout(self) -> _builtins.int:
        """
        The duration in minutes within which to automatically group incoming alerts. This setting is only required and applies when `type` is set to `time`. To continue grouping alerts until the incident is resolved leave this value unset or set it to `null`.
        """
        return pulumi.get(self, "timeout")

    @_builtins.property
    @pulumi.getter
    def aggregate(self) -> Optional[_builtins.str]:
        """
        One of `any` or `all`. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[_builtins.str]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting is only required and applies when `type` is set to `content_based` or `content_based_intelligent`.
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class GetAutomationActionsActionActionDataReferenceResult(dict):
    def __init__(__self__, *,
                 invocation_command: _builtins.str,
                 process_automation_job_arguments: _builtins.str,
                 process_automation_job_id: _builtins.str,
                 process_automation_node_filter: _builtins.str,
                 script: _builtins.str):
        """
        :param _builtins.str invocation_command: (Optional) The command to execute the script with.
        :param _builtins.str process_automation_job_arguments: (Optional) The arguments to pass to the Process Automation job execution.
        :param _builtins.str process_automation_job_id: (Required for `process_automation` action_type) The ID of the Process Automation job to execute.
        :param _builtins.str process_automation_node_filter: (Optional) The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        :param _builtins.str script: (Required for `script` action_type) Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        pulumi.set(__self__, "invocation_command", invocation_command)
        pulumi.set(__self__, "process_automation_job_arguments", process_automation_job_arguments)
        pulumi.set(__self__, "process_automation_job_id", process_automation_job_id)
        pulumi.set(__self__, "process_automation_node_filter", process_automation_node_filter)
        pulumi.set(__self__, "script", script)

    @_builtins.property
    @pulumi.getter(name="invocationCommand")
    def invocation_command(self) -> _builtins.str:
        """
        (Optional) The command to execute the script with.
        """
        return pulumi.get(self, "invocation_command")

    @_builtins.property
    @pulumi.getter(name="processAutomationJobArguments")
    def process_automation_job_arguments(self) -> _builtins.str:
        """
        (Optional) The arguments to pass to the Process Automation job execution.
        """
        return pulumi.get(self, "process_automation_job_arguments")

    @_builtins.property
    @pulumi.getter(name="processAutomationJobId")
    def process_automation_job_id(self) -> _builtins.str:
        """
        (Required for `process_automation` action_type) The ID of the Process Automation job to execute.
        """
        return pulumi.get(self, "process_automation_job_id")

    @_builtins.property
    @pulumi.getter(name="processAutomationNodeFilter")
    def process_automation_node_filter(self) -> _builtins.str:
        """
        (Optional) The expression that filters on which nodes a Process Automation Job executes [Learn more](https://docs.rundeck.com/docs/manual/05-nodes.html#node-filtering).
        """
        return pulumi.get(self, "process_automation_node_filter")

    @_builtins.property
    @pulumi.getter
    def script(self) -> _builtins.str:
        """
        (Required for `script` action_type) Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        return pulumi.get(self, "script")


@pulumi.output_type
class GetEventOrchestrationGlobalCacheVariableConditionResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class GetEventOrchestrationGlobalCacheVariableConfigurationResult(dict):
    def __init__(__self__, *,
                 regex: _builtins.str,
                 source: _builtins.str,
                 ttl_seconds: _builtins.int,
                 type: _builtins.str,
                 data_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str regex: A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        :param _builtins.int ttl_seconds: The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count` or `external_data`
        :param _builtins.str type: The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value`, `trigger_event_count` or `external_data`.
        :param _builtins.str data_type: The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `external_data`
        """
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "ttl_seconds", ttl_seconds)
        pulumi.set(__self__, "type", type)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> _builtins.int:
        """
        The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count` or `external_data`
        """
        return pulumi.get(self, "ttl_seconds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value`, `trigger_event_count` or `external_data`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `external_data`
        """
        return pulumi.get(self, "data_type")


@pulumi.output_type
class GetEventOrchestrationIntegrationDetailResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 label: _builtins.str,
                 parameters: Sequence['outputs.GetEventOrchestrationIntegrationDetailParameterResult']):
        """
        :param _builtins.str id: ID of the integration
        :param Sequence['GetEventOrchestrationIntegrationDetailParameterArgs'] parameters: A single-item list containing a parameter object describing the integration
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.GetEventOrchestrationIntegrationDetailParameterResult']:
        """
        A single-item list containing a parameter object describing the integration
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetEventOrchestrationIntegrationDetailParameterResult(dict):
    def __init__(__self__, *,
                 routing_key: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str routing_key: Routing key that routes to this Orchestration.
        :param _builtins.str type: Type of the routing key. `global` is the default type.
        """
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> _builtins.str:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEventOrchestrationIntegrationParameterResult(dict):
    def __init__(__self__, *,
                 routing_key: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str routing_key: Routing key that routes to this Orchestration.
        :param _builtins.str type: Type of the routing key. `global` is the default type.
        """
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> _builtins.str:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEventOrchestrationServiceCacheVariableConditionResult(dict):
    def __init__(__self__, *,
                 expression: _builtins.str):
        """
        :param _builtins.str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> _builtins.str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class GetEventOrchestrationServiceCacheVariableConfigurationResult(dict):
    def __init__(__self__, *,
                 regex: _builtins.str,
                 source: _builtins.str,
                 ttl_seconds: _builtins.int,
                 type: _builtins.str,
                 data_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str regex: A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        :param _builtins.str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        :param _builtins.int ttl_seconds: The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count` or `external_data`
        :param _builtins.str type: The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value`, `trigger_event_count` or `external_data`.
        :param _builtins.str data_type: The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `external_data`
        """
        pulumi.set(__self__, "regex", regex)
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "ttl_seconds", ttl_seconds)
        pulumi.set(__self__, "type", type)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> _builtins.str:
        """
        A [RE2 regular expression][4] that will be matched against the field specified via the `source` argument. This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "regex")

    @_builtins.property
    @pulumi.getter
    def source(self) -> _builtins.str:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths). This field is only used when `type` is `recent_value`
        """
        return pulumi.get(self, "source")

    @_builtins.property
    @pulumi.getter(name="ttlSeconds")
    def ttl_seconds(self) -> _builtins.int:
        """
        The number of seconds indicating how long to count incoming trigger events for. This field is only used when `type` is `trigger_event_count` or `external_data`
        """
        return pulumi.get(self, "ttl_seconds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The [type of value](https://support.pagerduty.com/docs/event-orchestration-variables) to store into the Cache Variable. Can be one of: `recent_value`, `trigger_event_count` or `external_data`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The type of data that will eventually be set for the Cache Variable via an API request. This field is only used when type is `external_data`
        """
        return pulumi.get(self, "data_type")


@pulumi.output_type
class GetEventOrchestrationsEventOrchestrationResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 integrations: Sequence['outputs.GetEventOrchestrationsEventOrchestrationIntegrationResult'],
                 name: _builtins.str):
        """
        :param _builtins.str id: ID of the integration
        :param Sequence['GetEventOrchestrationsEventOrchestrationIntegrationArgs'] integrations: A list of integrations for the Event Orchestration.
        :param _builtins.str name: The name of the found Event Orchestration.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "integrations", integrations)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def integrations(self) -> Sequence['outputs.GetEventOrchestrationsEventOrchestrationIntegrationResult']:
        """
        A list of integrations for the Event Orchestration.
        """
        return pulumi.get(self, "integrations")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the found Event Orchestration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetEventOrchestrationsEventOrchestrationIntegrationResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 label: _builtins.str,
                 parameters: Sequence['outputs.GetEventOrchestrationsEventOrchestrationIntegrationParameterResult']):
        """
        :param _builtins.str id: ID of the integration
        :param Sequence['GetEventOrchestrationsEventOrchestrationIntegrationParameterArgs'] parameters: A single-item list containing a parameter object describing the integration
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def label(self) -> _builtins.str:
        return pulumi.get(self, "label")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.GetEventOrchestrationsEventOrchestrationIntegrationParameterResult']:
        """
        A single-item list containing a parameter object describing the integration
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetEventOrchestrationsEventOrchestrationIntegrationParameterResult(dict):
    def __init__(__self__, *,
                 routing_key: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str routing_key: Routing key that routes to this Orchestration.
        :param _builtins.str type: Type of the routing key. `global` is the default type.
        """
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> _builtins.str:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIncidentTypeCustomFieldFieldOptionResult(dict):
    def __init__(__self__, *,
                 data: 'outputs.GetIncidentTypeCustomFieldFieldOptionDataResult',
                 id: _builtins.str,
                 type: _builtins.str):
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> 'outputs.GetIncidentTypeCustomFieldFieldOptionDataResult':
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


@pulumi.output_type
class GetIncidentTypeCustomFieldFieldOptionDataResult(dict):
    def __init__(__self__, *,
                 data_type: _builtins.str,
                 value: _builtins.str):
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> _builtins.str:
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class GetLicensesLicenseResult(dict):
    def __init__(__self__, *,
                 allocations_available: _builtins.int,
                 current_value: _builtins.int,
                 description: _builtins.str,
                 html_url: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 role_group: _builtins.str,
                 self: _builtins.str,
                 summary: _builtins.str,
                 type: _builtins.str,
                 valid_roles: Sequence[_builtins.str]):
        """
        :param _builtins.int allocations_available: Available allocations to assign to users
        :param _builtins.int current_value: The number of allocations already assigned to users
        :param _builtins.str description: Description of the license
        :param _builtins.str id: Allows to override the default behavior for setting the `id` attribute that is required for data sources.
        :param _builtins.str name: Name of the license
        :param _builtins.str role_group: The role group for the license that determines the available `valid_roles`
        :param _builtins.str summary: Summary of the license
        :param Sequence[_builtins.str] valid_roles: List of allowed roles that may be assigned to a user with this license
        """
        pulumi.set(__self__, "allocations_available", allocations_available)
        pulumi.set(__self__, "current_value", current_value)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "html_url", html_url)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role_group", role_group)
        pulumi.set(__self__, "self", self)
        pulumi.set(__self__, "summary", summary)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "valid_roles", valid_roles)

    @_builtins.property
    @pulumi.getter(name="allocationsAvailable")
    def allocations_available(self) -> _builtins.int:
        """
        Available allocations to assign to users
        """
        return pulumi.get(self, "allocations_available")

    @_builtins.property
    @pulumi.getter(name="currentValue")
    def current_value(self) -> _builtins.int:
        """
        The number of allocations already assigned to users
        """
        return pulumi.get(self, "current_value")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the license
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="htmlUrl")
    def html_url(self) -> _builtins.str:
        return pulumi.get(self, "html_url")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Allows to override the default behavior for setting the `id` attribute that is required for data sources.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the license
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="roleGroup")
    def role_group(self) -> _builtins.str:
        """
        The role group for the license that determines the available `valid_roles`
        """
        return pulumi.get(self, "role_group")

    @_builtins.property
    @pulumi.getter
    def self(self) -> _builtins.str:
        return pulumi.get(self, "self")

    @_builtins.property
    @pulumi.getter
    def summary(self) -> _builtins.str:
        """
        Summary of the license
        """
        return pulumi.get(self, "summary")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="validRoles")
    def valid_roles(self) -> Sequence[_builtins.str]:
        """
        List of allowed roles that may be assigned to a user with this license
        """
        return pulumi.get(self, "valid_roles")


@pulumi.output_type
class GetServiceCustomFieldFieldOptionResult(dict):
    def __init__(__self__, *,
                 data_type: _builtins.str,
                 id: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str data_type: The data type of the field option.
        :param _builtins.str id: The ID of the found field.
        :param _builtins.str value: The value of the field option.
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> _builtins.str:
        """
        The data type of the field option.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the found field.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the field option.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServiceCustomFieldValueCustomFieldResult(dict):
    def __init__(__self__, *,
                 data_type: _builtins.str,
                 description: _builtins.str,
                 display_name: _builtins.str,
                 field_type: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 type: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str data_type: The kind of data the custom field is allowed to contain. Can be one of: `string`, `integer`, `float`, `boolean`, `datetime`, or `url`.
        :param _builtins.str description: A description of the data this field contains.
        :param _builtins.str display_name: The human-readable name of the custom field.
        :param _builtins.str field_type: The type of field. Can be one of: `single_value`, `single_value_fixed`, `multi_value`, or `multi_value_fixed`.
        :param _builtins.str id: The ID of the custom field.
        :param _builtins.str name: The name of the custom field.
        :param _builtins.str type: The type of the reference, typically "field_value".
        :param _builtins.str value: The value of the custom field. This is a JSON-encoded string matching the field's data type.
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "display_name", display_name)
        pulumi.set(__self__, "field_type", field_type)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> _builtins.str:
        """
        The kind of data the custom field is allowed to contain. Can be one of: `string`, `integer`, `float`, `boolean`, `datetime`, or `url`.
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        A description of the data this field contains.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The human-readable name of the custom field.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> _builtins.str:
        """
        The type of field. Can be one of: `single_value`, `single_value_fixed`, `multi_value`, or `multi_value_fixed`.
        """
        return pulumi.get(self, "field_type")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the custom field.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the custom field.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the reference, typically "field_value".
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The value of the custom field. This is a JSON-encoded string matching the field's data type.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetServiceTeamResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 name: _builtins.str):
        """
        :param _builtins.str id: The ID of the found service.
        :param _builtins.str name: The service name to use to find a service in the PagerDuty API.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the found service.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The service name to use to find a service in the PagerDuty API.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetStandardsResourceScoresScoreResult(dict):
    def __init__(__self__, *,
                 passing: _builtins.int,
                 total: _builtins.int):
        """
        :param _builtins.int passing: Number of standards this resource successfully complies to.
        :param _builtins.int total: Number of standards associated to this resource.
        """
        pulumi.set(__self__, "passing", passing)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def passing(self) -> _builtins.int:
        """
        Number of standards this resource successfully complies to.
        """
        return pulumi.get(self, "passing")

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        Number of standards associated to this resource.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class GetStandardsResourceScoresStandardResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 pass_: _builtins.bool,
                 type: _builtins.str):
        """
        :param _builtins.bool active: Indicates whether the standard is currently active and applicable to the resource.
        :param _builtins.str description: Provides a textual description of the standard.
        :param _builtins.str id: Identifier of said resource.
        :param _builtins.str name: The human-readable name of the standard.
        :param _builtins.bool pass_: Indicates whether the resource complies to this standard.
        :param _builtins.str type: The type of the standard.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pass_", pass_)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Indicates whether the standard is currently active and applicable to the resource.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Provides a textual description of the standard.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Identifier of said resource.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The human-readable name of the standard.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pass")
    def pass_(self) -> _builtins.bool:
        """
        Indicates whether the resource complies to this standard.
        """
        return pulumi.get(self, "pass_")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the standard.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStandardsResourcesScoresResourceResult(dict):
    def __init__(__self__, *,
                 resource_id: _builtins.str,
                 resource_type: _builtins.str,
                 score: 'outputs.GetStandardsResourcesScoresResourceScoreResult',
                 standards: Sequence['outputs.GetStandardsResourcesScoresResourceStandardResult']):
        """
        :param _builtins.str resource_id: Unique Identifier.
        :param _builtins.str resource_type: Type of the object the standards are associated to. Allowed values are `technical_services`.
        :param 'GetStandardsResourcesScoresResourceScoreArgs' score: Summary of the scores for standards associated with this resource.
        :param Sequence['GetStandardsResourcesScoresResourceStandardArgs'] standards: The list of standards evaluated against.
        """
        pulumi.set(__self__, "resource_id", resource_id)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "score", score)
        pulumi.set(__self__, "standards", standards)

    @_builtins.property
    @pulumi.getter(name="resourceId")
    def resource_id(self) -> _builtins.str:
        """
        Unique Identifier.
        """
        return pulumi.get(self, "resource_id")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Type of the object the standards are associated to. Allowed values are `technical_services`.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def score(self) -> 'outputs.GetStandardsResourcesScoresResourceScoreResult':
        """
        Summary of the scores for standards associated with this resource.
        """
        return pulumi.get(self, "score")

    @_builtins.property
    @pulumi.getter
    def standards(self) -> Sequence['outputs.GetStandardsResourcesScoresResourceStandardResult']:
        """
        The list of standards evaluated against.
        """
        return pulumi.get(self, "standards")


@pulumi.output_type
class GetStandardsResourcesScoresResourceScoreResult(dict):
    def __init__(__self__, *,
                 passing: _builtins.int,
                 total: _builtins.int):
        """
        :param _builtins.int passing: Number of standards this resource successfully complies to.
        :param _builtins.int total: Number of standards associated to this resource.
        """
        pulumi.set(__self__, "passing", passing)
        pulumi.set(__self__, "total", total)

    @_builtins.property
    @pulumi.getter
    def passing(self) -> _builtins.int:
        """
        Number of standards this resource successfully complies to.
        """
        return pulumi.get(self, "passing")

    @_builtins.property
    @pulumi.getter
    def total(self) -> _builtins.int:
        """
        Number of standards associated to this resource.
        """
        return pulumi.get(self, "total")


@pulumi.output_type
class GetStandardsResourcesScoresResourceStandardResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 pass_: _builtins.bool,
                 type: _builtins.str):
        """
        :param _builtins.bool active: Indicates whether the standard is currently active and applicable to the resource.
        :param _builtins.str description: Provides a textual description of the standard.
        :param _builtins.str id: A unique identifier for the standard.
        :param _builtins.str name: The human-readable name of the standard.
        :param _builtins.bool pass_: Indicates whether the resource complies to this standard.
        :param _builtins.str type: The type of the standard.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "pass_", pass_)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Indicates whether the standard is currently active and applicable to the resource.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Provides a textual description of the standard.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A unique identifier for the standard.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The human-readable name of the standard.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pass")
    def pass_(self) -> _builtins.bool:
        """
        Indicates whether the resource complies to this standard.
        """
        return pulumi.get(self, "pass_")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the standard.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStandardsStandardResult(dict):
    def __init__(__self__, *,
                 active: _builtins.bool,
                 description: _builtins.str,
                 exclusions: Sequence['outputs.GetStandardsStandardExclusionResult'],
                 id: _builtins.str,
                 inclusions: Sequence['outputs.GetStandardsStandardInclusionResult'],
                 name: _builtins.str,
                 resource_type: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.bool active: Indicates whether the standard is currently active and applicable to the resource.
        :param _builtins.str description: Provides a textual description of the standard.
        :param Sequence['GetStandardsStandardExclusionArgs'] exclusions: A list of exceptions for the application of this standard.
        :param _builtins.str id: The unique identifier for the resource being included.
        :param Sequence['GetStandardsStandardInclusionArgs'] inclusions: A list of explict instances this standard applies to.
        :param _builtins.str name: The human-readable name of the standard.
        :param _builtins.str resource_type: Filter by `resource_type` the received standards. Allowed values are `technical_service`.
        :param _builtins.str type: Specifies the type of resource this inclusion applies to.
        """
        pulumi.set(__self__, "active", active)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "exclusions", exclusions)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "inclusions", inclusions)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def active(self) -> _builtins.bool:
        """
        Indicates whether the standard is currently active and applicable to the resource.
        """
        return pulumi.get(self, "active")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Provides a textual description of the standard.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def exclusions(self) -> Sequence['outputs.GetStandardsStandardExclusionResult']:
        """
        A list of exceptions for the application of this standard.
        """
        return pulumi.get(self, "exclusions")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for the resource being included.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def inclusions(self) -> Sequence['outputs.GetStandardsStandardInclusionResult']:
        """
        A list of explict instances this standard applies to.
        """
        return pulumi.get(self, "inclusions")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The human-readable name of the standard.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        Filter by `resource_type` the received standards. Allowed values are `technical_service`.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of resource this inclusion applies to.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStandardsStandardExclusionResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The unique identifier for the resource being included.
        :param _builtins.str type: Specifies the type of resource this inclusion applies to.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for the resource being included.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of resource this inclusion applies to.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetStandardsStandardInclusionResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The unique identifier for the resource being included.
        :param _builtins.str type: Specifies the type of resource this inclusion applies to.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The unique identifier for the resource being included.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Specifies the type of resource this inclusion applies to.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTeamMembersMemberResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 role: _builtins.str,
                 summary: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str id: The ID of the found user.
        :param _builtins.str role: The team role of the found user.
        :param _builtins.str summary: A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to name, though it is not intended to be an identifier.
        :param _builtins.str type: The type of object. The value returned will be `user_reference`. Can be used for passing to another object as dependency.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "summary", summary)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the found user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The team role of the found user.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter
    def summary(self) -> _builtins.str:
        """
        A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to name, though it is not intended to be an identifier.
        """
        return pulumi.get(self, "summary")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of object. The value returned will be `user_reference`. Can be used for passing to another object as dependency.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetTeamsTeamResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 summary: _builtins.str):
        """
        :param _builtins.str description: The description of the team.
        :param _builtins.str id: The ID of the team.
        :param _builtins.str name: The name of the team.
        :param _builtins.str summary: A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to name, though it is not intended to be an identifier.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "summary", summary)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the team.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the team.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the team.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def summary(self) -> _builtins.str:
        """
        A short-form, server-generated string that provides succinct, important information about an object suitable for primary labeling of an entity in a client. In many cases, this will be identical to name, though it is not intended to be an identifier.
        """
        return pulumi.get(self, "summary")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 email: _builtins.str,
                 id: _builtins.str,
                 job_title: _builtins.str,
                 name: _builtins.str,
                 role: _builtins.str,
                 time_zone: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str description: The human-friendly description of the found user.
        :param _builtins.str email: The email of the found user.
        :param _builtins.str id: The ID of the found user.
        :param _builtins.str job_title: The job title of the found user.
        :param _builtins.str name: The short name of the found user.
        :param _builtins.str role: The role of the found user.
        :param _builtins.str time_zone: The timezone of the found user.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "job_title", job_title)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "role", role)
        pulumi.set(__self__, "time_zone", time_zone)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The human-friendly description of the found user.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def email(self) -> _builtins.str:
        """
        The email of the found user.
        """
        return pulumi.get(self, "email")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the found user.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="jobTitle")
    def job_title(self) -> _builtins.str:
        """
        The job title of the found user.
        """
        return pulumi.get(self, "job_title")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The short name of the found user.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        The role of the found user.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The timezone of the found user.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        return pulumi.get(self, "type")


