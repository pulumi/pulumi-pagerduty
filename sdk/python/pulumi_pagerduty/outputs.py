# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AutomationActionsActionActionDataReference',
    'EscalationPolicyRule',
    'EscalationPolicyRuleTarget',
    'EventOrchestrationIntegration',
    'EventOrchestrationIntegrationParameter',
    'EventOrchestrationRouterCatchAll',
    'EventOrchestrationRouterCatchAllActions',
    'EventOrchestrationRouterSet',
    'EventOrchestrationRouterSetRule',
    'EventOrchestrationRouterSetRuleActions',
    'EventOrchestrationRouterSetRuleCondition',
    'EventOrchestrationServiceCatchAll',
    'EventOrchestrationServiceCatchAllActions',
    'EventOrchestrationServiceCatchAllActionsAutomationAction',
    'EventOrchestrationServiceCatchAllActionsAutomationActionHeader',
    'EventOrchestrationServiceCatchAllActionsAutomationActionParameter',
    'EventOrchestrationServiceCatchAllActionsExtraction',
    'EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction',
    'EventOrchestrationServiceCatchAllActionsVariable',
    'EventOrchestrationServiceSet',
    'EventOrchestrationServiceSetRule',
    'EventOrchestrationServiceSetRuleActions',
    'EventOrchestrationServiceSetRuleActionsAutomationAction',
    'EventOrchestrationServiceSetRuleActionsAutomationActionHeader',
    'EventOrchestrationServiceSetRuleActionsAutomationActionParameter',
    'EventOrchestrationServiceSetRuleActionsExtraction',
    'EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction',
    'EventOrchestrationServiceSetRuleActionsVariable',
    'EventOrchestrationServiceSetRuleCondition',
    'EventOrchestrationUnroutedCatchAll',
    'EventOrchestrationUnroutedCatchAllActions',
    'EventOrchestrationUnroutedCatchAllActionsExtraction',
    'EventOrchestrationUnroutedCatchAllActionsVariable',
    'EventOrchestrationUnroutedSet',
    'EventOrchestrationUnroutedSetRule',
    'EventOrchestrationUnroutedSetRuleActions',
    'EventOrchestrationUnroutedSetRuleActionsExtraction',
    'EventOrchestrationUnroutedSetRuleActionsVariable',
    'EventOrchestrationUnroutedSetRuleCondition',
    'IncidentWorkflowStep',
    'IncidentWorkflowStepInput',
    'ResponsePlayResponder',
    'ResponsePlayResponderEscalationRule',
    'ResponsePlayResponderEscalationRuleTarget',
    'ResponsePlayResponderService',
    'ResponsePlayResponderTeam',
    'ResponsePlaySubscriber',
    'RulesetRuleActions',
    'RulesetRuleActionsAnnotate',
    'RulesetRuleActionsEventAction',
    'RulesetRuleActionsExtraction',
    'RulesetRuleActionsPriority',
    'RulesetRuleActionsRoute',
    'RulesetRuleActionsSeverity',
    'RulesetRuleActionsSuppress',
    'RulesetRuleActionsSuspend',
    'RulesetRuleConditions',
    'RulesetRuleConditionsSubcondition',
    'RulesetRuleConditionsSubconditionParameter',
    'RulesetRuleTimeFrame',
    'RulesetRuleTimeFrameActiveBetween',
    'RulesetRuleTimeFrameScheduledWeekly',
    'RulesetRuleVariable',
    'RulesetRuleVariableParameter',
    'RulesetTeam',
    'ScheduleFinalSchedule',
    'ScheduleLayer',
    'ScheduleLayerRestriction',
    'ServiceAlertGroupingParameters',
    'ServiceAlertGroupingParametersConfig',
    'ServiceAutoPauseNotificationsParameters',
    'ServiceDependencyDependency',
    'ServiceDependencyDependencyDependentService',
    'ServiceDependencyDependencySupportingService',
    'ServiceEventRuleActions',
    'ServiceEventRuleActionsAnnotate',
    'ServiceEventRuleActionsEventAction',
    'ServiceEventRuleActionsExtraction',
    'ServiceEventRuleActionsPriority',
    'ServiceEventRuleActionsSeverity',
    'ServiceEventRuleActionsSuppress',
    'ServiceEventRuleActionsSuspend',
    'ServiceEventRuleConditions',
    'ServiceEventRuleConditionsSubcondition',
    'ServiceEventRuleConditionsSubconditionParameter',
    'ServiceEventRuleTimeFrame',
    'ServiceEventRuleTimeFrameActiveBetween',
    'ServiceEventRuleTimeFrameScheduledWeekly',
    'ServiceEventRuleVariable',
    'ServiceEventRuleVariableParameter',
    'ServiceIncidentUrgencyRule',
    'ServiceIncidentUrgencyRuleDuringSupportHours',
    'ServiceIncidentUrgencyRuleOutsideSupportHours',
    'ServiceIntegrationEmailFilter',
    'ServiceIntegrationEmailParser',
    'ServiceIntegrationEmailParserMatchPredicate',
    'ServiceIntegrationEmailParserMatchPredicatePredicate',
    'ServiceIntegrationEmailParserMatchPredicatePredicatePredicate',
    'ServiceIntegrationEmailParserValueExtractor',
    'ServiceScheduledAction',
    'ServiceScheduledActionAt',
    'ServiceSupportHours',
    'SlackConnectionConfig',
    'WebhookSubscriptionDeliveryMethod',
    'WebhookSubscriptionDeliveryMethodCustomHeader',
    'WebhookSubscriptionFilter',
    'GetAutomationActionsActionActionDataReferenceResult',
    'GetEventOrchestrationIntegrationResult',
    'GetEventOrchestrationIntegrationParameterResult',
    'GetEventOrchestrationsEventOrchestrationResult',
    'GetEventOrchestrationsEventOrchestrationIntegrationResult',
    'GetEventOrchestrationsEventOrchestrationIntegrationParameterResult',
    'GetUsersUserResult',
]

@pulumi.output_type
class AutomationActionsActionActionDataReference(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "invocationCommand":
            suggest = "invocation_command"
        elif key == "processAutomationJobArguments":
            suggest = "process_automation_job_arguments"
        elif key == "processAutomationJobId":
            suggest = "process_automation_job_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AutomationActionsActionActionDataReference. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AutomationActionsActionActionDataReference.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AutomationActionsActionActionDataReference.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 invocation_command: Optional[str] = None,
                 process_automation_job_arguments: Optional[str] = None,
                 process_automation_job_id: Optional[str] = None,
                 script: Optional[str] = None):
        """
        :param str invocation_command: The command to execute the script with.
        :param str process_automation_job_arguments: The arguments to pass to the Process Automation job execution.
        :param str process_automation_job_id: The ID of the Process Automation job to execute.
        :param str script: Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        if invocation_command is not None:
            pulumi.set(__self__, "invocation_command", invocation_command)
        if process_automation_job_arguments is not None:
            pulumi.set(__self__, "process_automation_job_arguments", process_automation_job_arguments)
        if process_automation_job_id is not None:
            pulumi.set(__self__, "process_automation_job_id", process_automation_job_id)
        if script is not None:
            pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter(name="invocationCommand")
    def invocation_command(self) -> Optional[str]:
        """
        The command to execute the script with.
        """
        return pulumi.get(self, "invocation_command")

    @property
    @pulumi.getter(name="processAutomationJobArguments")
    def process_automation_job_arguments(self) -> Optional[str]:
        """
        The arguments to pass to the Process Automation job execution.
        """
        return pulumi.get(self, "process_automation_job_arguments")

    @property
    @pulumi.getter(name="processAutomationJobId")
    def process_automation_job_id(self) -> Optional[str]:
        """
        The ID of the Process Automation job to execute.
        """
        return pulumi.get(self, "process_automation_job_id")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        """
        Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        return pulumi.get(self, "script")


@pulumi.output_type
class EscalationPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationDelayInMinutes":
            suggest = "escalation_delay_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_delay_in_minutes: int,
                 targets: Sequence['outputs.EscalationPolicyRuleTarget'],
                 id: Optional[str] = None):
        """
        :param int escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param str id: A target ID
        """
        pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        pulumi.set(__self__, "targets", targets)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> int:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.EscalationPolicyRuleTarget']:
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A target ID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class EscalationPolicyRuleTarget(dict):
    def __init__(__self__, *,
                 id: str,
                 type: Optional[str] = None):
        """
        :param str id: A target ID
        :param str type: Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Can be `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EventOrchestrationIntegration(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.EventOrchestrationIntegrationParameter']] = None):
        """
        :param str id: ID of the integration
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.EventOrchestrationIntegrationParameter']]:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class EventOrchestrationIntegrationParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routingKey":
            suggest = "routing_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationIntegrationParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationIntegrationParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationIntegrationParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 routing_key: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str routing_key: Routing key that routes to this Orchestration.
        :param str type: Type of the routing key. `global` is the default type.
        """
        if routing_key is not None:
            pulumi.set(__self__, "routing_key", routing_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> Optional[str]:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class EventOrchestrationRouterCatchAll(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationRouterCatchAllActions'):
        """
        :param 'EventOrchestrationRouterCatchAllActionsArgs' actions: These are the actions that will be taken to change the resulting alert and incident.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationRouterCatchAllActions':
        """
        These are the actions that will be taken to change the resulting alert and incident.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class EventOrchestrationRouterCatchAllActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationRouterCatchAllActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationRouterCatchAllActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationRouterCatchAllActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route_to: str):
        """
        :param str route_to: The ID of the target Service for the resulting alert.
        """
        pulumi.set(__self__, "route_to", route_to)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> str:
        """
        The ID of the target Service for the resulting alert.
        """
        return pulumi.get(self, "route_to")


@pulumi.output_type
class EventOrchestrationRouterSet(dict):
    def __init__(__self__, *,
                 id: str,
                 rules: Optional[Sequence['outputs.EventOrchestrationRouterSetRule']] = None):
        """
        :param str id: ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EventOrchestrationRouterSetRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class EventOrchestrationRouterSetRule(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationRouterSetRuleActions',
                 conditions: Optional[Sequence['outputs.EventOrchestrationRouterSetRuleCondition']] = None,
                 disabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param 'EventOrchestrationRouterSetRuleActionsArgs' actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param Sequence['EventOrchestrationRouterSetRuleConditionArgs'] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        :param bool disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param str id: ID of the `start` set. Router supports only one set and it's id has to be `start`
        :param str label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationRouterSetRuleActions':
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.EventOrchestrationRouterSetRuleCondition']]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will _always_ match against the rule.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the `start` set. Router supports only one set and it's id has to be `start`
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class EventOrchestrationRouterSetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationRouterSetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationRouterSetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationRouterSetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 route_to: str):
        """
        :param str route_to: The ID of the target Service for the resulting alert.
        """
        pulumi.set(__self__, "route_to", route_to)

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> str:
        """
        The ID of the target Service for the resulting alert.
        """
        return pulumi.get(self, "route_to")


@pulumi.output_type
class EventOrchestrationRouterSetRuleCondition(dict):
    def __init__(__self__, *,
                 expression: str):
        """
        :param str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class EventOrchestrationServiceCatchAll(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationServiceCatchAllActions'):
        """
        :param 'EventOrchestrationServiceCatchAllActionsArgs' actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationServiceCatchAllActions':
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationAction":
            suggest = "automation_action"
        elif key == "eventAction":
            suggest = "event_action"
        elif key == "pagerdutyAutomationAction":
            suggest = "pagerduty_automation_action"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceCatchAllActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceCatchAllActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceCatchAllActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotate: Optional[str] = None,
                 automation_action: Optional['outputs.EventOrchestrationServiceCatchAllActionsAutomationAction'] = None,
                 event_action: Optional[str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsExtraction']] = None,
                 pagerduty_automation_action: Optional['outputs.EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction'] = None,
                 priority: Optional[str] = None,
                 route_to: Optional[str] = None,
                 severity: Optional[str] = None,
                 suppress: Optional[bool] = None,
                 suspend: Optional[int] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsVariable']] = None):
        """
        :param str annotate: Add this text as a note on the resulting incident.
        :param 'EventOrchestrationServiceCatchAllActionsAutomationActionArgs' automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationServiceCatchAllActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param 'EventOrchestrationServiceCatchAllActionsPagerdutyAutomationActionArgs' pagerduty_automation_action: Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        :param str route_to: The ID of a Set from this Service Orchestration whose rules you also want to use with event that match this rule.
        :param str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param bool suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param int suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert.
        :param Sequence['EventOrchestrationServiceCatchAllActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if pagerduty_automation_action is not None:
            pulumi.set(__self__, "pagerduty_automation_action", pagerduty_automation_action)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[str]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional['outputs.EventOrchestrationServiceCatchAllActionsAutomationAction']:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter(name="pagerdutyAutomationAction")
    def pagerduty_automation_action(self) -> Optional['outputs.EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction']:
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        """
        return pulumi.get(self, "pagerduty_automation_action")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[str]:
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with event that match this rule.
        """
        return pulumi.get(self, "route_to")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def suppress(self) -> Optional[bool]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[int]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert.
        """
        return pulumi.get(self, "suspend")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSend":
            suggest = "auto_send"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceCatchAllActionsAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceCatchAllActionsAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceCatchAllActionsAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 url: str,
                 auto_send: Optional[bool] = None,
                 headers: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsAutomationActionHeader']] = None,
                 parameters: Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsAutomationActionParameter']] = None):
        """
        :param str name: Name of this Webhook.
        :param str url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param bool auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param Sequence['EventOrchestrationServiceCatchAllActionsAutomationActionHeaderArgs'] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param Sequence['EventOrchestrationServiceCatchAllActionsAutomationActionParameterArgs'] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[bool]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsAutomationActionHeader']]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.EventOrchestrationServiceCatchAllActionsAutomationActionParameter']]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsAutomationActionHeader(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Name to identify the header
        :param str value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsAutomationActionParameter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Name to identify the header
        :param str value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsExtraction(dict):
    def __init__(__self__, *,
                 target: str,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionId":
            suggest = "action_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceCatchAllActionsPagerdutyAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_id: str):
        """
        :param str action_id: Id of the Process Automation action to be triggered.
        """
        pulumi.set(__self__, "action_id", action_id)

    @property
    @pulumi.getter(name="actionId")
    def action_id(self) -> str:
        """
        Id of the Process Automation action to be triggered.
        """
        return pulumi.get(self, "action_id")


@pulumi.output_type
class EventOrchestrationServiceCatchAllActionsVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 path: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of this Webhook.
        :param str path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param str type: Only `regex` is supported
        :param str value: Value of this header
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSet(dict):
    def __init__(__self__, *,
                 id: str,
                 rules: Optional[Sequence['outputs.EventOrchestrationServiceSetRule']] = None):
        """
        :param str id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class EventOrchestrationServiceSetRule(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationServiceSetRuleActions',
                 conditions: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleCondition']] = None,
                 disabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param 'EventOrchestrationServiceSetRuleActionsArgs' actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param Sequence['EventOrchestrationServiceSetRuleConditionArgs'] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param bool disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param str id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        :param str label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationServiceSetRuleActions':
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleCondition']]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "automationAction":
            suggest = "automation_action"
        elif key == "eventAction":
            suggest = "event_action"
        elif key == "pagerdutyAutomationAction":
            suggest = "pagerduty_automation_action"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceSetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceSetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceSetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotate: Optional[str] = None,
                 automation_action: Optional['outputs.EventOrchestrationServiceSetRuleActionsAutomationAction'] = None,
                 event_action: Optional[str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsExtraction']] = None,
                 pagerduty_automation_action: Optional['outputs.EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction'] = None,
                 priority: Optional[str] = None,
                 route_to: Optional[str] = None,
                 severity: Optional[str] = None,
                 suppress: Optional[bool] = None,
                 suspend: Optional[int] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsVariable']] = None):
        """
        :param str annotate: Add this text as a note on the resulting incident.
        :param 'EventOrchestrationServiceSetRuleActionsAutomationActionArgs' automation_action: Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        :param str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationServiceSetRuleActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param 'EventOrchestrationServiceSetRuleActionsPagerdutyAutomationActionArgs' pagerduty_automation_action: Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        :param str route_to: The ID of a Set from this Service Orchestration whose rules you also want to use with event that match this rule.
        :param str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param bool suppress: Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        :param int suspend: The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert.
        :param Sequence['EventOrchestrationServiceSetRuleActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if annotate is not None:
            pulumi.set(__self__, "annotate", annotate)
        if automation_action is not None:
            pulumi.set(__self__, "automation_action", automation_action)
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if pagerduty_automation_action is not None:
            pulumi.set(__self__, "pagerduty_automation_action", pagerduty_automation_action)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if suspend is not None:
            pulumi.set(__self__, "suspend", suspend)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter
    def annotate(self) -> Optional[str]:
        """
        Add this text as a note on the resulting incident.
        """
        return pulumi.get(self, "annotate")

    @property
    @pulumi.getter(name="automationAction")
    def automation_action(self) -> Optional['outputs.EventOrchestrationServiceSetRuleActionsAutomationAction']:
        """
        Create a [Webhook](https://support.pagerduty.com/docs/event-orchestration#webhooks) associated with the resulting incident.
        """
        return pulumi.get(self, "automation_action")

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter(name="pagerdutyAutomationAction")
    def pagerduty_automation_action(self) -> Optional['outputs.EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction']:
        """
        Configure a [Process Automation](https://support.pagerduty.com/docs/event-orchestration#process-automation) associated with the resulting incident.
        """
        return pulumi.get(self, "pagerduty_automation_action")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[str]:
        """
        The ID of a Set from this Service Orchestration whose rules you also want to use with event that match this rule.
        """
        return pulumi.get(self, "route_to")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def suppress(self) -> Optional[bool]:
        """
        Set whether the resulting alert is suppressed. Suppressed alerts will not trigger an incident.
        """
        return pulumi.get(self, "suppress")

    @property
    @pulumi.getter
    def suspend(self) -> Optional[int]:
        """
        The number of seconds to suspend the resulting alert before triggering. This effectively pauses incident notifications. If a `resolve` event arrives before the alert triggers then PagerDuty won't create an incident for this the resulting alert.
        """
        return pulumi.get(self, "suspend")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoSend":
            suggest = "auto_send"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceSetRuleActionsAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceSetRuleActionsAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceSetRuleActionsAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 url: str,
                 auto_send: Optional[bool] = None,
                 headers: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsAutomationActionHeader']] = None,
                 parameters: Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsAutomationActionParameter']] = None):
        """
        :param str name: Name of this Webhook.
        :param str url: The API endpoint where PagerDuty's servers will send the webhook request.
        :param bool auto_send: When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        :param Sequence['EventOrchestrationServiceSetRuleActionsAutomationActionHeaderArgs'] headers: Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        :param Sequence['EventOrchestrationServiceSetRuleActionsAutomationActionParameterArgs'] parameters: Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "url", url)
        if auto_send is not None:
            pulumi.set(__self__, "auto_send", auto_send)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def url(self) -> str:
        """
        The API endpoint where PagerDuty's servers will send the webhook request.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="autoSend")
    def auto_send(self) -> Optional[bool]:
        """
        When true, PagerDuty's servers will automatically send this webhook request as soon as the resulting incident is created. When false, your incident responder will be able to manually trigger the Webhook via the PagerDuty website and mobile app.
        """
        return pulumi.get(self, "auto_send")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsAutomationActionHeader']]:
        """
        Specify custom key/value pairs that'll be sent with the webhook request as request headers.
        """
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.EventOrchestrationServiceSetRuleActionsAutomationActionParameter']]:
        """
        Specify custom key/value pairs that'll be included in the webhook request's JSON payload.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsAutomationActionHeader(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Name to identify the header
        :param str value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsAutomationActionParameter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Name to identify the header
        :param str value: Value of this header
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Name to identify the header
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 target: str,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionId":
            suggest = "action_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationServiceSetRuleActionsPagerdutyAutomationAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_id: str):
        """
        :param str action_id: Id of the Process Automation action to be triggered.
        """
        pulumi.set(__self__, "action_id", action_id)

    @property
    @pulumi.getter(name="actionId")
    def action_id(self) -> str:
        """
        Id of the Process Automation action to be triggered.
        """
        return pulumi.get(self, "action_id")


@pulumi.output_type
class EventOrchestrationServiceSetRuleActionsVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 path: str,
                 type: str,
                 value: str):
        """
        :param str name: Name of this Webhook.
        :param str path: Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        :param str type: Only `regex` is supported
        :param str value: Value of this header
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of this Webhook.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path to a field in an event, in dot-notation. This supports both PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value of this header
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationServiceSetRuleCondition(dict):
    def __init__(__self__, *,
                 expression: str):
        """
        :param str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class EventOrchestrationUnroutedCatchAll(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationUnroutedCatchAllActions'):
        """
        :param 'EventOrchestrationUnroutedCatchAllActionsArgs' actions: These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        pulumi.set(__self__, "actions", actions)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationUnroutedCatchAllActions':
        """
        These are the actions that will be taken to change the resulting alert and incident. `catch_all` supports all actions described above for `rule` _except_ `route_to` action.
        """
        return pulumi.get(self, "actions")


@pulumi.output_type
class EventOrchestrationUnroutedCatchAllActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventAction":
            suggest = "event_action"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationUnroutedCatchAllActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationUnroutedCatchAllActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationUnroutedCatchAllActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_action: Optional[str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationUnroutedCatchAllActionsExtraction']] = None,
                 severity: Optional[str] = None,
                 suppress: Optional[bool] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationUnroutedCatchAllActionsVariable']] = None):
        """
        :param str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationUnroutedCatchAllActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param Sequence['EventOrchestrationUnroutedCatchAllActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if suppress is not None:
            pulumi.set(__self__, "suppress", suppress)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedCatchAllActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def suppress(self) -> Optional[bool]:
        return pulumi.get(self, "suppress")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedCatchAllActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationUnroutedCatchAllActionsExtraction(dict):
    def __init__(__self__, *,
                 target: str,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationUnroutedCatchAllActionsVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 path: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the variable
        :param str path: Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        :param str type: Only `regex` is supported
        :param str value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationUnroutedSet(dict):
    def __init__(__self__, *,
                 id: str,
                 rules: Optional[Sequence['outputs.EventOrchestrationUnroutedSetRule']] = None):
        """
        :param str id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        pulumi.set(__self__, "id", id)
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedSetRule']]:
        return pulumi.get(self, "rules")


@pulumi.output_type
class EventOrchestrationUnroutedSetRule(dict):
    def __init__(__self__, *,
                 actions: 'outputs.EventOrchestrationUnroutedSetRuleActions',
                 conditions: Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleCondition']] = None,
                 disabled: Optional[bool] = None,
                 id: Optional[str] = None,
                 label: Optional[str] = None):
        """
        :param 'EventOrchestrationUnroutedSetRuleActionsArgs' actions: Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        :param Sequence['EventOrchestrationUnroutedSetRuleConditionArgs'] conditions: Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        :param bool disabled: Indicates whether the rule is disabled and would therefore not be evaluated.
        :param str id: The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        :param str label: A description of this rule's purpose.
        """
        pulumi.set(__self__, "actions", actions)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if label is not None:
            pulumi.set(__self__, "label", label)

    @property
    @pulumi.getter
    def actions(self) -> 'outputs.EventOrchestrationUnroutedSetRuleActions':
        """
        Actions that will be taken to change the resulting alert and incident, when an event matches this rule.
        """
        return pulumi.get(self, "actions")

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleCondition']]:
        """
        Each of these conditions is evaluated to check if an event matches this rule. The rule is considered a match if any of these conditions match. If none are provided, the event will `always` match against the rule.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter
    def disabled(self) -> Optional[bool]:
        """
        Indicates whether the rule is disabled and would therefore not be evaluated.
        """
        return pulumi.get(self, "disabled")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of this set of rules. Rules in other sets can route events into this set using the rule's `route_to` property.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def label(self) -> Optional[str]:
        """
        A description of this rule's purpose.
        """
        return pulumi.get(self, "label")


@pulumi.output_type
class EventOrchestrationUnroutedSetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventAction":
            suggest = "event_action"
        elif key == "routeTo":
            suggest = "route_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EventOrchestrationUnroutedSetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EventOrchestrationUnroutedSetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EventOrchestrationUnroutedSetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_action: Optional[str] = None,
                 extractions: Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleActionsExtraction']] = None,
                 route_to: Optional[str] = None,
                 severity: Optional[str] = None,
                 variables: Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleActionsVariable']] = None):
        """
        :param str event_action: sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        :param Sequence['EventOrchestrationUnroutedSetRuleActionsExtractionArgs'] extractions: Replace any CEF field or Custom Details object field using custom variables.
        :param str route_to: The ID of a Set from this Unrouted Orchestration whose rules you also want to use with event that match this rule.
        :param str severity: sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        :param Sequence['EventOrchestrationUnroutedSetRuleActionsVariableArgs'] variables: Populate variables from event payloads and use those variables in other event actions.
        """
        if event_action is not None:
            pulumi.set(__self__, "event_action", event_action)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if route_to is not None:
            pulumi.set(__self__, "route_to", route_to)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if variables is not None:
            pulumi.set(__self__, "variables", variables)

    @property
    @pulumi.getter(name="eventAction")
    def event_action(self) -> Optional[str]:
        """
        sets whether the resulting alert status is trigger or resolve. Allowed values are: `trigger`, `resolve`
        """
        return pulumi.get(self, "event_action")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleActionsExtraction']]:
        """
        Replace any CEF field or Custom Details object field using custom variables.
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter(name="routeTo")
    def route_to(self) -> Optional[str]:
        """
        The ID of a Set from this Unrouted Orchestration whose rules you also want to use with event that match this rule.
        """
        return pulumi.get(self, "route_to")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        sets Severity of the resulting alert. Allowed values are: `info`, `error`, `warning`, `critical`
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def variables(self) -> Optional[Sequence['outputs.EventOrchestrationUnroutedSetRuleActionsVariable']]:
        """
        Populate variables from event payloads and use those variables in other event actions.
        """
        return pulumi.get(self, "variables")


@pulumi.output_type
class EventOrchestrationUnroutedSetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 target: str,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str target: The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        :param str regex: A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        :param str source: The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        :param str template: A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
               * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
               * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        pulumi.set(__self__, "target", target)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def target(self) -> str:
        """
        The PagerDuty Common Event Format [PD-CEF](https://support.pagerduty.com/docs/pd-cef) field that will be set with the value from the `template` or based on `regex` and `source` fields.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        A [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) that will be matched against field specified via the `source` argument. If the regex contains one or more capture groups, their values will be extracted and appended together. If it contains no capture groups, the whole match is used. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        The path to the event field where the `regex` will be applied to extract a value. You can use any valid [PCL path](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview#paths) like `event.summary` and you can reference previously-defined variables using a path like `variables.hostname`. This field can be ignored for `template` based extractions.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A string that will be used to populate the `target` field. You can reference variables or event data within your template using double curly braces. For example:
        * Use variables named `ip` and `subnet` with a template like: `{{variables.ip}}/{{variables.subnet}}`
        * Combine the event severity & summary with template like: `{{event.severity}}:{{event.summary}}`
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class EventOrchestrationUnroutedSetRuleActionsVariable(dict):
    def __init__(__self__, *,
                 name: str,
                 path: str,
                 type: str,
                 value: str):
        """
        :param str name: The name of the variable
        :param str path: Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        :param str type: Only `regex` is supported
        :param str value: The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the variable
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        Path to a field in an event, in dot-notation. This supports both [PD-CEF](https://support.pagerduty.com/docs/pd-cef) and non-CEF fields. Eg: Use `event.summary` for the `summary` CEF field. Use `raw_event.fieldname` to read from the original event `fieldname` data.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Only `regex` is supported
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The Regex expression to match against. Must use valid [RE2 regular expression](https://github.com/google/re2/wiki/Syntax) syntax.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class EventOrchestrationUnroutedSetRuleCondition(dict):
    def __init__(__self__, *,
                 expression: str):
        """
        :param str expression: A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        A [PCL condition](https://developer.pagerduty.com/docs/ZG9jOjM1NTE0MDc0-pcl-overview) string.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class IncidentWorkflowStep(dict):
    def __init__(__self__, *,
                 action: str,
                 name: str,
                 id: Optional[str] = None,
                 inputs: Optional[Sequence['outputs.IncidentWorkflowStepInput']] = None):
        """
        :param str action: The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        :param str name: The name of the workflow step.
        :param str id: The ID of the incident workflow.
        :param Sequence['IncidentWorkflowStepInputArgs'] inputs: The list of inputs for the workflow action.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "name", name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if inputs is not None:
            pulumi.set(__self__, "inputs", inputs)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        The action id for the workflow step, including the version. A list of actions available can be retrieved using the [PagerDuty API](https://developer.pagerduty.com/api-reference/aa192a25fac39-list-actions).
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the workflow step.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the incident workflow.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def inputs(self) -> Optional[Sequence['outputs.IncidentWorkflowStepInput']]:
        """
        The list of inputs for the workflow action.
        """
        return pulumi.get(self, "inputs")


@pulumi.output_type
class IncidentWorkflowStepInput(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str,
                 generated: Optional[bool] = None):
        """
        :param str name: The name of the input.
        :param str value: The value of the input.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if generated is not None:
            pulumi.set(__self__, "generated", generated)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the input.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the input.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def generated(self) -> Optional[bool]:
        return pulumi.get(self, "generated")


@pulumi.output_type
class ResponsePlayResponder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationRules":
            suggest = "escalation_rules"
        elif key == "numLoops":
            suggest = "num_loops"
        elif key == "onCallHandoffNotifications":
            suggest = "on_call_handoff_notifications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponsePlayResponder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponsePlayResponder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponsePlayResponder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 escalation_rules: Optional[Sequence['outputs.ResponsePlayResponderEscalationRule']] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 num_loops: Optional[int] = None,
                 on_call_handoff_notifications: Optional[str] = None,
                 services: Optional[Sequence['outputs.ResponsePlayResponderService']] = None,
                 teams: Optional[Sequence['outputs.ResponsePlayResponderTeam']] = None,
                 type: Optional[str] = None):
        """
        :param str description: Description of escalation policy
        :param Sequence['ResponsePlayResponderEscalationRuleArgs'] escalation_rules: The escalation rules
        :param str id: ID of the user defined as the responder
        :param str name: Name of the escalation policy
        :param int num_loops: The number of times the escalation policy will repeat after reaching the end of its escalation.
        :param str on_call_handoff_notifications: Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        :param Sequence['ResponsePlayResponderServiceArgs'] services: There can be multiple services associated with a policy.
        :param Sequence['ResponsePlayResponderTeamArgs'] teams: Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        :param str type: Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if escalation_rules is not None:
            pulumi.set(__self__, "escalation_rules", escalation_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_loops is not None:
            pulumi.set(__self__, "num_loops", num_loops)
        if on_call_handoff_notifications is not None:
            pulumi.set(__self__, "on_call_handoff_notifications", on_call_handoff_notifications)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of escalation policy
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="escalationRules")
    def escalation_rules(self) -> Optional[Sequence['outputs.ResponsePlayResponderEscalationRule']]:
        """
        The escalation rules
        """
        return pulumi.get(self, "escalation_rules")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the escalation policy
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numLoops")
    def num_loops(self) -> Optional[int]:
        """
        The number of times the escalation policy will repeat after reaching the end of its escalation.
        """
        return pulumi.get(self, "num_loops")

    @property
    @pulumi.getter(name="onCallHandoffNotifications")
    def on_call_handoff_notifications(self) -> Optional[str]:
        """
        Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        """
        return pulumi.get(self, "on_call_handoff_notifications")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.ResponsePlayResponderService']]:
        """
        There can be multiple services associated with a policy.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence['outputs.ResponsePlayResponderTeam']]:
        """
        Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        """
        return pulumi.get(self, "teams")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of object of the target. Supported types are `user_reference`, `schedule_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderEscalationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationDelayInMinutes":
            suggest = "escalation_delay_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponsePlayResponderEscalationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponsePlayResponderEscalationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponsePlayResponderEscalationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 targets: Sequence['outputs.ResponsePlayResponderEscalationRuleTarget'],
                 escalation_delay_in_minutes: Optional[int] = None,
                 id: Optional[str] = None):
        """
        :param Sequence['ResponsePlayResponderEscalationRuleTargetArgs'] targets: The targets an incident should be assigned to upon reaching this rule.
        :param int escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param str id: ID of the user defined as the responder
        """
        pulumi.set(__self__, "targets", targets)
        if escalation_delay_in_minutes is not None:
            pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.ResponsePlayResponderEscalationRuleTarget']:
        """
        The targets an incident should be assigned to upon reaching this rule.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> Optional[int]:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ResponsePlayResponderEscalationRuleTarget(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: ID of the user defined as the responder
        :param str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: ID of the user defined as the responder
        :param str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderTeam(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        :param str id: ID of the user defined as the responder
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ResponsePlaySubscriber(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: ID of the user defined as the responder
        :param str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RulesetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventActions":
            suggest = "event_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotates: Optional[Sequence['outputs.RulesetRuleActionsAnnotate']] = None,
                 event_actions: Optional[Sequence['outputs.RulesetRuleActionsEventAction']] = None,
                 extractions: Optional[Sequence['outputs.RulesetRuleActionsExtraction']] = None,
                 priorities: Optional[Sequence['outputs.RulesetRuleActionsPriority']] = None,
                 routes: Optional[Sequence['outputs.RulesetRuleActionsRoute']] = None,
                 severities: Optional[Sequence['outputs.RulesetRuleActionsSeverity']] = None,
                 suppresses: Optional[Sequence['outputs.RulesetRuleActionsSuppress']] = None,
                 suspends: Optional[Sequence['outputs.RulesetRuleActionsSuspend']] = None):
        """
        :param Sequence['RulesetRuleActionsAnnotateArgs'] annotates: Note added to the event.
        :param Sequence['RulesetRuleActionsEventActionArgs'] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param Sequence['RulesetRuleActionsExtractionArgs'] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param Sequence['RulesetRuleActionsPriorityArgs'] priorities: The ID of the priority applied to the event.
        :param Sequence['RulesetRuleActionsRouteArgs'] routes: The ID of the service where the event will be routed.
        :param Sequence['RulesetRuleActionsSeverityArgs'] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        :param Sequence['RulesetRuleActionsSuppressArgs'] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        :param Sequence['RulesetRuleActionsSuspendArgs'] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)
        if suspends is not None:
            pulumi.set(__self__, "suspends", suspends)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[Sequence['outputs.RulesetRuleActionsAnnotate']]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[Sequence['outputs.RulesetRuleActionsEventAction']]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.RulesetRuleActionsExtraction']]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence['outputs.RulesetRuleActionsPriority']]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.RulesetRuleActionsRoute']]:
        """
        The ID of the service where the event will be routed.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter
    def severities(self) -> Optional[Sequence['outputs.RulesetRuleActionsSeverity']]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[Sequence['outputs.RulesetRuleActionsSuppress']]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        """
        return pulumi.get(self, "suppresses")

    @property
    @pulumi.getter
    def suspends(self) -> Optional[Sequence['outputs.RulesetRuleActionsSuspend']]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        return pulumi.get(self, "suspends")


@pulumi.output_type
class RulesetRuleActionsAnnotate(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsEventAction(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 target: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
        :param str source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param str target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param str template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class RulesetRuleActionsPriority(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsRoute(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSeverity(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSuppress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdTimeAmount":
            suggest = "threshold_time_amount"
        elif key == "thresholdTimeUnit":
            suggest = "threshold_time_unit"
        elif key == "thresholdValue":
            suggest = "threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionsSuppress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionsSuppress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionsSuppress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_time_amount: Optional[int] = None,
                 threshold_time_unit: Optional[str] = None,
                 threshold_value: Optional[int] = None,
                 value: Optional[bool] = None):
        """
        :param int threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        :param str threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param int threshold_value: The number of alerts that should be suppressed. Must be greater than 0.
        :param bool value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[int]:
        """
        The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_time_amount")

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[str]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[int]:
        """
        The number of alerts that should be suppressed. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSuspend(dict):
    def __init__(__self__, *,
                 value: Optional[int] = None):
        """
        :param int value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleConditions(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 subconditions: Optional[Sequence['outputs.RulesetRuleConditionsSubcondition']] = None):
        """
        :param str operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param Sequence['RulesetRuleConditionsSubconditionArgs'] subconditions: List of sub-conditions that define the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[Sequence['outputs.RulesetRuleConditionsSubcondition']]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")


@pulumi.output_type
class RulesetRuleConditionsSubcondition(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.RulesetRuleConditionsSubconditionParameter']] = None):
        """
        :param str operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param Sequence['RulesetRuleConditionsSubconditionParameterArgs'] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.RulesetRuleConditionsSubconditionParameter']]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class RulesetRuleConditionsSubconditionParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleTimeFrame(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeBetweens":
            suggest = "active_betweens"
        elif key == "scheduledWeeklies":
            suggest = "scheduled_weeklies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrame. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrame.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrame.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_betweens: Optional[Sequence['outputs.RulesetRuleTimeFrameActiveBetween']] = None,
                 scheduled_weeklies: Optional[Sequence['outputs.RulesetRuleTimeFrameScheduledWeekly']] = None):
        """
        :param Sequence['RulesetRuleTimeFrameActiveBetweenArgs'] active_betweens: Values for executing the rule during a specific time period.
        :param Sequence['RulesetRuleTimeFrameScheduledWeeklyArgs'] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[Sequence['outputs.RulesetRuleTimeFrameActiveBetween']]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[Sequence['outputs.RulesetRuleTimeFrameScheduledWeekly']]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")


@pulumi.output_type
class RulesetRuleTimeFrameActiveBetween(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrameActiveBetween. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrameActiveBetween.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrameActiveBetween.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[int] = None,
                 start_time: Optional[int] = None):
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[int]:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class RulesetRuleTimeFrameScheduledWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrameScheduledWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[int] = None,
                 start_time: Optional[int] = None,
                 timezone: Optional[str] = None,
                 weekdays: Optional[Sequence[int]] = None):
        """
        :param int duration: Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        :param str timezone: [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        :param Sequence[int] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[int]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class RulesetRuleVariable(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.RulesetRuleVariableParameter']] = None,
                 type: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.RulesetRuleVariableParameter']]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class RulesetRuleVariableParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetTeam(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the ruleset.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the ruleset.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ScheduleFinalSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "renderedCoveragePercentage":
            suggest = "rendered_coverage_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleFinalSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleFinalSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleFinalSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 rendered_coverage_percentage: Optional[str] = None):
        """
        :param str name: The name of the schedule.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rendered_coverage_percentage is not None:
            pulumi.set(__self__, "rendered_coverage_percentage", rendered_coverage_percentage)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the schedule.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="renderedCoveragePercentage")
    def rendered_coverage_percentage(self) -> Optional[str]:
        return pulumi.get(self, "rendered_coverage_percentage")


@pulumi.output_type
class ScheduleLayer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotationTurnLengthSeconds":
            suggest = "rotation_turn_length_seconds"
        elif key == "rotationVirtualStart":
            suggest = "rotation_virtual_start"
        elif key == "renderedCoveragePercentage":
            suggest = "rendered_coverage_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleLayer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleLayer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleLayer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rotation_turn_length_seconds: int,
                 rotation_virtual_start: str,
                 start: str,
                 users: Sequence[str],
                 end: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 rendered_coverage_percentage: Optional[str] = None,
                 restrictions: Optional[Sequence['outputs.ScheduleLayerRestriction']] = None):
        """
        :param int rotation_turn_length_seconds: The duration of each on-call shift in `seconds`.
        :param str rotation_virtual_start: The effective start time of the schedule layer. This can be before the start time of the schedule.
        :param str start: The start time of the schedule layer.
        :param Sequence[str] users: The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        :param str end: The end time of the schedule layer. If not specified, the layer does not end.
        :param str id: The ID of the schedule.
        :param str name: The name of the schedule layer.
        :param Sequence['ScheduleLayerRestrictionArgs'] restrictions: A schedule layer restriction block. Restriction blocks documented below.
        """
        pulumi.set(__self__, "rotation_turn_length_seconds", rotation_turn_length_seconds)
        pulumi.set(__self__, "rotation_virtual_start", rotation_virtual_start)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "users", users)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if rendered_coverage_percentage is not None:
            pulumi.set(__self__, "rendered_coverage_percentage", rendered_coverage_percentage)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter(name="rotationTurnLengthSeconds")
    def rotation_turn_length_seconds(self) -> int:
        """
        The duration of each on-call shift in `seconds`.
        """
        return pulumi.get(self, "rotation_turn_length_seconds")

    @property
    @pulumi.getter(name="rotationVirtualStart")
    def rotation_virtual_start(self) -> str:
        """
        The effective start time of the schedule layer. This can be before the start time of the schedule.
        """
        return pulumi.get(self, "rotation_virtual_start")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        The start time of the schedule layer.
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter
    def users(self) -> Sequence[str]:
        """
        The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter
    def end(self) -> Optional[str]:
        """
        The end time of the schedule layer. If not specified, the layer does not end.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the schedule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the schedule layer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="renderedCoveragePercentage")
    def rendered_coverage_percentage(self) -> Optional[str]:
        return pulumi.get(self, "rendered_coverage_percentage")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.ScheduleLayerRestriction']]:
        """
        A schedule layer restriction block. Restriction blocks documented below.
        """
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class ScheduleLayerRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationSeconds":
            suggest = "duration_seconds"
        elif key == "startTimeOfDay":
            suggest = "start_time_of_day"
        elif key == "startDayOfWeek":
            suggest = "start_day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleLayerRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleLayerRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleLayerRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_seconds: int,
                 start_time_of_day: str,
                 type: str,
                 start_day_of_week: Optional[int] = None):
        """
        :param int duration_seconds: The duration of the restriction in `seconds`.
        :param str start_time_of_day: The start time in `HH:mm:ss` format.
        :param str type: Can be `daily_restriction` or `weekly_restriction`.
        :param int start_day_of_week: Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        pulumi.set(__self__, "duration_seconds", duration_seconds)
        pulumi.set(__self__, "start_time_of_day", start_time_of_day)
        pulumi.set(__self__, "type", type)
        if start_day_of_week is not None:
            pulumi.set(__self__, "start_day_of_week", start_day_of_week)

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> int:
        """
        The duration of the restriction in `seconds`.
        """
        return pulumi.get(self, "duration_seconds")

    @property
    @pulumi.getter(name="startTimeOfDay")
    def start_time_of_day(self) -> str:
        """
        The start time in `HH:mm:ss` format.
        """
        return pulumi.get(self, "start_time_of_day")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `daily_restriction` or `weekly_restriction`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[int]:
        """
        Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        return pulumi.get(self, "start_day_of_week")


@pulumi.output_type
class ServiceAlertGroupingParameters(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.ServiceAlertGroupingParametersConfig'] = None,
                 type: Optional[str] = None):
        """
        :param 'ServiceAlertGroupingParametersConfigArgs' config: Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.ServiceAlertGroupingParametersConfig']:
        """
        Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceAlertGroupingParametersConfig(dict):
    def __init__(__self__, *,
                 aggregate: Optional[str] = None,
                 fields: Optional[Sequence[str]] = None,
                 timeout: Optional[int] = None):
        """
        :param str aggregate: One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        :param Sequence[str] fields: Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        :param int timeout: The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def aggregate(self) -> Optional[str]:
        """
        One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[str]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ServiceAutoPauseNotificationsParameters(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None,
                 timeout: Optional[int] = None):
        """
        :param bool enabled: Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        :param int timeout: Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Indicates whether alerts should be automatically suspended when identified as transient.  If not passed in, will default to 'false'.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        Indicates in seconds how long alerts should be suspended before triggering. Allowed values: `120`, `180`, `300`, `600`, `900` if `enabled` is `true`. Must be omitted or set to `null` if `enabled` is `false`.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ServiceDependencyDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependentServices":
            suggest = "dependent_services"
        elif key == "supportingServices":
            suggest = "supporting_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceDependencyDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceDependencyDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceDependencyDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependent_services: Sequence['outputs.ServiceDependencyDependencyDependentService'],
                 supporting_services: Sequence['outputs.ServiceDependencyDependencySupportingService'],
                 type: Optional[str] = None):
        """
        :param Sequence['ServiceDependencyDependencyDependentServiceArgs'] dependent_services: The service that dependents on the supporting service. Dependency dependent service documented below.
        :param Sequence['ServiceDependencyDependencySupportingServiceArgs'] supporting_services: The service that supports the dependent service. Dependency supporting service documented below.
        :param str type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "dependent_services", dependent_services)
        pulumi.set(__self__, "supporting_services", supporting_services)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dependentServices")
    def dependent_services(self) -> Sequence['outputs.ServiceDependencyDependencyDependentService']:
        """
        The service that dependents on the supporting service. Dependency dependent service documented below.
        """
        return pulumi.get(self, "dependent_services")

    @property
    @pulumi.getter(name="supportingServices")
    def supporting_services(self) -> Sequence['outputs.ServiceDependencyDependencySupportingService']:
        """
        The service that supports the dependent service. Dependency supporting service documented below.
        """
        return pulumi.get(self, "supporting_services")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceDependencyDependencyDependentService(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The ID of the service dependency.
        :param str type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceDependencyDependencySupportingService(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The ID of the service dependency.
        :param str type: Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `business_service`,  `service`, `business_service_reference` or `technical_service_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceEventRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventActions":
            suggest = "event_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotates: Optional[Sequence['outputs.ServiceEventRuleActionsAnnotate']] = None,
                 event_actions: Optional[Sequence['outputs.ServiceEventRuleActionsEventAction']] = None,
                 extractions: Optional[Sequence['outputs.ServiceEventRuleActionsExtraction']] = None,
                 priorities: Optional[Sequence['outputs.ServiceEventRuleActionsPriority']] = None,
                 severities: Optional[Sequence['outputs.ServiceEventRuleActionsSeverity']] = None,
                 suppresses: Optional[Sequence['outputs.ServiceEventRuleActionsSuppress']] = None,
                 suspends: Optional[Sequence['outputs.ServiceEventRuleActionsSuspend']] = None):
        """
        :param Sequence['ServiceEventRuleActionsAnnotateArgs'] annotates: Note added to the event.
        :param Sequence['ServiceEventRuleActionsEventActionArgs'] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param Sequence['ServiceEventRuleActionsExtractionArgs'] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param Sequence['ServiceEventRuleActionsPriorityArgs'] priorities: The ID of the priority applied to the event.
        :param Sequence['ServiceEventRuleActionsSeverityArgs'] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        :param Sequence['ServiceEventRuleActionsSuppressArgs'] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        :param Sequence['ServiceEventRuleActionsSuspendArgs'] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)
        if suspends is not None:
            pulumi.set(__self__, "suspends", suspends)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsAnnotate']]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsEventAction']]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsExtraction']]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsPriority']]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @property
    @pulumi.getter
    def severities(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSeverity']]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSuppress']]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        return pulumi.get(self, "suppresses")

    @property
    @pulumi.getter
    def suspends(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSuspend']]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        return pulumi.get(self, "suspends")


@pulumi.output_type
class ServiceEventRuleActionsAnnotate(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsEventAction(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 target: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
        :param str source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param str target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param str template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class ServiceEventRuleActionsPriority(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSeverity(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSuppress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdTimeAmount":
            suggest = "threshold_time_amount"
        elif key == "thresholdTimeUnit":
            suggest = "threshold_time_unit"
        elif key == "thresholdValue":
            suggest = "threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleActionsSuppress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleActionsSuppress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleActionsSuppress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_time_amount: Optional[int] = None,
                 threshold_time_unit: Optional[str] = None,
                 threshold_value: Optional[int] = None,
                 value: Optional[bool] = None):
        """
        :param int threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created.
        :param str threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param int threshold_value: The number of alerts that should be suppressed.
        :param bool value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[int]:
        """
        The number value of the `threshold_time_unit` before an incident is created.
        """
        return pulumi.get(self, "threshold_time_amount")

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[str]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[int]:
        """
        The number of alerts that should be suppressed.
        """
        return pulumi.get(self, "threshold_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSuspend(dict):
    def __init__(__self__, *,
                 value: Optional[int] = None):
        """
        :param int value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleConditions(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 subconditions: Optional[Sequence['outputs.ServiceEventRuleConditionsSubcondition']] = None):
        """
        :param str operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param Sequence['ServiceEventRuleConditionsSubconditionArgs'] subconditions: List of sub-conditions that define the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[Sequence['outputs.ServiceEventRuleConditionsSubcondition']]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")


@pulumi.output_type
class ServiceEventRuleConditionsSubcondition(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.ServiceEventRuleConditionsSubconditionParameter']] = None):
        """
        :param str operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param Sequence['ServiceEventRuleConditionsSubconditionParameterArgs'] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.ServiceEventRuleConditionsSubconditionParameter']]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class ServiceEventRuleConditionsSubconditionParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleTimeFrame(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeBetweens":
            suggest = "active_betweens"
        elif key == "scheduledWeeklies":
            suggest = "scheduled_weeklies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrame. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrame.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrame.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_betweens: Optional[Sequence['outputs.ServiceEventRuleTimeFrameActiveBetween']] = None,
                 scheduled_weeklies: Optional[Sequence['outputs.ServiceEventRuleTimeFrameScheduledWeekly']] = None):
        """
        :param Sequence['ServiceEventRuleTimeFrameActiveBetweenArgs'] active_betweens: Values for executing the rule during a specific time period.
        :param Sequence['ServiceEventRuleTimeFrameScheduledWeeklyArgs'] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[Sequence['outputs.ServiceEventRuleTimeFrameActiveBetween']]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[Sequence['outputs.ServiceEventRuleTimeFrameScheduledWeekly']]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")


@pulumi.output_type
class ServiceEventRuleTimeFrameActiveBetween(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrameActiveBetween. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrameActiveBetween.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrameActiveBetween.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[int] = None,
                 start_time: Optional[int] = None):
        """
        :param int end_time: Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        :param int start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[int]:
        """
        Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ServiceEventRuleTimeFrameScheduledWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrameScheduledWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[int] = None,
                 start_time: Optional[int] = None,
                 timezone: Optional[str] = None,
                 weekdays: Optional[Sequence[int]] = None):
        """
        :param int duration: Length of time the schedule will be active.  Unix timestamp in milliseconds.
        :param int start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        :param str timezone: Timezone for the given schedule.
        :param Sequence[int] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        Length of time the schedule will be active.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Timezone for the given schedule.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[int]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class ServiceEventRuleVariable(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.ServiceEventRuleVariableParameter']] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param Sequence['ServiceEventRuleVariableParameterArgs'] parameters: The parameters for performing the operation to populate the variable.
        :param str type: Type of operation to populate the variable. Usually `regex`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.ServiceEventRuleVariableParameter']]:
        """
        The parameters for performing the operation to populate the variable.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of operation to populate the variable. Usually `regex`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceEventRuleVariableParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceIncidentUrgencyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "duringSupportHours":
            suggest = "during_support_hours"
        elif key == "outsideSupportHours":
            suggest = "outside_support_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIncidentUrgencyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIncidentUrgencyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIncidentUrgencyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 during_support_hours: Optional['outputs.ServiceIncidentUrgencyRuleDuringSupportHours'] = None,
                 outside_support_hours: Optional['outputs.ServiceIncidentUrgencyRuleOutsideSupportHours'] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param 'ServiceIncidentUrgencyRuleDuringSupportHoursArgs' during_support_hours: Incidents' urgency during support hours.
        :param 'ServiceIncidentUrgencyRuleOutsideSupportHoursArgs' outside_support_hours: Incidents' urgency outside support hours.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        pulumi.set(__self__, "type", type)
        if during_support_hours is not None:
            pulumi.set(__self__, "during_support_hours", during_support_hours)
        if outside_support_hours is not None:
            pulumi.set(__self__, "outside_support_hours", outside_support_hours)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="duringSupportHours")
    def during_support_hours(self) -> Optional['outputs.ServiceIncidentUrgencyRuleDuringSupportHours']:
        """
        Incidents' urgency during support hours.
        """
        return pulumi.get(self, "during_support_hours")

    @property
    @pulumi.getter(name="outsideSupportHours")
    def outside_support_hours(self) -> Optional['outputs.ServiceIncidentUrgencyRuleOutsideSupportHours']:
        """
        Incidents' urgency outside support hours.
        """
        return pulumi.get(self, "outside_support_hours")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceIncidentUrgencyRuleDuringSupportHours(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceIncidentUrgencyRuleOutsideSupportHours(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceIntegrationEmailFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bodyMode":
            suggest = "body_mode"
        elif key == "bodyRegex":
            suggest = "body_regex"
        elif key == "fromEmailMode":
            suggest = "from_email_mode"
        elif key == "fromEmailRegex":
            suggest = "from_email_regex"
        elif key == "subjectMode":
            suggest = "subject_mode"
        elif key == "subjectRegex":
            suggest = "subject_regex"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEmailFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEmailFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEmailFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 body_mode: Optional[str] = None,
                 body_regex: Optional[str] = None,
                 from_email_mode: Optional[str] = None,
                 from_email_regex: Optional[str] = None,
                 id: Optional[str] = None,
                 subject_mode: Optional[str] = None,
                 subject_regex: Optional[str] = None):
        """
        :param str body_mode: Can be `always` or `match`.
        :param str body_regex: Should be a valid regex or `null`
        :param str from_email_mode: Can be `always` or `match`.
        :param str from_email_regex: Should be a valid regex or `null`
        :param str id: The ID of the service integration.
        :param str subject_mode: Can be `always` or `match`.
        :param str subject_regex: Should be a valid regex or `null`
        """
        if body_mode is not None:
            pulumi.set(__self__, "body_mode", body_mode)
        if body_regex is not None:
            pulumi.set(__self__, "body_regex", body_regex)
        if from_email_mode is not None:
            pulumi.set(__self__, "from_email_mode", from_email_mode)
        if from_email_regex is not None:
            pulumi.set(__self__, "from_email_regex", from_email_regex)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if subject_mode is not None:
            pulumi.set(__self__, "subject_mode", subject_mode)
        if subject_regex is not None:
            pulumi.set(__self__, "subject_regex", subject_regex)

    @property
    @pulumi.getter(name="bodyMode")
    def body_mode(self) -> Optional[str]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "body_mode")

    @property
    @pulumi.getter(name="bodyRegex")
    def body_regex(self) -> Optional[str]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "body_regex")

    @property
    @pulumi.getter(name="fromEmailMode")
    def from_email_mode(self) -> Optional[str]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "from_email_mode")

    @property
    @pulumi.getter(name="fromEmailRegex")
    def from_email_regex(self) -> Optional[str]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "from_email_regex")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the service integration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="subjectMode")
    def subject_mode(self) -> Optional[str]:
        """
        Can be `always` or `match`.
        """
        return pulumi.get(self, "subject_mode")

    @property
    @pulumi.getter(name="subjectRegex")
    def subject_regex(self) -> Optional[str]:
        """
        Should be a valid regex or `null`
        """
        return pulumi.get(self, "subject_regex")


@pulumi.output_type
class ServiceIntegrationEmailParser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchPredicate":
            suggest = "match_predicate"
        elif key == "valueExtractors":
            suggest = "value_extractors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEmailParser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEmailParser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEmailParser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: str,
                 match_predicate: 'outputs.ServiceIntegrationEmailParserMatchPredicate',
                 id: Optional[int] = None,
                 value_extractors: Optional[Sequence['outputs.ServiceIntegrationEmailParserValueExtractor']] = None):
        """
        :param str action: Can be `resolve` or `trigger`.
        :param int id: The ID of the service integration.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "match_predicate", match_predicate)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if value_extractors is not None:
            pulumi.set(__self__, "value_extractors", value_extractors)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Can be `resolve` or `trigger`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="matchPredicate")
    def match_predicate(self) -> 'outputs.ServiceIntegrationEmailParserMatchPredicate':
        return pulumi.get(self, "match_predicate")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        The ID of the service integration.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="valueExtractors")
    def value_extractors(self) -> Optional[Sequence['outputs.ServiceIntegrationEmailParserValueExtractor']]:
        return pulumi.get(self, "value_extractors")


@pulumi.output_type
class ServiceIntegrationEmailParserMatchPredicate(dict):
    def __init__(__self__, *,
                 type: str,
                 predicates: Optional[Sequence['outputs.ServiceIntegrationEmailParserMatchPredicatePredicate']] = None):
        """
        :param str type: Can be `any` or `all`.
        """
        pulumi.set(__self__, "type", type)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `any` or `all`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def predicates(self) -> Optional[Sequence['outputs.ServiceIntegrationEmailParserMatchPredicatePredicate']]:
        return pulumi.get(self, "predicates")


@pulumi.output_type
class ServiceIntegrationEmailParserMatchPredicatePredicate(dict):
    def __init__(__self__, *,
                 type: str,
                 matcher: Optional[str] = None,
                 part: Optional[str] = None,
                 predicates: Optional[Sequence['outputs.ServiceIntegrationEmailParserMatchPredicatePredicatePredicate']] = None):
        """
        :param str type: Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        :param str matcher: Predicate value or valid regex.
        :param str part: Can be `subject`, `body` or `from_addresses`.
        """
        pulumi.set(__self__, "type", type)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)
        if part is not None:
            pulumi.set(__self__, "part", part)
        if predicates is not None:
            pulumi.set(__self__, "predicates", predicates)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def matcher(self) -> Optional[str]:
        """
        Predicate value or valid regex.
        """
        return pulumi.get(self, "matcher")

    @property
    @pulumi.getter
    def part(self) -> Optional[str]:
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        return pulumi.get(self, "part")

    @property
    @pulumi.getter
    def predicates(self) -> Optional[Sequence['outputs.ServiceIntegrationEmailParserMatchPredicatePredicatePredicate']]:
        return pulumi.get(self, "predicates")


@pulumi.output_type
class ServiceIntegrationEmailParserMatchPredicatePredicatePredicate(dict):
    def __init__(__self__, *,
                 matcher: str,
                 part: str,
                 type: str):
        """
        :param str matcher: Predicate value or valid regex.
        :param str part: Can be `subject`, `body` or `from_addresses`.
        :param str type: Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        pulumi.set(__self__, "matcher", matcher)
        pulumi.set(__self__, "part", part)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def matcher(self) -> str:
        """
        Predicate value or valid regex.
        """
        return pulumi.get(self, "matcher")

    @property
    @pulumi.getter
    def part(self) -> str:
        """
        Can be `subject`, `body` or `from_addresses`.
        """
        return pulumi.get(self, "part")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `contains`, `exactly`, `regex` or `not`. If type is `not` predicate should contain child predicate with all parameters.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceIntegrationEmailParserValueExtractor(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "valueName":
            suggest = "value_name"
        elif key == "endsBefore":
            suggest = "ends_before"
        elif key == "startsAfter":
            suggest = "starts_after"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIntegrationEmailParserValueExtractor. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIntegrationEmailParserValueExtractor.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIntegrationEmailParserValueExtractor.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 part: str,
                 type: str,
                 value_name: str,
                 ends_before: Optional[str] = None,
                 regex: Optional[str] = None,
                 starts_after: Optional[str] = None):
        """
        :param str part: Can be `subject` or `body`.
        :param str type: Can be `between`, `entire` or `regex`.
        :param str value_name: First value extractor should have name `incident_key` other value extractors should contain custom names.
        :param str regex: If `type` has value `regex` this value should contain valid regex.
        """
        pulumi.set(__self__, "part", part)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value_name", value_name)
        if ends_before is not None:
            pulumi.set(__self__, "ends_before", ends_before)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if starts_after is not None:
            pulumi.set(__self__, "starts_after", starts_after)

    @property
    @pulumi.getter
    def part(self) -> str:
        """
        Can be `subject` or `body`.
        """
        return pulumi.get(self, "part")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `between`, `entire` or `regex`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="valueName")
    def value_name(self) -> str:
        """
        First value extractor should have name `incident_key` other value extractors should contain custom names.
        """
        return pulumi.get(self, "value_name")

    @property
    @pulumi.getter(name="endsBefore")
    def ends_before(self) -> Optional[str]:
        return pulumi.get(self, "ends_before")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        If `type` has value `regex` this value should contain valid regex.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter(name="startsAfter")
    def starts_after(self) -> Optional[str]:
        return pulumi.get(self, "starts_after")


@pulumi.output_type
class ServiceScheduledAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toUrgency":
            suggest = "to_urgency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceScheduledAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceScheduledAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceScheduledAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[Sequence['outputs.ServiceScheduledActionAt']] = None,
                 to_urgency: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['ServiceScheduledActionAtArgs'] ats: A block representing when the scheduled action will occur.
        :param str to_urgency: The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if to_urgency is not None:
            pulumi.set(__self__, "to_urgency", to_urgency)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ats(self) -> Optional[Sequence['outputs.ServiceScheduledActionAt']]:
        """
        A block representing when the scheduled action will occur.
        """
        return pulumi.get(self, "ats")

    @property
    @pulumi.getter(name="toUrgency")
    def to_urgency(self) -> Optional[str]:
        """
        The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        """
        return pulumi.get(self, "to_urgency")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceScheduledActionAt(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
        :param str type: The type of time specification. Currently, this must be set to `named_time`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of time specification. Currently, this must be set to `named_time`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceSupportHours(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceSupportHours. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceSupportHours.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceSupportHours.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence[int]] = None,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None,
                 time_zone: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence[int] days_of_weeks: Array of days of week as integers. `1` to `7`, `1` being
               Monday and `7` being Sunday.
        :param str end_time: The support hours' ending time of day.
        :param str start_time: The support hours' starting time of day.
        :param str time_zone: The time zone for the support hours.
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[int]]:
        """
        Array of days of week as integers. `1` to `7`, `1` being
        Monday and `7` being Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        The support hours' ending time of day.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        The support hours' starting time of day.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone for the support hours.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SlackConnectionConfig(dict):
    def __init__(__self__, *,
                 events: Sequence[str],
                 priorities: Optional[Sequence[str]] = None,
                 urgency: Optional[str] = None):
        """
        :param Sequence[str] events: A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
               - `incident.acknowledged`
               - `incident.escalated`
               - `incident.resolved`
               - `incident.reassigned`
               - `incident.annotated`
               - `incident.unacknowledged`
               - `incident.delegated`
               - `incident.priority_updated`
               - `incident.responder.added`
               - `incident.responder.replied`
               - `incident.status_update_published`
               - `incident.reopened`
        :param str urgency: Allows you to filter events by urgency. Either `high` or `low`.
        """
        pulumi.set(__self__, "events", events)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def events(self) -> Sequence[str]:
        """
        A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
        - `incident.acknowledged`
        - `incident.escalated`
        - `incident.resolved`
        - `incident.reassigned`
        - `incident.annotated`
        - `incident.unacknowledged`
        - `incident.delegated`
        - `incident.priority_updated`
        - `incident.responder.added`
        - `incident.responder.replied`
        - `incident.status_update_published`
        - `incident.reopened`
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "priorities")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        Allows you to filter events by urgency. Either `high` or `low`.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class WebhookSubscriptionDeliveryMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customHeaders":
            suggest = "custom_headers"
        elif key == "temporarilyDisabled":
            suggest = "temporarily_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookSubscriptionDeliveryMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookSubscriptionDeliveryMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookSubscriptionDeliveryMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_headers: Optional[Sequence['outputs.WebhookSubscriptionDeliveryMethodCustomHeader']] = None,
                 temporarily_disabled: Optional[bool] = None,
                 type: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param Sequence['WebhookSubscriptionDeliveryMethodCustomHeaderArgs'] custom_headers: The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        :param bool temporarily_disabled: Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        :param str type: Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        :param str url: The destination URL for webhook delivery.
        """
        if custom_headers is not None:
            pulumi.set(__self__, "custom_headers", custom_headers)
        if temporarily_disabled is not None:
            pulumi.set(__self__, "temporarily_disabled", temporarily_disabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="customHeaders")
    def custom_headers(self) -> Optional[Sequence['outputs.WebhookSubscriptionDeliveryMethodCustomHeader']]:
        """
        The custom_header of a webhook subscription define any optional headers that will be passed along with the payload to the destination URL.
        """
        return pulumi.get(self, "custom_headers")

    @property
    @pulumi.getter(name="temporarilyDisabled")
    def temporarily_disabled(self) -> Optional[bool]:
        """
        Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        """
        return pulumi.get(self, "temporarily_disabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The destination URL for webhook delivery.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WebhookSubscriptionDeliveryMethodCustomHeader(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class WebhookSubscriptionFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str type: The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        :param str id: The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAutomationActionsActionActionDataReferenceResult(dict):
    def __init__(__self__, *,
                 invocation_command: str,
                 process_automation_job_arguments: str,
                 process_automation_job_id: str,
                 script: str):
        """
        :param str invocation_command: (Optional) The command to execute the script with.
        :param str process_automation_job_arguments: (Optional) The arguments to pass to the Process Automation job execution.
        :param str process_automation_job_id: (Required for `process_automation` action_type) The ID of the Process Automation job to execute.
        :param str script: (Required for `script` action_type) Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        pulumi.set(__self__, "invocation_command", invocation_command)
        pulumi.set(__self__, "process_automation_job_arguments", process_automation_job_arguments)
        pulumi.set(__self__, "process_automation_job_id", process_automation_job_id)
        pulumi.set(__self__, "script", script)

    @property
    @pulumi.getter(name="invocationCommand")
    def invocation_command(self) -> str:
        """
        (Optional) The command to execute the script with.
        """
        return pulumi.get(self, "invocation_command")

    @property
    @pulumi.getter(name="processAutomationJobArguments")
    def process_automation_job_arguments(self) -> str:
        """
        (Optional) The arguments to pass to the Process Automation job execution.
        """
        return pulumi.get(self, "process_automation_job_arguments")

    @property
    @pulumi.getter(name="processAutomationJobId")
    def process_automation_job_id(self) -> str:
        """
        (Required for `process_automation` action_type) The ID of the Process Automation job to execute.
        """
        return pulumi.get(self, "process_automation_job_id")

    @property
    @pulumi.getter
    def script(self) -> str:
        """
        (Required for `script` action_type) Body of the script to be executed on the Runner. Max length is 16777215 characters.
        """
        return pulumi.get(self, "script")


@pulumi.output_type
class GetEventOrchestrationIntegrationResult(dict):
    def __init__(__self__, *,
                 id: str,
                 parameters: Sequence['outputs.GetEventOrchestrationIntegrationParameterResult']):
        """
        :param str id: ID of the integration
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.GetEventOrchestrationIntegrationParameterResult']:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetEventOrchestrationIntegrationParameterResult(dict):
    def __init__(__self__, *,
                 routing_key: str,
                 type: str):
        """
        :param str routing_key: Routing key that routes to this Orchestration.
        :param str type: Type of the routing key. `global` is the default type.
        """
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetEventOrchestrationsEventOrchestrationResult(dict):
    def __init__(__self__, *,
                 id: str,
                 integrations: Sequence['outputs.GetEventOrchestrationsEventOrchestrationIntegrationResult'],
                 name: str):
        """
        :param str id: ID of the integration
        :param Sequence['GetEventOrchestrationsEventOrchestrationIntegrationArgs'] integrations: An integration for the Event Orchestration.
        :param str name: The name of the found Event Orchestration.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "integrations", integrations)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def integrations(self) -> Sequence['outputs.GetEventOrchestrationsEventOrchestrationIntegrationResult']:
        """
        An integration for the Event Orchestration.
        """
        return pulumi.get(self, "integrations")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the found Event Orchestration.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetEventOrchestrationsEventOrchestrationIntegrationResult(dict):
    def __init__(__self__, *,
                 id: str,
                 parameters: Sequence['outputs.GetEventOrchestrationsEventOrchestrationIntegrationParameterResult']):
        """
        :param str id: ID of the integration
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        ID of the integration
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.GetEventOrchestrationsEventOrchestrationIntegrationParameterResult']:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class GetEventOrchestrationsEventOrchestrationIntegrationParameterResult(dict):
    def __init__(__self__, *,
                 routing_key: str,
                 type: str):
        """
        :param str routing_key: Routing key that routes to this Orchestration.
        :param str type: Type of the routing key. `global` is the default type.
        """
        pulumi.set(__self__, "routing_key", routing_key)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="routingKey")
    def routing_key(self) -> str:
        """
        Routing key that routes to this Orchestration.
        """
        return pulumi.get(self, "routing_key")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of the routing key. `global` is the default type.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetUsersUserResult(dict):
    def __init__(__self__, *,
                 email: str,
                 id: str,
                 name: str):
        """
        :param str email: The email to use to find a user in the PagerDuty API.
        :param str id: The ID of the found user.
        :param str name: The short name of the found user.
        """
        pulumi.set(__self__, "email", email)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def email(self) -> str:
        """
        The email to use to find a user in the PagerDuty API.
        """
        return pulumi.get(self, "email")

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the found user.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The short name of the found user.
        """
        return pulumi.get(self, "name")


