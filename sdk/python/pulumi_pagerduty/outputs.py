# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'EscalationPolicyRule',
    'EscalationPolicyRuleTarget',
    'ResponsePlayResponder',
    'ResponsePlayResponderEscalationRule',
    'ResponsePlayResponderEscalationRuleTarget',
    'ResponsePlayResponderService',
    'ResponsePlayResponderTeam',
    'ResponsePlaySubscriber',
    'RulesetRuleActions',
    'RulesetRuleActionsAnnotate',
    'RulesetRuleActionsEventAction',
    'RulesetRuleActionsExtraction',
    'RulesetRuleActionsPriority',
    'RulesetRuleActionsRoute',
    'RulesetRuleActionsSeverity',
    'RulesetRuleActionsSuppress',
    'RulesetRuleActionsSuspend',
    'RulesetRuleConditions',
    'RulesetRuleConditionsSubcondition',
    'RulesetRuleConditionsSubconditionParameter',
    'RulesetRuleTimeFrame',
    'RulesetRuleTimeFrameActiveBetween',
    'RulesetRuleTimeFrameScheduledWeekly',
    'RulesetRuleVariable',
    'RulesetRuleVariableParameter',
    'RulesetTeam',
    'ScheduleLayer',
    'ScheduleLayerRestriction',
    'ServiceAlertGroupingParameters',
    'ServiceAlertGroupingParametersConfig',
    'ServiceDependencyDependency',
    'ServiceDependencyDependencyDependentService',
    'ServiceDependencyDependencySupportingService',
    'ServiceEventRuleActions',
    'ServiceEventRuleActionsAnnotate',
    'ServiceEventRuleActionsEventAction',
    'ServiceEventRuleActionsExtraction',
    'ServiceEventRuleActionsPriority',
    'ServiceEventRuleActionsSeverity',
    'ServiceEventRuleActionsSuppress',
    'ServiceEventRuleActionsSuspend',
    'ServiceEventRuleConditions',
    'ServiceEventRuleConditionsSubcondition',
    'ServiceEventRuleConditionsSubconditionParameter',
    'ServiceEventRuleTimeFrame',
    'ServiceEventRuleTimeFrameActiveBetween',
    'ServiceEventRuleTimeFrameScheduledWeekly',
    'ServiceEventRuleVariable',
    'ServiceEventRuleVariableParameter',
    'ServiceIncidentUrgencyRule',
    'ServiceIncidentUrgencyRuleDuringSupportHours',
    'ServiceIncidentUrgencyRuleOutsideSupportHours',
    'ServiceScheduledAction',
    'ServiceScheduledActionAt',
    'ServiceSupportHours',
    'SlackConnectionConfig',
    'WebhookSubscriptionDeliveryMethod',
    'WebhookSubscriptionFilter',
]

@pulumi.output_type
class EscalationPolicyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationDelayInMinutes":
            suggest = "escalation_delay_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EscalationPolicyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EscalationPolicyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EscalationPolicyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 escalation_delay_in_minutes: int,
                 targets: Sequence['outputs.EscalationPolicyRuleTarget'],
                 id: Optional[str] = None):
        """
        :param int escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param str id: A target ID
        """
        pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        pulumi.set(__self__, "targets", targets)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> int:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.EscalationPolicyRuleTarget']:
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A target ID
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class EscalationPolicyRuleTarget(dict):
    def __init__(__self__, *,
                 id: str,
                 type: Optional[str] = None):
        """
        :param str id: A target ID
        :param str type: Can be `user`, `schedule`, `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Can be `user`, `schedule`, `user_reference` or `schedule_reference`. Defaults to `user_reference`. For multiple users as example, repeat the target.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponder(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationRules":
            suggest = "escalation_rules"
        elif key == "numLoops":
            suggest = "num_loops"
        elif key == "onCallHandoffNotifications":
            suggest = "on_call_handoff_notifications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponsePlayResponder. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponsePlayResponder.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponsePlayResponder.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 escalation_rules: Optional[Sequence['outputs.ResponsePlayResponderEscalationRule']] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 num_loops: Optional[int] = None,
                 on_call_handoff_notifications: Optional[str] = None,
                 services: Optional[Sequence['outputs.ResponsePlayResponderService']] = None,
                 teams: Optional[Sequence['outputs.ResponsePlayResponderTeam']] = None,
                 type: Optional[str] = None):
        """
        :param str description: Description of escalation policy
        :param Sequence['ResponsePlayResponderEscalationRuleArgs'] escalation_rules: The escalation rules
        :param str id: ID of the user defined as the responder
        :param str name: Name of the escalation policy
        :param int num_loops: The number of times the escalation policy will repeat after reaching the end of its escalation.
        :param str on_call_handoff_notifications: Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        :param Sequence['ResponsePlayResponderServiceArgs'] services: There can be multiple services associated with a policy.
        :param Sequence['ResponsePlayResponderTeamArgs'] teams: Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        :param str type: Type of object of the target. Supported types are `user`, `schedule`, `user_reference`, `schedule_reference`.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if escalation_rules is not None:
            pulumi.set(__self__, "escalation_rules", escalation_rules)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if num_loops is not None:
            pulumi.set(__self__, "num_loops", num_loops)
        if on_call_handoff_notifications is not None:
            pulumi.set(__self__, "on_call_handoff_notifications", on_call_handoff_notifications)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if teams is not None:
            pulumi.set(__self__, "teams", teams)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of escalation policy
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="escalationRules")
    def escalation_rules(self) -> Optional[Sequence['outputs.ResponsePlayResponderEscalationRule']]:
        """
        The escalation rules
        """
        return pulumi.get(self, "escalation_rules")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the escalation policy
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="numLoops")
    def num_loops(self) -> Optional[int]:
        """
        The number of times the escalation policy will repeat after reaching the end of its escalation.
        """
        return pulumi.get(self, "num_loops")

    @property
    @pulumi.getter(name="onCallHandoffNotifications")
    def on_call_handoff_notifications(self) -> Optional[str]:
        """
        Determines how on call handoff notifications will be sent for users on the escalation policy. Defaults to "if_has_services". Could be "if_has_services", "always
        """
        return pulumi.get(self, "on_call_handoff_notifications")

    @property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.ResponsePlayResponderService']]:
        """
        There can be multiple services associated with a policy.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter
    def teams(self) -> Optional[Sequence['outputs.ResponsePlayResponderTeam']]:
        """
        Teams associated with the policy. Account must have the `teams` ability to use this parameter. There can be multiple teams associated with a policy.
        """
        return pulumi.get(self, "teams")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of object of the target. Supported types are `user`, `schedule`, `user_reference`, `schedule_reference`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderEscalationRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "escalationDelayInMinutes":
            suggest = "escalation_delay_in_minutes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ResponsePlayResponderEscalationRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ResponsePlayResponderEscalationRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ResponsePlayResponderEscalationRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 targets: Sequence['outputs.ResponsePlayResponderEscalationRuleTarget'],
                 escalation_delay_in_minutes: Optional[int] = None,
                 id: Optional[str] = None):
        """
        :param Sequence['ResponsePlayResponderEscalationRuleTargetArgs'] targets: The targets an incident should be assigned to upon reaching this rule.
        :param int escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param str id: ID of the user defined as the responder
        """
        pulumi.set(__self__, "targets", targets)
        if escalation_delay_in_minutes is not None:
            pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.ResponsePlayResponderEscalationRuleTarget']:
        """
        The targets an incident should be assigned to upon reaching this rule.
        """
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> Optional[int]:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ResponsePlayResponderEscalationRuleTarget(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: ID of the user defined as the responder
        :param str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderService(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: ID of the user defined as the responder
        :param str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ResponsePlayResponderTeam(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        :param str id: ID of the user defined as the responder
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ResponsePlaySubscriber(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str id: ID of the user defined as the responder
        :param str type: A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        ID of the user defined as the responder
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        A string that determines the schema of the object. If not set, the default value is "response_play".
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RulesetRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventActions":
            suggest = "event_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotates: Optional[Sequence['outputs.RulesetRuleActionsAnnotate']] = None,
                 event_actions: Optional[Sequence['outputs.RulesetRuleActionsEventAction']] = None,
                 extractions: Optional[Sequence['outputs.RulesetRuleActionsExtraction']] = None,
                 priorities: Optional[Sequence['outputs.RulesetRuleActionsPriority']] = None,
                 routes: Optional[Sequence['outputs.RulesetRuleActionsRoute']] = None,
                 severities: Optional[Sequence['outputs.RulesetRuleActionsSeverity']] = None,
                 suppresses: Optional[Sequence['outputs.RulesetRuleActionsSuppress']] = None,
                 suspends: Optional[Sequence['outputs.RulesetRuleActionsSuspend']] = None):
        """
        :param Sequence['RulesetRuleActionsAnnotateArgs'] annotates: Note added to the event.
        :param Sequence['RulesetRuleActionsEventActionArgs'] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param Sequence['RulesetRuleActionsExtractionArgs'] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param Sequence['RulesetRuleActionsPriorityArgs'] priorities: The ID of the priority applied to the event.
        :param Sequence['RulesetRuleActionsRouteArgs'] routes: The ID of the service where the event will be routed.
        :param Sequence['RulesetRuleActionsSeverityArgs'] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        :param Sequence['RulesetRuleActionsSuppressArgs'] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        :param Sequence['RulesetRuleActionsSuspendArgs'] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)
        if suspends is not None:
            pulumi.set(__self__, "suspends", suspends)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[Sequence['outputs.RulesetRuleActionsAnnotate']]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[Sequence['outputs.RulesetRuleActionsEventAction']]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.RulesetRuleActionsExtraction']]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence['outputs.RulesetRuleActionsPriority']]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.RulesetRuleActionsRoute']]:
        """
        The ID of the service where the event will be routed.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter
    def severities(self) -> Optional[Sequence['outputs.RulesetRuleActionsSeverity']]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`warning`,`error`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[Sequence['outputs.RulesetRuleActionsSuppress']]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident). Note: If a threshold is set, the rule must also have a `route` action.
        """
        return pulumi.get(self, "suppresses")

    @property
    @pulumi.getter
    def suspends(self) -> Optional[Sequence['outputs.RulesetRuleActionsSuspend']]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering. Note: A rule with a `suspend` action must also have a `route` action.
        """
        return pulumi.get(self, "suspends")


@pulumi.output_type
class RulesetRuleActionsAnnotate(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsEventAction(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 target: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
        :param str source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param str target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param str template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class RulesetRuleActionsPriority(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsRoute(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSeverity(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSuppress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdTimeAmount":
            suggest = "threshold_time_amount"
        elif key == "thresholdTimeUnit":
            suggest = "threshold_time_unit"
        elif key == "thresholdValue":
            suggest = "threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleActionsSuppress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleActionsSuppress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleActionsSuppress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_time_amount: Optional[int] = None,
                 threshold_time_unit: Optional[str] = None,
                 threshold_value: Optional[int] = None,
                 value: Optional[bool] = None):
        """
        :param int threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        :param str threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param int threshold_value: The number of alerts that should be suppressed. Must be greater than 0.
        :param bool value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[int]:
        """
        The number value of the `threshold_time_unit` before an incident is created. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_time_amount")

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[str]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[int]:
        """
        The number of alerts that should be suppressed. Must be greater than 0.
        """
        return pulumi.get(self, "threshold_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleActionsSuspend(dict):
    def __init__(__self__, *,
                 value: Optional[int] = None):
        """
        :param int value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleConditions(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 subconditions: Optional[Sequence['outputs.RulesetRuleConditionsSubcondition']] = None):
        """
        :param str operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param Sequence['RulesetRuleConditionsSubconditionArgs'] subconditions: List of sub-conditions that define the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[Sequence['outputs.RulesetRuleConditionsSubcondition']]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")


@pulumi.output_type
class RulesetRuleConditionsSubcondition(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.RulesetRuleConditionsSubconditionParameter']] = None):
        """
        :param str operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param Sequence['RulesetRuleConditionsSubconditionParameterArgs'] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.RulesetRuleConditionsSubconditionParameter']]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class RulesetRuleConditionsSubconditionParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetRuleTimeFrame(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeBetweens":
            suggest = "active_betweens"
        elif key == "scheduledWeeklies":
            suggest = "scheduled_weeklies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrame. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrame.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrame.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_betweens: Optional[Sequence['outputs.RulesetRuleTimeFrameActiveBetween']] = None,
                 scheduled_weeklies: Optional[Sequence['outputs.RulesetRuleTimeFrameScheduledWeekly']] = None):
        """
        :param Sequence['RulesetRuleTimeFrameActiveBetweenArgs'] active_betweens: Values for executing the rule during a specific time period.
        :param Sequence['RulesetRuleTimeFrameScheduledWeeklyArgs'] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[Sequence['outputs.RulesetRuleTimeFrameActiveBetween']]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[Sequence['outputs.RulesetRuleTimeFrameScheduledWeekly']]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")


@pulumi.output_type
class RulesetRuleTimeFrameActiveBetween(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrameActiveBetween. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrameActiveBetween.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrameActiveBetween.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[int] = None,
                 start_time: Optional[int] = None):
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[int]:
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        return pulumi.get(self, "start_time")


@pulumi.output_type
class RulesetRuleTimeFrameScheduledWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RulesetRuleTimeFrameScheduledWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RulesetRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RulesetRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[int] = None,
                 start_time: Optional[int] = None,
                 timezone: Optional[str] = None,
                 weekdays: Optional[Sequence[int]] = None):
        """
        :param int duration: Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        :param str timezone: [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        :param Sequence[int] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        Length of time the schedule will be active in milliseconds. For example `duration = 2 * 60 * 60 * 1000` if you want your rule to apply for 2 hours, from the specified `start_time`.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        [The name of the timezone](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) for the given schedule, which will be used to determine UTC offset including adjustment for daylight saving time. For example: `timezone = "America/Toronto"`
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[int]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class RulesetRuleVariable(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.RulesetRuleVariableParameter']] = None,
                 type: Optional[str] = None):
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.RulesetRuleVariableParameter']]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class RulesetRuleVariableParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class RulesetTeam(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the ruleset.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the ruleset.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ScheduleLayer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rotationTurnLengthSeconds":
            suggest = "rotation_turn_length_seconds"
        elif key == "rotationVirtualStart":
            suggest = "rotation_virtual_start"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleLayer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleLayer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleLayer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 rotation_turn_length_seconds: int,
                 rotation_virtual_start: str,
                 start: str,
                 users: Sequence[str],
                 end: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 restrictions: Optional[Sequence['outputs.ScheduleLayerRestriction']] = None):
        """
        :param int rotation_turn_length_seconds: The duration of each on-call shift in `seconds`.
        :param str rotation_virtual_start: The effective start time of the schedule layer. This can be before the start time of the schedule.
        :param str start: The start time of the schedule layer.
        :param Sequence[str] users: The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        :param str end: The end time of the schedule layer. If not specified, the layer does not end.
        :param str id: The ID of the schedule.
        :param str name: The name of the schedule layer.
        :param Sequence['ScheduleLayerRestrictionArgs'] restrictions: A schedule layer restriction block. Restriction blocks documented below.
        """
        pulumi.set(__self__, "rotation_turn_length_seconds", rotation_turn_length_seconds)
        pulumi.set(__self__, "rotation_virtual_start", rotation_virtual_start)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "users", users)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter(name="rotationTurnLengthSeconds")
    def rotation_turn_length_seconds(self) -> int:
        """
        The duration of each on-call shift in `seconds`.
        """
        return pulumi.get(self, "rotation_turn_length_seconds")

    @property
    @pulumi.getter(name="rotationVirtualStart")
    def rotation_virtual_start(self) -> str:
        """
        The effective start time of the schedule layer. This can be before the start time of the schedule.
        """
        return pulumi.get(self, "rotation_virtual_start")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        The start time of the schedule layer.
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter
    def users(self) -> Sequence[str]:
        """
        The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter
    def end(self) -> Optional[str]:
        """
        The end time of the schedule layer. If not specified, the layer does not end.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the schedule.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the schedule layer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.ScheduleLayerRestriction']]:
        """
        A schedule layer restriction block. Restriction blocks documented below.
        """
        return pulumi.get(self, "restrictions")


@pulumi.output_type
class ScheduleLayerRestriction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "durationSeconds":
            suggest = "duration_seconds"
        elif key == "startTimeOfDay":
            suggest = "start_time_of_day"
        elif key == "startDayOfWeek":
            suggest = "start_day_of_week"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScheduleLayerRestriction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScheduleLayerRestriction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScheduleLayerRestriction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration_seconds: int,
                 start_time_of_day: str,
                 type: str,
                 start_day_of_week: Optional[int] = None):
        """
        :param int duration_seconds: The duration of the restriction in `seconds`.
        :param str start_time_of_day: The start time in `HH:mm:ss` format.
        :param str type: Can be `daily_restriction` or `weekly_restriction`.
        :param int start_day_of_week: Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        pulumi.set(__self__, "duration_seconds", duration_seconds)
        pulumi.set(__self__, "start_time_of_day", start_time_of_day)
        pulumi.set(__self__, "type", type)
        if start_day_of_week is not None:
            pulumi.set(__self__, "start_day_of_week", start_day_of_week)

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> int:
        """
        The duration of the restriction in `seconds`.
        """
        return pulumi.get(self, "duration_seconds")

    @property
    @pulumi.getter(name="startTimeOfDay")
    def start_time_of_day(self) -> str:
        """
        The start time in `HH:mm:ss` format.
        """
        return pulumi.get(self, "start_time_of_day")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `daily_restriction` or `weekly_restriction`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[int]:
        """
        Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        return pulumi.get(self, "start_day_of_week")


@pulumi.output_type
class ServiceAlertGroupingParameters(dict):
    def __init__(__self__, *,
                 config: Optional['outputs.ServiceAlertGroupingParametersConfig'] = None,
                 type: Optional[str] = None):
        """
        :param 'ServiceAlertGroupingParametersConfigArgs' config: Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        :param str type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        if config is not None:
            pulumi.set(__self__, "config", config)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.ServiceAlertGroupingParametersConfig']:
        """
        Alert grouping parameters dependent on `type`. If `type` is set to `intelligent` or empty then `config` can be empty.
        """
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceAlertGroupingParametersConfig(dict):
    def __init__(__self__, *,
                 aggregate: Optional[str] = None,
                 fields: Optional[Sequence[str]] = None,
                 timeout: Optional[int] = None):
        """
        :param str aggregate: One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        :param Sequence[str] fields: Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        :param int timeout: The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        if aggregate is not None:
            pulumi.set(__self__, "aggregate", aggregate)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def aggregate(self) -> Optional[str]:
        """
        One of `any` or `all`. This setting applies only when `type` is set to `content_based`. Group alerts based on one or all of `fields` value(s).
        """
        return pulumi.get(self, "aggregate")

    @property
    @pulumi.getter
    def fields(self) -> Optional[Sequence[str]]:
        """
        Alerts will be grouped together if the content of these fields match. This setting applies only when `type` is set to `content_based`.
        """
        return pulumi.get(self, "fields")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[int]:
        """
        The duration in minutes within which to automatically group incoming alerts. This setting applies only when `type` is set to `time`. To continue grouping alerts until the incident is resolved, set this value to `0`.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class ServiceDependencyDependency(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dependentServices":
            suggest = "dependent_services"
        elif key == "supportingServices":
            suggest = "supporting_services"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceDependencyDependency. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceDependencyDependency.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceDependencyDependency.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dependent_services: Sequence['outputs.ServiceDependencyDependencyDependentService'],
                 supporting_services: Sequence['outputs.ServiceDependencyDependencySupportingService'],
                 type: Optional[str] = None):
        """
        :param Sequence['ServiceDependencyDependencyDependentServiceArgs'] dependent_services: The service that dependents on the supporting service.
        :param Sequence['ServiceDependencyDependencySupportingServiceArgs'] supporting_services: The service that supports the dependent service.
        """
        pulumi.set(__self__, "dependent_services", dependent_services)
        pulumi.set(__self__, "supporting_services", supporting_services)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dependentServices")
    def dependent_services(self) -> Sequence['outputs.ServiceDependencyDependencyDependentService']:
        """
        The service that dependents on the supporting service.
        """
        return pulumi.get(self, "dependent_services")

    @property
    @pulumi.getter(name="supportingServices")
    def supporting_services(self) -> Sequence['outputs.ServiceDependencyDependencySupportingService']:
        """
        The service that supports the dependent service.
        """
        return pulumi.get(self, "supporting_services")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceDependencyDependencyDependentService(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The ID of the service dependency.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceDependencyDependencySupportingService(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The ID of the service dependency.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceEventRuleActions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventActions":
            suggest = "event_actions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleActions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleActions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleActions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 annotates: Optional[Sequence['outputs.ServiceEventRuleActionsAnnotate']] = None,
                 event_actions: Optional[Sequence['outputs.ServiceEventRuleActionsEventAction']] = None,
                 extractions: Optional[Sequence['outputs.ServiceEventRuleActionsExtraction']] = None,
                 priorities: Optional[Sequence['outputs.ServiceEventRuleActionsPriority']] = None,
                 severities: Optional[Sequence['outputs.ServiceEventRuleActionsSeverity']] = None,
                 suppresses: Optional[Sequence['outputs.ServiceEventRuleActionsSuppress']] = None,
                 suspends: Optional[Sequence['outputs.ServiceEventRuleActionsSuspend']] = None):
        """
        :param Sequence['ServiceEventRuleActionsAnnotateArgs'] annotates: Note added to the event.
        :param Sequence['ServiceEventRuleActionsEventActionArgs'] event_actions: An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        :param Sequence['ServiceEventRuleActionsExtractionArgs'] extractions: Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        :param Sequence['ServiceEventRuleActionsPriorityArgs'] priorities: The ID of the priority applied to the event.
        :param Sequence['ServiceEventRuleActionsSeverityArgs'] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        :param Sequence['ServiceEventRuleActionsSuppressArgs'] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        :param Sequence['ServiceEventRuleActionsSuspendArgs'] suspends: An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)
        if suspends is not None:
            pulumi.set(__self__, "suspends", suspends)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsAnnotate']]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsEventAction']]:
        """
        An object with a single `value` field. The value sets whether the resulting alert status is `trigger` or `resolve`.
        """
        return pulumi.get(self, "event_actions")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsExtraction']]:
        """
        Allows you to copy important data from one event field to another. Extraction objects may use *either* of the following field structures:
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsPriority']]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @property
    @pulumi.getter
    def severities(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSeverity']]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSuppress']]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        return pulumi.get(self, "suppresses")

    @property
    @pulumi.getter
    def suspends(self) -> Optional[Sequence['outputs.ServiceEventRuleActionsSuspend']]:
        """
        An object with a single `value` field. The value sets the length of time to suspend the resulting alert before triggering.
        """
        return pulumi.get(self, "suspends")


@pulumi.output_type
class ServiceEventRuleActionsAnnotate(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsEventAction(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 target: Optional[str] = None,
                 template: Optional[str] = None):
        """
        :param str regex: The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
        :param str source: Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param str target: Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        :param str template: A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)
        if template is not None:
            pulumi.set(__self__, "template", template)

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The conditions that need to be met for the extraction to happen. Must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Field where the data is being copied from. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Field where the data is being copied to. Must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def template(self) -> Optional[str]:
        """
        A customized field message. This can also include variables extracted from the payload by using string interpolation.
        """
        return pulumi.get(self, "template")


@pulumi.output_type
class ServiceEventRuleActionsPriority(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSeverity(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSuppress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdTimeAmount":
            suggest = "threshold_time_amount"
        elif key == "thresholdTimeUnit":
            suggest = "threshold_time_unit"
        elif key == "thresholdValue":
            suggest = "threshold_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleActionsSuppress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleActionsSuppress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleActionsSuppress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold_time_amount: Optional[int] = None,
                 threshold_time_unit: Optional[str] = None,
                 threshold_value: Optional[int] = None,
                 value: Optional[bool] = None):
        """
        :param int threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created.
        :param str threshold_time_unit: The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        :param int threshold_value: The number of alerts that should be suppressed.
        :param bool value: The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[int]:
        """
        The number value of the `threshold_time_unit` before an incident is created.
        """
        return pulumi.get(self, "threshold_time_amount")

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[str]:
        """
        The `seconds`,`minutes`, or `hours` the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[int]:
        """
        The number of alerts that should be suppressed.
        """
        return pulumi.get(self, "threshold_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        """
        The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleActionsSuspend(dict):
    def __init__(__self__, *,
                 value: Optional[int] = None):
        """
        :param int value: The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleConditions(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 subconditions: Optional[Sequence['outputs.ServiceEventRuleConditionsSubcondition']] = None):
        """
        :param str operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param Sequence['ServiceEventRuleConditionsSubconditionArgs'] subconditions: List of sub-conditions that define the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[Sequence['outputs.ServiceEventRuleConditionsSubcondition']]:
        """
        List of sub-conditions that define the condition.
        """
        return pulumi.get(self, "subconditions")


@pulumi.output_type
class ServiceEventRuleConditionsSubcondition(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.ServiceEventRuleConditionsSubconditionParameter']] = None):
        """
        :param str operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param Sequence['ServiceEventRuleConditionsSubconditionParameterArgs'] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.ServiceEventRuleConditionsSubconditionParameter']]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set. The `path` value must be a [PagerDuty Common Event Format (PD-CEF)](https://support.pagerduty.com/docs/pd-cef) field.
        """
        return pulumi.get(self, "parameters")


@pulumi.output_type
class ServiceEventRuleConditionsSubconditionParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        :param str value: The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceEventRuleTimeFrame(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeBetweens":
            suggest = "active_betweens"
        elif key == "scheduledWeeklies":
            suggest = "scheduled_weeklies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrame. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrame.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrame.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_betweens: Optional[Sequence['outputs.ServiceEventRuleTimeFrameActiveBetween']] = None,
                 scheduled_weeklies: Optional[Sequence['outputs.ServiceEventRuleTimeFrameScheduledWeekly']] = None):
        """
        :param Sequence['ServiceEventRuleTimeFrameActiveBetweenArgs'] active_betweens: Values for executing the rule during a specific time period.
        :param Sequence['ServiceEventRuleTimeFrameScheduledWeeklyArgs'] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[Sequence['outputs.ServiceEventRuleTimeFrameActiveBetween']]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[Sequence['outputs.ServiceEventRuleTimeFrameScheduledWeekly']]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")


@pulumi.output_type
class ServiceEventRuleTimeFrameActiveBetween(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrameActiveBetween. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrameActiveBetween.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrameActiveBetween.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[int] = None,
                 start_time: Optional[int] = None):
        """
        :param int end_time: Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        :param int start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[int]:
        """
        Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ServiceEventRuleTimeFrameScheduledWeekly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEventRuleTimeFrameScheduledWeekly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEventRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEventRuleTimeFrameScheduledWeekly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[int] = None,
                 start_time: Optional[int] = None,
                 timezone: Optional[str] = None,
                 weekdays: Optional[Sequence[int]] = None):
        """
        :param int duration: Length of time the schedule will be active.  Unix timestamp in milliseconds.
        :param int start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        :param str timezone: Timezone for the given schedule.
        :param Sequence[int] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        Length of time the schedule will be active.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Timezone for the given schedule.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[int]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")


@pulumi.output_type
class ServiceEventRuleVariable(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.ServiceEventRuleVariableParameter']] = None,
                 type: Optional[str] = None):
        """
        :param str name: The name of the variable.
        :param Sequence['ServiceEventRuleVariableParameterArgs'] parameters: The parameters for performing the operation to populate the variable.
        :param str type: Type of operation to populate the variable. Usually `regex`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the variable.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.ServiceEventRuleVariableParameter']]:
        """
        The parameters for performing the operation to populate the variable.
        """
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of operation to populate the variable. Usually `regex`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceEventRuleVariableParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str path: Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        :param str value: The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        """
        Path to a field in an event, in dot-notation. For Event Rules on a Service, this will have to be a [PD-CEF field](https://support.pagerduty.com/docs/pd-cef).
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value for the operation. For example, an RE2 regular expression for regex-type variables.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ServiceIncidentUrgencyRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "duringSupportHours":
            suggest = "during_support_hours"
        elif key == "outsideSupportHours":
            suggest = "outside_support_hours"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceIncidentUrgencyRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceIncidentUrgencyRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceIncidentUrgencyRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 during_support_hours: Optional['outputs.ServiceIncidentUrgencyRuleDuringSupportHours'] = None,
                 outside_support_hours: Optional['outputs.ServiceIncidentUrgencyRuleOutsideSupportHours'] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param 'ServiceIncidentUrgencyRuleDuringSupportHoursArgs' during_support_hours: Incidents' urgency during support hours.
        :param 'ServiceIncidentUrgencyRuleOutsideSupportHoursArgs' outside_support_hours: Incidents' urgency outside support hours.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        pulumi.set(__self__, "type", type)
        if during_support_hours is not None:
            pulumi.set(__self__, "during_support_hours", during_support_hours)
        if outside_support_hours is not None:
            pulumi.set(__self__, "outside_support_hours", outside_support_hours)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="duringSupportHours")
    def during_support_hours(self) -> Optional['outputs.ServiceIncidentUrgencyRuleDuringSupportHours']:
        """
        Incidents' urgency during support hours.
        """
        return pulumi.get(self, "during_support_hours")

    @property
    @pulumi.getter(name="outsideSupportHours")
    def outside_support_hours(self) -> Optional['outputs.ServiceIncidentUrgencyRuleOutsideSupportHours']:
        """
        Incidents' urgency outside support hours.
        """
        return pulumi.get(self, "outside_support_hours")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceIncidentUrgencyRuleDuringSupportHours(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceIncidentUrgencyRuleOutsideSupportHours(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class ServiceScheduledAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toUrgency":
            suggest = "to_urgency"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceScheduledAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceScheduledAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceScheduledAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ats: Optional[Sequence['outputs.ServiceScheduledActionAt']] = None,
                 to_urgency: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['ServiceScheduledActionAtArgs'] ats: A block representing when the scheduled action will occur.
        :param str to_urgency: The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if to_urgency is not None:
            pulumi.set(__self__, "to_urgency", to_urgency)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ats(self) -> Optional[Sequence['outputs.ServiceScheduledActionAt']]:
        """
        A block representing when the scheduled action will occur.
        """
        return pulumi.get(self, "ats")

    @property
    @pulumi.getter(name="toUrgency")
    def to_urgency(self) -> Optional[str]:
        """
        The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        """
        return pulumi.get(self, "to_urgency")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceScheduledActionAt(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
        :param str type: The type of time specification. Currently, this must be set to `named_time`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of time specification. Currently, this must be set to `named_time`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ServiceSupportHours(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "daysOfWeeks":
            suggest = "days_of_weeks"
        elif key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceSupportHours. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceSupportHours.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceSupportHours.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence[int]] = None,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None,
                 time_zone: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence[int] days_of_weeks: Array of days of week as integers. `1` to `7`, `1` being
               Monday and `7` being Sunday.
        :param str end_time: The support hours' ending time of day.
        :param str start_time: The support hours' starting time of day.
        :param str time_zone: The time zone for the support hours.
        :param str type: The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[int]]:
        """
        Array of days of week as integers. `1` to `7`, `1` being
        Monday and `7` being Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        The support hours' ending time of day.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        The support hours' starting time of day.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone for the support hours.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of alert grouping; one of `intelligent`, `time` or `content_based`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SlackConnectionConfig(dict):
    def __init__(__self__, *,
                 events: Sequence[str],
                 priorities: Optional[Sequence[str]] = None,
                 urgency: Optional[str] = None):
        """
        :param Sequence[str] events: A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
               - `incident.acknowledged`
               - `incident.escalated`
               - `incident.resolved`
               - `incident.reassigned`
               - `incident.annotated`
               - `incident.unacknowledged`
               - `incident.delegated`
               - `incident.priority_updated`
               - `incident.responder.added`
               - `incident.responder.replied`
               - `incident.status_update_published`
               - `incident.reopened`
        :param str urgency: Allows you to filter events by urgency. Either `high` or `low`.
        """
        pulumi.set(__self__, "events", events)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def events(self) -> Sequence[str]:
        """
        A list of strings to filter events by PagerDuty event type. `"incident.triggered"` is required. The follow event types are also possible:
        - `incident.acknowledged`
        - `incident.escalated`
        - `incident.resolved`
        - `incident.reassigned`
        - `incident.annotated`
        - `incident.unacknowledged`
        - `incident.delegated`
        - `incident.priority_updated`
        - `incident.responder.added`
        - `incident.responder.replied`
        - `incident.status_update_published`
        - `incident.reopened`
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "priorities")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        Allows you to filter events by urgency. Either `high` or `low`.
        """
        return pulumi.get(self, "urgency")


@pulumi.output_type
class WebhookSubscriptionDeliveryMethod(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "temporarilyDisabled":
            suggest = "temporarily_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WebhookSubscriptionDeliveryMethod. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WebhookSubscriptionDeliveryMethod.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WebhookSubscriptionDeliveryMethod.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 temporarily_disabled: Optional[bool] = None,
                 type: Optional[str] = None,
                 url: Optional[str] = None):
        """
        :param bool temporarily_disabled: Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        :param str type: Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        :param str url: The destination URL for webhook delivery.
        """
        if temporarily_disabled is not None:
            pulumi.set(__self__, "temporarily_disabled", temporarily_disabled)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="temporarilyDisabled")
    def temporarily_disabled(self) -> Optional[bool]:
        """
        Whether this webhook subscription is temporarily disabled. Becomes true if the delivery method URL is repeatedly rejected by the server.
        """
        return pulumi.get(self, "temporarily_disabled")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Indicates the type of the delivery method. Allowed and default value: `http_delivery_method`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        The destination URL for webhook delivery.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WebhookSubscriptionFilter(dict):
    def __init__(__self__, *,
                 type: str,
                 id: Optional[str] = None):
        """
        :param str type: The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        :param str id: The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        pulumi.set(__self__, "type", type)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of object being used as the filter. Allowed values are `account_reference`, `service_reference`, and `team_reference`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The id of the object being used as the filter. This field is required for all filter types except account_reference.
        """
        return pulumi.get(self, "id")


