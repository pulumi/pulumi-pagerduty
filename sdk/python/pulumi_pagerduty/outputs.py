# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union
from . import _utilities, _tables
from . import outputs

__all__ = [
    'EscalationPolicyRule',
    'EscalationPolicyRuleTarget',
    'RulesetRuleActions',
    'RulesetRuleActionsAnnotate',
    'RulesetRuleActionsEventAction',
    'RulesetRuleActionsExtraction',
    'RulesetRuleActionsPriority',
    'RulesetRuleActionsRoute',
    'RulesetRuleActionsSeverity',
    'RulesetRuleActionsSuppress',
    'RulesetRuleConditions',
    'RulesetRuleConditionsSubcondition',
    'RulesetRuleConditionsSubconditionParameter',
    'RulesetRuleTimeFrame',
    'RulesetRuleTimeFrameActiveBetween',
    'RulesetRuleTimeFrameScheduledWeekly',
    'RulesetTeam',
    'ScheduleLayer',
    'ScheduleLayerRestriction',
    'ServiceDependencyDependency',
    'ServiceDependencyDependencyDependentService',
    'ServiceDependencyDependencySupportingService',
    'ServiceIncidentUrgencyRule',
    'ServiceIncidentUrgencyRuleDuringSupportHours',
    'ServiceIncidentUrgencyRuleOutsideSupportHours',
    'ServiceScheduledAction',
    'ServiceScheduledActionAt',
    'ServiceSupportHours',
    'UserNotificationRuleContactMethod',
]

@pulumi.output_type
class EscalationPolicyRule(dict):
    def __init__(__self__, *,
                 escalation_delay_in_minutes: int,
                 targets: Sequence['outputs.EscalationPolicyRuleTarget'],
                 id: Optional[str] = None):
        """
        :param int escalation_delay_in_minutes: The number of minutes before an unacknowledged incident escalates away from this rule.
        :param str id: A target ID
        """
        pulumi.set(__self__, "escalation_delay_in_minutes", escalation_delay_in_minutes)
        pulumi.set(__self__, "targets", targets)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="escalationDelayInMinutes")
    def escalation_delay_in_minutes(self) -> int:
        """
        The number of minutes before an unacknowledged incident escalates away from this rule.
        """
        return pulumi.get(self, "escalation_delay_in_minutes")

    @property
    @pulumi.getter
    def targets(self) -> Sequence['outputs.EscalationPolicyRuleTarget']:
        return pulumi.get(self, "targets")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class EscalationPolicyRuleTarget(dict):
    def __init__(__self__, *,
                 id: str,
                 type: Optional[str] = None):
        """
        :param str id: A target ID
        :param str type: Can be `user`, `schedule`, `user_reference` or `schedule_reference`. Defaults to `user_reference`
        """
        pulumi.set(__self__, "id", id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        A target ID
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Can be `user`, `schedule`, `user_reference` or `schedule_reference`. Defaults to `user_reference`
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleActions(dict):
    def __init__(__self__, *,
                 annotates: Optional[Sequence['outputs.RulesetRuleActionsAnnotate']] = None,
                 event_actions: Optional[Sequence['outputs.RulesetRuleActionsEventAction']] = None,
                 extractions: Optional[Sequence['outputs.RulesetRuleActionsExtraction']] = None,
                 priorities: Optional[Sequence['outputs.RulesetRuleActionsPriority']] = None,
                 routes: Optional[Sequence['outputs.RulesetRuleActionsRoute']] = None,
                 severities: Optional[Sequence['outputs.RulesetRuleActionsSeverity']] = None,
                 suppresses: Optional[Sequence['outputs.RulesetRuleActionsSuppress']] = None):
        """
        :param Sequence['RulesetRuleActionsAnnotateArgs'] annotates: Note added to the event.
        :param Sequence['RulesetRuleActionsExtractionArgs'] extractions: Allows you to copy important data from one event field to another. Extraction rules must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax). Extraction objects consist of the following fields:
        :param Sequence['RulesetRuleActionsPriorityArgs'] priorities: The ID of the priority applied to the event.
        :param Sequence['RulesetRuleActionsRouteArgs'] routes: The ID of the service where the event will be routed.
        :param Sequence['RulesetRuleActionsSeverityArgs'] severities: The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        :param Sequence['RulesetRuleActionsSuppressArgs'] suppresses: Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        if annotates is not None:
            pulumi.set(__self__, "annotates", annotates)
        if event_actions is not None:
            pulumi.set(__self__, "event_actions", event_actions)
        if extractions is not None:
            pulumi.set(__self__, "extractions", extractions)
        if priorities is not None:
            pulumi.set(__self__, "priorities", priorities)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if severities is not None:
            pulumi.set(__self__, "severities", severities)
        if suppresses is not None:
            pulumi.set(__self__, "suppresses", suppresses)

    @property
    @pulumi.getter
    def annotates(self) -> Optional[Sequence['outputs.RulesetRuleActionsAnnotate']]:
        """
        Note added to the event.
        """
        return pulumi.get(self, "annotates")

    @property
    @pulumi.getter(name="eventActions")
    def event_actions(self) -> Optional[Sequence['outputs.RulesetRuleActionsEventAction']]:
        return pulumi.get(self, "event_actions")

    @property
    @pulumi.getter
    def extractions(self) -> Optional[Sequence['outputs.RulesetRuleActionsExtraction']]:
        """
        Allows you to copy important data from one event field to another. Extraction rules must use valid [RE2 regular expression syntax](https://github.com/google/re2/wiki/Syntax). Extraction objects consist of the following fields:
        """
        return pulumi.get(self, "extractions")

    @property
    @pulumi.getter
    def priorities(self) -> Optional[Sequence['outputs.RulesetRuleActionsPriority']]:
        """
        The ID of the priority applied to the event.
        """
        return pulumi.get(self, "priorities")

    @property
    @pulumi.getter
    def routes(self) -> Optional[Sequence['outputs.RulesetRuleActionsRoute']]:
        """
        The ID of the service where the event will be routed.
        """
        return pulumi.get(self, "routes")

    @property
    @pulumi.getter
    def severities(self) -> Optional[Sequence['outputs.RulesetRuleActionsSeverity']]:
        """
        The [severity level](https://support.pagerduty.com/docs/rulesets#section-set-severity-with-event-rules) of the event. Can be either `info`,`error`,`warning`, or `critical`.
        """
        return pulumi.get(self, "severities")

    @property
    @pulumi.getter
    def suppresses(self) -> Optional[Sequence['outputs.RulesetRuleActionsSuppress']]:
        """
        Controls whether an alert is [suppressed](https://support.pagerduty.com/docs/rulesets#section-suppress-but-create-triggering-thresholds-with-event-rules) (does not create an incident).
        """
        return pulumi.get(self, "suppresses")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleActionsAnnotate(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleActionsEventAction(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleActionsExtraction(dict):
    def __init__(__self__, *,
                 regex: Optional[str] = None,
                 source: Optional[str] = None,
                 target: Optional[str] = None):
        """
        :param str regex: The conditions that need to be met for the extraction to happen.
               * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        :param str source: Field where the data is being copied from.
        :param str target: Field where the data is being copied to.
        """
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if source is not None:
            pulumi.set(__self__, "source", source)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        The conditions that need to be met for the extraction to happen.
        * *NOTE: A rule can have multiple `extraction` objects attributed to it.*
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def source(self) -> Optional[str]:
        """
        Field where the data is being copied from.
        """
        return pulumi.get(self, "source")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Field where the data is being copied to.
        """
        return pulumi.get(self, "target")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleActionsPriority(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleActionsRoute(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleActionsSeverity(dict):
    def __init__(__self__, *,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleActionsSuppress(dict):
    def __init__(__self__, *,
                 threshold_time_amount: Optional[int] = None,
                 threshold_time_unit: Optional[str] = None,
                 threshold_value: Optional[int] = None,
                 value: Optional[bool] = None):
        """
        :param int threshold_time_amount: The number value of the `threshold_time_unit` before an incident is created.
        :param str threshold_time_unit: The `minutes`,`hours`, or `days` that the `threshold_time_amount` should be measured.
        :param int threshold_value: The number of alerts that should be suppressed.
        :param bool value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if threshold_time_amount is not None:
            pulumi.set(__self__, "threshold_time_amount", threshold_time_amount)
        if threshold_time_unit is not None:
            pulumi.set(__self__, "threshold_time_unit", threshold_time_unit)
        if threshold_value is not None:
            pulumi.set(__self__, "threshold_value", threshold_value)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter(name="thresholdTimeAmount")
    def threshold_time_amount(self) -> Optional[int]:
        """
        The number value of the `threshold_time_unit` before an incident is created.
        """
        return pulumi.get(self, "threshold_time_amount")

    @property
    @pulumi.getter(name="thresholdTimeUnit")
    def threshold_time_unit(self) -> Optional[str]:
        """
        The `minutes`,`hours`, or `days` that the `threshold_time_amount` should be measured.
        """
        return pulumi.get(self, "threshold_time_unit")

    @property
    @pulumi.getter(name="thresholdValue")
    def threshold_value(self) -> Optional[int]:
        """
        The number of alerts that should be suppressed.
        """
        return pulumi.get(self, "threshold_value")

    @property
    @pulumi.getter
    def value(self) -> Optional[bool]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleConditions(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 subconditions: Optional[Sequence['outputs.RulesetRuleConditionsSubcondition']] = None):
        """
        :param str operator: Operator to combine sub-conditions. Can be `and` or `or`.
        :param Sequence['RulesetRuleConditionsSubconditionArgs'] subconditions: List of sub-conditions that define the the condition.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if subconditions is not None:
            pulumi.set(__self__, "subconditions", subconditions)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Operator to combine sub-conditions. Can be `and` or `or`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def subconditions(self) -> Optional[Sequence['outputs.RulesetRuleConditionsSubcondition']]:
        """
        List of sub-conditions that define the the condition.
        """
        return pulumi.get(self, "subconditions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleConditionsSubcondition(dict):
    def __init__(__self__, *,
                 operator: Optional[str] = None,
                 parameters: Optional[Sequence['outputs.RulesetRuleConditionsSubconditionParameter']] = None):
        """
        :param str operator: Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        :param Sequence['RulesetRuleConditionsSubconditionParameterArgs'] parameters: Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        if operator is not None:
            pulumi.set(__self__, "operator", operator)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter
    def operator(self) -> Optional[str]:
        """
        Type of operator to apply to the sub-condition. Can be `exists`,`nexists`,`equals`,`nequals`,`contains`,`ncontains`,`matches`, or `nmatches`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.RulesetRuleConditionsSubconditionParameter']]:
        """
        Parameter for the sub-condition. It requires both a `path` and `value` to be set.
        """
        return pulumi.get(self, "parameters")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleConditionsSubconditionParameter(dict):
    def __init__(__self__, *,
                 path: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str value: Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[str]:
        return pulumi.get(self, "path")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Boolean value that indicates if the alert should be suppressed before the indicated threshold values are met.
        """
        return pulumi.get(self, "value")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleTimeFrame(dict):
    def __init__(__self__, *,
                 active_betweens: Optional[Sequence['outputs.RulesetRuleTimeFrameActiveBetween']] = None,
                 scheduled_weeklies: Optional[Sequence['outputs.RulesetRuleTimeFrameScheduledWeekly']] = None):
        """
        :param Sequence['RulesetRuleTimeFrameActiveBetweenArgs'] active_betweens: Values for executing the rule during a specific time period.
        :param Sequence['RulesetRuleTimeFrameScheduledWeeklyArgs'] scheduled_weeklies: Values for executing the rule on a recurring schedule.
        """
        if active_betweens is not None:
            pulumi.set(__self__, "active_betweens", active_betweens)
        if scheduled_weeklies is not None:
            pulumi.set(__self__, "scheduled_weeklies", scheduled_weeklies)

    @property
    @pulumi.getter(name="activeBetweens")
    def active_betweens(self) -> Optional[Sequence['outputs.RulesetRuleTimeFrameActiveBetween']]:
        """
        Values for executing the rule during a specific time period.
        """
        return pulumi.get(self, "active_betweens")

    @property
    @pulumi.getter(name="scheduledWeeklies")
    def scheduled_weeklies(self) -> Optional[Sequence['outputs.RulesetRuleTimeFrameScheduledWeekly']]:
        """
        Values for executing the rule on a recurring schedule.
        """
        return pulumi.get(self, "scheduled_weeklies")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleTimeFrameActiveBetween(dict):
    def __init__(__self__, *,
                 end_time: Optional[int] = None,
                 start_time: Optional[int] = None):
        """
        :param int end_time: Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        :param int start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[int]:
        """
        Ending of the scheduled time when the rule should execute.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetRuleTimeFrameScheduledWeekly(dict):
    def __init__(__self__, *,
                 duration: Optional[int] = None,
                 start_time: Optional[int] = None,
                 timezone: Optional[str] = None,
                 weekdays: Optional[Sequence[int]] = None):
        """
        :param int duration: Length of time the schedule will be active.  Unix timestamp in milliseconds.
        :param int start_time: Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        :param str timezone: Timezone for the given schedule.
        :param Sequence[int] weekdays: An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timezone is not None:
            pulumi.set(__self__, "timezone", timezone)
        if weekdays is not None:
            pulumi.set(__self__, "weekdays", weekdays)

    @property
    @pulumi.getter
    def duration(self) -> Optional[int]:
        """
        Length of time the schedule will be active.  Unix timestamp in milliseconds.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[int]:
        """
        Time when the schedule will start. Unix timestamp in milliseconds. For example, if you have a rule with a `start_time` of `0` and a `duration` of `60,000` then that rule would be active from `00:00` to `00:01`. If the `start_time` was `3,600,000` the it would be active starting at `01:00`.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def timezone(self) -> Optional[str]:
        """
        Timezone for the given schedule.
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def weekdays(self) -> Optional[Sequence[int]]:
        """
        An integer array representing which days during the week the rule executes. For example `weekdays = [1,3,7]` would execute on Monday, Wednesday and Sunday.
        """
        return pulumi.get(self, "weekdays")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class RulesetTeam(dict):
    def __init__(__self__, *,
                 id: str):
        """
        :param str id: The ID of the ruleset.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the ruleset.
        """
        return pulumi.get(self, "id")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleLayer(dict):
    def __init__(__self__, *,
                 rotation_turn_length_seconds: int,
                 rotation_virtual_start: str,
                 start: str,
                 users: Sequence[str],
                 end: Optional[str] = None,
                 id: Optional[str] = None,
                 name: Optional[str] = None,
                 restrictions: Optional[Sequence['outputs.ScheduleLayerRestriction']] = None):
        """
        :param int rotation_turn_length_seconds: The duration of each on-call shift in `seconds`.
        :param str rotation_virtual_start: The effective start time of the schedule layer. This can be before the start time of the schedule.
        :param str start: The start time of the schedule layer. This value will not be read back from the PagerDuty API because the API will always return a new `start` time, which represents the last updated time of the schedule layer.
        :param Sequence[str] users: The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        :param str end: The end time of the schedule layer. If not specified, the layer does not end.
        :param str id: The ID of the schedule
        :param str name: The name of the schedule layer.
        :param Sequence['ScheduleLayerRestrictionArgs'] restrictions: A schedule layer restriction block. Restriction blocks documented below.
        """
        pulumi.set(__self__, "rotation_turn_length_seconds", rotation_turn_length_seconds)
        pulumi.set(__self__, "rotation_virtual_start", rotation_virtual_start)
        pulumi.set(__self__, "start", start)
        pulumi.set(__self__, "users", users)
        if end is not None:
            pulumi.set(__self__, "end", end)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if restrictions is not None:
            pulumi.set(__self__, "restrictions", restrictions)

    @property
    @pulumi.getter(name="rotationTurnLengthSeconds")
    def rotation_turn_length_seconds(self) -> int:
        """
        The duration of each on-call shift in `seconds`.
        """
        return pulumi.get(self, "rotation_turn_length_seconds")

    @property
    @pulumi.getter(name="rotationVirtualStart")
    def rotation_virtual_start(self) -> str:
        """
        The effective start time of the schedule layer. This can be before the start time of the schedule.
        """
        return pulumi.get(self, "rotation_virtual_start")

    @property
    @pulumi.getter
    def start(self) -> str:
        """
        The start time of the schedule layer. This value will not be read back from the PagerDuty API because the API will always return a new `start` time, which represents the last updated time of the schedule layer.
        """
        return pulumi.get(self, "start")

    @property
    @pulumi.getter
    def users(self) -> Sequence[str]:
        """
        The ordered list of users on this layer. The position of the user on the list determines their order in the layer.
        """
        return pulumi.get(self, "users")

    @property
    @pulumi.getter
    def end(self) -> Optional[str]:
        """
        The end time of the schedule layer. If not specified, the layer does not end.
        """
        return pulumi.get(self, "end")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The ID of the schedule
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name of the schedule layer.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def restrictions(self) -> Optional[Sequence['outputs.ScheduleLayerRestriction']]:
        """
        A schedule layer restriction block. Restriction blocks documented below.
        """
        return pulumi.get(self, "restrictions")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ScheduleLayerRestriction(dict):
    def __init__(__self__, *,
                 duration_seconds: int,
                 start_time_of_day: str,
                 type: str,
                 start_day_of_week: Optional[int] = None):
        """
        :param int duration_seconds: The duration of the restriction in `seconds`.
        :param str start_time_of_day: The start time in `HH:mm:ss` format.
        :param str type: Can be `daily_restriction` or `weekly_restriction`
        :param int start_day_of_week: Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        pulumi.set(__self__, "duration_seconds", duration_seconds)
        pulumi.set(__self__, "start_time_of_day", start_time_of_day)
        pulumi.set(__self__, "type", type)
        if start_day_of_week is not None:
            pulumi.set(__self__, "start_day_of_week", start_day_of_week)

    @property
    @pulumi.getter(name="durationSeconds")
    def duration_seconds(self) -> int:
        """
        The duration of the restriction in `seconds`.
        """
        return pulumi.get(self, "duration_seconds")

    @property
    @pulumi.getter(name="startTimeOfDay")
    def start_time_of_day(self) -> str:
        """
        The start time in `HH:mm:ss` format.
        """
        return pulumi.get(self, "start_time_of_day")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Can be `daily_restriction` or `weekly_restriction`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="startDayOfWeek")
    def start_day_of_week(self) -> Optional[int]:
        """
        Number of the day when restriction starts. From 1 to 7 where 1 is Monday and 7 is Sunday.
        """
        return pulumi.get(self, "start_day_of_week")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceDependencyDependency(dict):
    def __init__(__self__, *,
                 dependent_services: Sequence['outputs.ServiceDependencyDependencyDependentService'],
                 supporting_services: Sequence['outputs.ServiceDependencyDependencySupportingService'],
                 type: Optional[str] = None):
        """
        :param Sequence['ServiceDependencyDependencyDependentServiceArgs'] dependent_services: The service that id dependent on the supporting service.
        :param Sequence['ServiceDependencyDependencySupportingServiceArgs'] supporting_services: The service that supports  the  dependent service.
        """
        pulumi.set(__self__, "dependent_services", dependent_services)
        pulumi.set(__self__, "supporting_services", supporting_services)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="dependentServices")
    def dependent_services(self) -> Sequence['outputs.ServiceDependencyDependencyDependentService']:
        """
        The service that id dependent on the supporting service.
        """
        return pulumi.get(self, "dependent_services")

    @property
    @pulumi.getter(name="supportingServices")
    def supporting_services(self) -> Sequence['outputs.ServiceDependencyDependencySupportingService']:
        """
        The service that supports  the  dependent service.
        """
        return pulumi.get(self, "supporting_services")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceDependencyDependencyDependentService(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The ID of the service dependency.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceDependencyDependencySupportingService(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The ID of the service dependency.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the service dependency.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceIncidentUrgencyRule(dict):
    def __init__(__self__, *,
                 type: str,
                 during_support_hours: Optional['outputs.ServiceIncidentUrgencyRuleDuringSupportHours'] = None,
                 outside_support_hours: Optional['outputs.ServiceIncidentUrgencyRuleOutsideSupportHours'] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        :param 'ServiceIncidentUrgencyRuleDuringSupportHoursArgs' during_support_hours: Incidents' urgency during support hours.
        :param 'ServiceIncidentUrgencyRuleOutsideSupportHoursArgs' outside_support_hours: Incidents' urgency outside of support hours.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        pulumi.set(__self__, "type", type)
        if during_support_hours is not None:
            pulumi.set(__self__, "during_support_hours", during_support_hours)
        if outside_support_hours is not None:
            pulumi.set(__self__, "outside_support_hours", outside_support_hours)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="duringSupportHours")
    def during_support_hours(self) -> Optional['outputs.ServiceIncidentUrgencyRuleDuringSupportHours']:
        """
        Incidents' urgency during support hours.
        """
        return pulumi.get(self, "during_support_hours")

    @property
    @pulumi.getter(name="outsideSupportHours")
    def outside_support_hours(self) -> Optional['outputs.ServiceIncidentUrgencyRuleOutsideSupportHours']:
        """
        Incidents' urgency outside of support hours.
        """
        return pulumi.get(self, "outside_support_hours")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceIncidentUrgencyRuleDuringSupportHours(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceIncidentUrgencyRuleOutsideSupportHours(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None,
                 urgency: Optional[str] = None):
        """
        :param str type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        :param str urgency: The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)
        if urgency is not None:
            pulumi.set(__self__, "urgency", urgency)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def urgency(self) -> Optional[str]:
        """
        The urgency: `low` Notify responders (does not escalate), `high` (follows escalation rules) or `severity_based` Set's the urgency of the incident based on the severity set by the triggering monitoring tool.
        """
        return pulumi.get(self, "urgency")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceScheduledAction(dict):
    def __init__(__self__, *,
                 ats: Optional[Sequence['outputs.ServiceScheduledActionAt']] = None,
                 to_urgency: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence['ServiceScheduledActionAtArgs'] ats: A block representing when the scheduled action will occur.
        :param str to_urgency: The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        :param str type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        if ats is not None:
            pulumi.set(__self__, "ats", ats)
        if to_urgency is not None:
            pulumi.set(__self__, "to_urgency", to_urgency)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ats(self) -> Optional[Sequence['outputs.ServiceScheduledActionAt']]:
        """
        A block representing when the scheduled action will occur.
        """
        return pulumi.get(self, "ats")

    @property
    @pulumi.getter(name="toUrgency")
    def to_urgency(self) -> Optional[str]:
        """
        The urgency to change to: `low` (does not escalate), or `high` (follows escalation rules).
        """
        return pulumi.get(self, "to_urgency")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceScheduledActionAt(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str name: Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
        :param str type: The type of time specification. Currently, this must be set to `named_time`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Designates either the start or the end of the scheduled action. Can be `support_hours_start` or `support_hours_end`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of time specification. Currently, this must be set to `named_time`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class ServiceSupportHours(dict):
    def __init__(__self__, *,
                 days_of_weeks: Optional[Sequence[int]] = None,
                 end_time: Optional[str] = None,
                 start_time: Optional[str] = None,
                 time_zone: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param Sequence[int] days_of_weeks: Array of days of week as integers. `1` to `7`, `1` being
               Monday and `7` being Sunday.
        :param str end_time: The support hours' ending time of day.
        :param str start_time: The support hours' starting time of day.
        :param str time_zone: The time zone for the support hours.
        :param str type: The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[Sequence[int]]:
        """
        Array of days of week as integers. `1` to `7`, `1` being
        Monday and `7` being Sunday.
        """
        return pulumi.get(self, "days_of_weeks")

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[str]:
        """
        The support hours' ending time of day.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[str]:
        """
        The support hours' starting time of day.
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        The time zone for the support hours.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The type of scheduled action. Currently, this must be set to `urgency_change`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


@pulumi.output_type
class UserNotificationRuleContactMethod(dict):
    def __init__(__self__, *,
                 id: str,
                 type: str):
        """
        :param str id: The id of the referenced contact method.
        :param str type: The type of contact method. Can be `email_contact_method`, `phone_contact_method`, `push_notification_contact_method` or `sms_contact_method`.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The id of the referenced contact method.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        The type of contact method. Can be `email_contact_method`, `phone_contact_method`, `push_notification_contact_method` or `sms_contact_method`.
        """
        return pulumi.get(self, "type")

    def _translate_property(self, prop):
        return _tables.CAMEL_TO_SNAKE_CASE_TABLE.get(prop) or prop


